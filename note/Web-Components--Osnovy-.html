  
<html>
  <head>
    <meta charset="utf-8">
    <title>Web Components. Основы</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="format-detection" content="telephone=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="MobileOptimized" content="176">
    <meta name="HandheldFriendly" content="True">
    <meta name="robots" content="index, follow">
    <meta name="description" content="Базовые вещи касательно Web Components. Способы создания элементов веб-страницы на основе Web Components. Четыре спецификации Web Components. Фундаментальные аспекты компонентов.">
    <meta property="og:site_name" content="inscriptum">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Web Components. Основы">
    <meta property="og:description" content="Базовые вещи касательно Web Components. Способы создания элементов веб-страницы на основе Web Components. Четыре спецификации Web Components. Фундаментальные аспекты компонентов.">
    <meta property="og:image" content="https://inscriptum.js.org/data/articles/webcomponents-base/images/recipe.jpg">
    <meta property="article:published_time" content="2019-09-26T03:19:34.000Z">
    <meta property="article:modified_time" content="2019-09-26T03:19:34.000Z">
    <meta property="article:author" content="test@test.test">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Web Components. Основы">
    <meta name="twitter:description" content="Базовые вещи касательно Web Components. Способы создания элементов веб-страницы на основе Web Components. Четыре спецификации Web Components. Фундаментальные аспекты компонентов.">
    <meta name="twitter:image" content="https://inscriptum.js.org/data/articles/webcomponents-base/images/recipe.jpg">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link href="/css/note.css" rel="stylesheet">
    <link href="/css/custom_editor_fonts.css" rel="stylesheet">
  </head>
  <body>
    <div class="tl_page_wrap">

    <div class="tl_page">
      <section class="tl_article title_focused">
        <header class="tl_article_header">
          <h1 dir="auto">Web Components. Основы</h1>
          <address dir="auto">
            <a rel="author">Базовые вещи касательно Web Components. Способы создания элементов веб-страницы на основе Web Components. Четыре спецификации Web Components. Фундаментальные аспекты компонентов.</a>
            <time datetime=""></time>
          </address>
        </header>
        <article id="_tl_editor" class="tl_article_content ql-container ql-disabled"><div class="ql-editor" data-gramm="false" contenteditable="false" dir="auto"><h3 id="Что-из-себя-представляют-Web-Components">Что из себя представляют Web Components</h3><p>Рецепт Web Components прост - это три фундаментальных блока: HTML, CSS и JavaScript.</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/recipe.jpg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>HTML определяет каркас компонента, является разметкой как и для обычной страницы. CSS отвечает за визуальное отображение. JavaScript - это логика компонента, его поведение и функциональность. Спецификации Web Components позволяют нам использовать эти три технологии вместе для построения собственных компонентов. Отсутствие дополнительных требований и инструментов существенно упрощают создание и использование таких компонентов как отдельно, так и внутри уже существующих приложений.</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/wc.jpg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Компоненты, создаваемые на основе принципов Web Components, на сегодняшний день, имеют максимальную модульность, гибкость и переиспользуемость. Независимость от иного контента на странице дает возможность не беспокоиться о неправильном отображении.</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-root.png"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>А наследование и переиспользование уже существующих компонентов делают их универсальным инструментом для приложений любых масштабов. Но, пожалуй, основным достоинством Web Components остается их простота - разработчикам нет необходимости изучать дополнительные фреймворки и библиотеки, все, что нужно - это HTML, CSS и JavaScript.</p><p>Таким образом достигаются следующие цели:</p><ul start="null" style="counter-reset: list-0 0 null 0;"><li>изоляция стилей;</li><li>отсутствие зависимостей в виде библиотек и фреймворков;</li><li>универсальность и простота компонентов.</li></ul><h3 id="Спецификации-Web-Components">Спецификации Web Components</h3><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/spec.jpeg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Web Components состоит из четырех спецификаций:</p><ul start="null" style="counter-reset: list-0 0 null 0;"><li>Custom Elements</li><li>Shadow DOM</li><li>HTML Templates</li><li>HTML Imports</li></ul><p>Каждая из этих спецификаций предоставляет отдельную функциональность для создания и использования компонентов. </p><h3 id="Custom-Elements">Custom Elements</h3><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/custom-elements.jpeg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Custom Elements описывает как создавать собственные DOM элементы, добавлять свойства и функции к ним, а также расширять их на основе уже существующих элементов. Для создания пользовательского DOM элемента необходимо использовать классы ES2015. Рассмотрим создание пользовательского элемента на простом примере.</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Custom Elements<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l">&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstCustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{</span>
<span class="l">&nbsp; &nbsp; &nbsp; <span class="hljs-keyword">constructor</span>() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">super</span>();</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'constructor'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; }</span>
<span class="l">&nbsp;&nbsp;</span>
<span class="l">&nbsp; &nbsp; <span class="hljs-built_in">window</span>.customElements.define(<span class="hljs-string">'first-custom-element'</span>, FirstCustomElement);</span>
<span class="l">&nbsp; </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">first-custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">first-custom-element</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>&nbsp;</span>
<span class="l"></span></span></code></pre><p>Был создан класс расширяющий нативный HTMLElement. Таким образом мы унаследовали функции самого базового DOM элемента. Внутри класса определен конструктор, который будет вызван при создании элемента. В конструкторе обязательно необходимо вызвать метод super() чтобы выполнился конструктор базового класса. Наконец, вызываем метод window.customElements.define, определенный в спецификации Custom Elements v1. На вход он принимает название тега, который в дальнейшем будет использован на странице и, собственно, класс для создания элемента. Теперь мы можем в теле документа вставить наш элемент, после чего в консоли выведется сообщение из метода конструктора.</p><p>Помимо конструктора в Custom Elements присутствует ряд методов, предоставляемых API и описанных в спецификации, как методы жизненного цикла (lifecycle hooks). Они используются для выполнения определенных участков кода в отдельные периоды “жизни” компонента.</p><p>Рассмотрим три наиболее употребимых из них. Для этого изменим предыдущий пример следующим образом:</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Custom Elements<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstCustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">constructor</span>() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">super</span>();</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'constructor'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connectedCallback() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'connectedCallback'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> observedAttributes() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">return</span> [<span class="hljs-string">'test'</span>]</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; attributeChangedCallback(name, oldValue, newValue) {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'attributeChangedCallback '</span>, name, oldValue, newValue);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; disconnectedCallback() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'disconnectedCallback'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">window</span>.customElements.define(<span class="hljs-string">'first-custom-element'</span>, FirstCustomElement);</span>
<span class="l">&nbsp; &nbsp; </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">first-custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">first-custom-element</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><ul start="null" style="counter-reset: list-0 0 null 0;"><li><strong>connectedCallback</strong> выполняется в момент добавления элемента к DOM;</li><li><strong>attributeChangedCallback</strong> метод выполняемый в момент изменения атрибутов. Он позволяет подписываться на изменения определенных атрибутов. Для того, чтобы можно было указать какие именно из них отслеживать статический метод observedAttributes должен вернуть их в виде массива текстовых значений.</li><li><strong>disconnectedCallback</strong> выполняется в момент удаления элемента из DOM. Данный метод наиболее удобен, если необходимо выполнить некоторую работу (удалить интервалы, очистить дополнительные данные) после удаления.</li></ul><p><strong>Расширение Custom Elements</strong>&nbsp;- это возможность создавать свои элементы, основываясь на уже созданных ранее. Для понимания рассмотрим пример.</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Custom Elements<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloCustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLElement</span> </span>{</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; sayHello() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello!'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">window</span>.customElements.define(<span class="hljs-string">'hello-custom-element'</span>, HelloCustomElement);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HowAreYouCustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HelloCustomElement</span> </span>{</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">constructor</span>() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">super</span>();</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.howAreYou();</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; howAreYou() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.sayHello();</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'How are you!'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">window</span>.customElements.define(<span class="hljs-string">'howareyou-custom-element'</span>, HowAreYouCustomElement);</span>
<span class="l">&nbsp; &nbsp; </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">howareyou-custom-element</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">howareyou-custom-element</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><p>После выполнения в консоли будет выведено:</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l">Hello!</span>
<span class="l">How are you!</span>
</code></pre><p><strong>Расширение Custom Elements на основе стандартных элементов</strong>&nbsp;- еще одна очень важная функция при создании своих элементов. Если необходимо добавить небольшой функционал к стандартному DOM элементу это можно сделать через его расширение. Предположим, что у нас есть input, в котором при его создании должно появиться подготовленное заранее содержимое.</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Custom Elements<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/document-register-element/1.5.0/document-register-element.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloInputCustomElement</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HTMLInputElement</span> </span>{</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; connectedCallback() {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">'value'</span>, <span class="hljs-string">'Hello'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">window</span>.customElements.define(</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-string">'helloinput-custom-element'</span>,&nbsp;</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; HelloInputCustomElement, {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">extends</span>: <span class="hljs-string">'input'</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; );</span>
<span class="l">&nbsp; &nbsp; </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">is</span>=<span class="hljs-string">"helloinput-custom-element"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><p>В результате, после создания в нашем элементе input будет содержаться текст <code>Hello</code>. Для расширения стандартного элемента мы выполнили следующие шаги:</p><ol start="null" style="counter-reset: list-0 0 null 0;"><li>Унаследовались от расширяемого элемента extends HTMLInputElement.</li><li>При создании элемента добавили тег расширяемого элемента <code>window.customElements.define('helloinput-custom-element', HelloInputCustomElement, {extends: 'input'}).</code></li><li>В документе наш элемент используется через указание атрибута is в стандартном теге.</li><li>Важно! На данный момент расширение стандартных элементов не реализовано в большинстве браузеров, поэтому необходимо воспользоваться&nbsp;<a href="https://github.com/WebReflection/document-register-element#using-innerhtml" target="_blank">поллифилом</a>&nbsp;выше мы подключили его через cdn.</li></ol><p>Итак, мы рассмотрели, пожалуй, основную из спецификаций Web Components. Custom Elements является ядром компонента, именно с неё начинается его создание.</p><h3 id="Shadow-DOM">Shadow DOM</h3><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-dom.jpeg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Следующая из спецификаций Web Components называется Shadow DOM. Она позволяет создавать дополнительное DOM дерево для создаваемого элемента. Особенность такого внутреннего DOM дерева заключается в его инкапсуляции - независимости от основного DOM дерева.</p><p>Существует два способа использования Shadow DOM - в закрытом и открытом виде:</p><ul start="null" style="counter-reset: list-0 0 null 0;"><li><strong>open</strong> - открытый тип, позволяет получить полный контроль над дополнительным DOM-ом;</li><li><strong>close</strong> - закрытый тип, не позволяет манипулировать дополнительным DOM-ом после его создания.</li></ul><p>Рассмотрим пример кода:</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l">	<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l">	 </span>
<span class="l">	<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Shadow DOM<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span>
<span class="l">	        <span class="hljs-selector-tag">input</span> {</span>
<span class="l">	            <span class="hljs-attribute">border-color</span>: red;</span>
<span class="l">	            <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span>
<span class="l">	        }</span>
<span class="l">	    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
<span class="l">	<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">	</span>
<span class="l"> </span>
<span class="l">	<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> /&gt;</span></span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"hello"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> /&gt;</span></span>
<span class="l">	</span>
<span class="l"> </span>
<span class="l">	    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="xml"></span>
<span class="l">	        let $helloDiv = document.getElementById('hello');</span>
<span class="l">	        $helloDiv.attachShadow({</span>
<span class="l">	            mode: "open"</span>
<span class="l">	        });</span>
<span class="l">	        $helloDiv.shadowRoot.innerHTML =</span>
<span class="l">	            `<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span>
<span class="l">	                <span class="hljs-selector-tag">input</span> {</span>
<span class="l">	                <span class="hljs-attribute">border</span>: none;</span>
<span class="l">	                }</span>
<span class="l">	            </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span>
<span class="l">				<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"hello"</span>/&gt;</span>`</span>
<span class="l">             ;</span>
<span class="l">  	    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l">  	<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">  	</span>
<span class="l">  	<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><p>В результате его исполнения браузер отобразит три input элемента, два из них с красной рамкой и один без нее:</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-dom_example.png"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Такой результат получился в результате использования функции attachShadow и добавления дополнительного содержимого через shadowRoot.innerHTML. Если посмотреть в инспектор кода, то можно увидеть структуру дерева дополнительного DOM.</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-root.png"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Дополнительное содержимое было добавлено в shadow-root. Это позволяет компонентам не влиять на общие стили страницы и не испытывать их влияние на себе.</p><h3 id="HTML-Templates">HTML Templates</h3><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/html-templates.jpeg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>HTML Templates позволяет создавать шаблоны на основе HTML. Такие шаблоны обладают рядом особенностей:</p><ol start="null" style="counter-reset: list-0 0 null 0;"><li>Создаются с помощью тега&nbsp;.</li><li>Не отображаются в браузере до момента их явного использования.</li><li>Могут быть использованы для определения разметки компонента и её дальнейшего рендеринга во время создания.</li></ol><p>Для использования шаблона достаточно создать разметку внутри тега template:</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTML Templates<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"task"</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Task name<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Task body<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"> </span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">ui</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"todo-list"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ui</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"> </span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> tasks = [{</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">name</span>: <span class="hljs-string">"Сделать зарядку"</span>,</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">body</span>: <span class="hljs-string">"Разминка, пробежка, подтягивание на перекладине"</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">name</span>: <span class="hljs-string">"Купить продукты"</span>,</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">body</span>: <span class="hljs-string">"Хлеб, овощи, чай"</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">name</span>: <span class="hljs-string">"Подготовить доклад"</span>,</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-attr">body</span>: <span class="hljs-string">"Найти проблему, описать суть, найти решение"</span></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; ];</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> $template = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'task'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> $todoList = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'todo-list'</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; tasks.forEach(<span class="hljs-function"><span class="hljs-params">task</span> =&gt;</span> {</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> $clone = <span class="hljs-built_in">document</span>.importNode($template.content, <span class="hljs-literal">true</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $clone.querySelector(<span class="hljs-string">'h1'</span>).innerText = task.name;</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $clone.querySelector(<span class="hljs-string">'p'</span>).innerText = task.body;</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $todoList.appendChild($clone);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; });</span>
<span class="l">&nbsp; &nbsp; </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><p>В примере выше у нас есть список задач и шаблон для отображения отдельной задачи. С помощью функции document.importNode мы создаем клон шаблона (глубокое клонирование при помощи второго параметра со значением true). Далее измененный шаблон добавляется к элементу списка задач функцией appendChild. Как видно из примера, шаблон был переиспользован несколько раз внутри цикла.</p><p>HTML Templates является наиболее устоявшейся из спецификаций, она реализована во всех современных браузерах.</p><h3 id="HTML-Imports">HTML Imports</h3><figure contenteditable="false"><div class="figure_wrapper"><img src="https://inscriptum.js.org/data/articles/webcomponents-base/images/html-imports.jpeg"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>Последней из спецификаций Web Components является HTML Imports. Как и следует из её названия она описывает способ импорта html файла. Это можно сравнить с импортом css файла внутри страницы. Только в данном случае вместо разметки стилей будет загружен файл с одним или более компонентами.</p><p>Для демонстрации создадим два файла. Первый hello.html с содержимым:</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span></span>
<span class="l">  </span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello Web Components!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><p>Второй index.html:</p><pre class="ql-syntax" spellcheck="false"><code class="hljs"><span class="l"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>HTML Imports<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"import"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"hello.html"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"hello"</span> /&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span>
<span class="l">&nbsp; &nbsp; <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> $link = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"hello"</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-keyword">const</span> content = $link.import.querySelector(<span class="hljs-string">"h1"</span>);</span>
<span class="l">&nbsp; &nbsp; &nbsp; &nbsp; <span class="hljs-built_in">document</span>.body.appendChild(content.cloneNode(<span class="hljs-literal">true</span>));</span>
<span class="l">&nbsp; &nbsp; </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span>
<span class="l"> </span>
<span class="l"> </span>
<span class="l"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span> </span>
<span class="l"></span></span></code></pre><p>Открытие страницы index выведет заголовок из файла hello.html.</p><p>HTML Imports является наиболее спорной из всех спецификаций, на сегодняшний день она реализована только в браузере Chrome и Opera. К тому же, смысл работы данной спецификации выглядит несколько избыточным с появлением динамических импортов в ES2015. Тем не менее, функция загрузки компонентов через импорт html файла существует и может оказаться весьма нужной в отдельных случаях.</p><h3 id="Итог">Итог</h3><p>На этом мы закончили рассмотрение основ Web Components. Познакомились с целями, которые позволяют достичь компоненты и как эти цели коррелируют с четырьмя спецификациями:</p><ul start="null" style="counter-reset: list-0 0 null 0;"><li>Custom Elements - создание элемента внутри страницы со своим жизненным циклом, разметкой и логикой отображения.</li><li>Shadow DOM - дополнительный DOM внутри страницы, позволяющий добиться инкапсуляции стилей.</li><li>HTML Templates - шаблон для переиспользуемых частей внутри компонентов.</li><li>HTML Imports - импорт html файлов внутри основной страницы.</li></ul><h3 id="Ссылки">Ссылки</h3><ul start="null" style="counter-reset: list-0 0 null 0;"><li><a href="https://github.com/webcomponents/webcomponentsjs" target="_blank"><strong>webcomponentsjs</strong></a>&nbsp;и&nbsp;<a href="https://www.webcomponents.org/polyfills" target="_blank"><strong>polyfills</strong></a>&nbsp;- полифиллы и как их использовать (для работы еще нереализованных спецификаций в браузерах).</li><li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/customelements" target="_blank"><strong>Custom Elements</strong></a>.</li><li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom" target="_blank"><strong>Shadow DOM</strong></a>.</li><li><a href="https://www.html5rocks.com/en/tutorials/webcomponents/template/" target="_blank"><strong>HTML Templates</strong></a>.</li><li><a href="https://www.html5rocks.com/en/tutorials/webcomponents/imports/" target="_blank"><strong>HTML Imports</strong></a>.</li></ul></div></article>
        
        <aside class="tl_article_buttons">
          
          <a id="_edit_button" class="button edit_button" href="/editor/ck104pji1024b0161h5vsalch/posted">Edit</a>
          
          
          
        </aside>
      </section>
    </div>
  </div>
  </body>
  <script type="text/javascript" src="/js/vendor.js"></script>
  <script type="text/javascript" src="/js/note.js"></script>
</html>