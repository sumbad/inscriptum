<html>
<head>
  <meta charset="utf-8">
  <title>Разделение frontend и backend, с сохранением взаимопонимания</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="MobileOptimized" content="176">
  <meta name="HandheldFriendly" content="True">
  <meta name="robots" content="index, follow">
  <meta property="og:site_name" content="inscriptum">
  <meta property="og:type" content="article">
  <meta property="og:title" content="Разделение frontend и backend, с сохранением взаимопонимания">
  <meta property="og:description" content="Несколько лет назад мне попалась небольшая статья в журнале, ученый рассказывал о процессе обучения. Отмечалось, что для полноценного получения знаний нужно всё больше и больше времени, а в недалеком будущем этот процесс может быть равен 80-ти годам жизни. Видимо, в IT это будущее уже настало.
Мне посчастливилось, я начинал программировать в те годы, когда не было разделение на backend и frontend программистов, когда не звучали слова UX, прототип, QA и продуктолог. Мир был проще, деревья были выше и зеленее, воздух чище, а во дворах играли дети, а не парковались автомобили. Как бы мне ни хотелось вернуться в те годы, нужно признать, что всё это не замысел какого-то суперзлодея, а ход эволюционного развития общества. Да, общество могло начать развиваться и иначе, но как говорится история не терпит сослагательных наклонений. 
Предыстория...">
  <meta property="og:image" content="https://res.cloudinary.com/inscriptum/image/upload/v1554174759/blob_b1sj1n.png">
  <!-- <meta property="article:published_time" content="..."> -->
  <!-- <meta property="article:modified_time" content="..."> -->
  <meta property="article:author" content="Независимый frontend и backend">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Разделение frontend и backend, с сохранением взаимопонимания">
  <meta name="twitter:description" content="Несколько лет назад мне попалась небольшая статья в журнале, ученый рассказывал о процессе обучения. Отмечалось, что для полноценного получения знаний нужно всё больше и больше времени, а в недалеком будущем этот процесс может быть равен 80-ти годам жизни. Видимо, в IT это будущее уже настало.
Мне посчастливилось, я начинал программировать в те годы, когда не было разделение на backend и frontend программистов, когда не звучали слова UX, прототип, QA и продуктолог. Мир был проще, деревья были выше и зеленее, воздух чище, а во дворах играли дети, а не парковались автомобили. Как бы мне ни хотелось вернуться в те годы, нужно признать, что всё это не замысел какого-то суперзлодея, а ход эволюционного развития общества. Да, общество могло начать развиваться и иначе, но как говорится история не терпит сослагательных наклонений. 
Предыстория...">
  <meta name="twitter:image" content="https://res.cloudinary.com/inscriptum/image/upload/v1554174759/blob_b1sj1n.png">
  <!-- <link rel="shortcut icon" href="/favicon.ico?1" type="image/x-icon"> -->
  <!-- <link rel="icon" type="image/png" href="/images/favicon.png?1" sizes="16x16"> -->
  <!-- <link rel="icon" type="image/png" href="/images/favicon_2x.png?1" sizes="32x32"> -->
  <link href="/css/core_editor.css" rel="stylesheet">
</head>
<body>

    <div class="tl_page">
      <section class="tl_article tl_article_editable title_focused tl_article_saving">
        <header class="tl_article_header">
          <h1 dir="auto">Разделение frontend и backend, с сохранением взаимопонимания</h1>
          <address dir="auto">
            <a rel="author">Независимый frontend и backend</a>
            <time datetime=""></time>
          </address>
        </header>
        <article id="_tl_editor" class="tl_article_content ql-container ql-disabled"><div class="ql-editor" data-gramm="false" contenteditable="false" dir="auto"><p>Несколько лет назад мне попалась небольшая статья в журнале, ученый рассказывал о процессе обучения. Отмечалось, что для полноценного получения знаний нужно всё больше и больше времени, а в недалеком будущем этот процесс может быть равен 80-ти годам жизни. Видимо, в IT это будущее уже настало.</p><p>Мне посчастливилось, я начинал программировать в те годы, когда не было разделение на backend и frontend программистов, когда не звучали слова UX, прототип, QA и продуктолог. Мир был проще, деревья были выше и зеленее, воздух чище, а во дворах играли дети, а не парковались автомобили. Как бы мне ни хотелось вернуться в те годы, нужно признать, что всё это не замысел какого-то суперзлодея, а ход эволюционного развития общества. Да, общество могло начать развиваться и иначе, но как говорится история не терпит сослагательных наклонений. </p><h3 id="Предыстория">Предыстория</h3><p>Продукт над которым работает наша команда тоже появился в те далекие годы, когда не было жесткого разделения по направлениям. Он имел неплохую согласованную архитектуру, умел хорошо управлять поведением пользователя и даже позволял расширять себя с помощью системы плагинов. Шло время, команда развивала продукт и вроде бы всё было хорошо, но стали прослеживаться странные явления. К примеру, когда программист занимался бизнес логикой, он как-то плохо начинал верстать формы, делал их неудобными и сложными для восприятия. Или, добавление, казалось бы простой функциональности оценивалось на несколько недель так как изначально жестко связанная архитектура отдельных модулей плохо подходила под изменение одного без корректировок в другом.</p><p>Про вопросы удобства, эргономики и глобального развития продукта вообще можно было забыть в моменты падения приложения с неизвестной ошибкой. Всё как у всех, когда продукт сравнительно небольшой и общие требования не столь высоки один программист успевал делать работу в разных направлениях. Когда же требования в каждом из этих направлений сильно возросли, а ты видишь картину в целом и прекрасно понимаешь, что если функция не будет правильно и стабильно работать, то все эти кнопочки, формочки, тесты, презентации и продвижения ничем не помогут. В итоге откладываешь всё вокруг и садишься за исправление работы этой злосчастной функции. После этого ты <strong>совершаешь</strong> свой маленький подвиг пусть он и останется никем неоцененным, но функция начинает работать. Собственно, как-то так и появились в нашей команде люди, ответственные за разные направления, чтобы эти маленькие подвиги дошли до клиентов, которым они действительно нужны.</p><p>Но изменение в составе команды было только первым шагом.  Использование одного технически сильно связанного приложения приводило к невозможности развивать продукт требуемыми темпами и периодически отражалось в "перетягивании одеяла" в разработке. Современный интерфейс часто модифицируется под нужды клиентов, что приводит к постоянным изменениям в структуре отображаемых данных. У нас это вело к необходимости менять логику backend'а, хотя структура самих данных чаще всего оставалась неизменной.</p><h3 id="Frontend-и-backend">Frontend и backend</h3><p>Стать профессионалом во всём долго и дорого. Поэтому современный мир прикладных программистов делится, в основной своей массе, на frontend и backend. Здесь вроде всё понятно: набираем frontend программистов, они теперь у нас будут отвечать за пользовательский интерфейс. У backend тоже всё хорошо: наконец они могут сфокусироваться на бизнес логике, моделях данных и других подкапотных вещах. При этом стоит отметить, что по сути backend, frontend, тестировщики и дизайнеры остаются единой командой. Они делают общий продукт, просто фокусируются на разных его частях. Под одной командой имею ввиду, что у них одно информационное и, желательно, территориальное пространство. То есть вместе обсуждают новые фичи и разбирают проделанную работу, согласовывают порядок совместных действий над одной задачей. У них одна цель и все это понимают.</p><p>Для какого-то абстрактного нового проекта на этом можно закончить, но у нас уже было написанное приложение и одна команда, а объемы планируемых работ и сроки их реализации явно указывали, что одной единой командой обойтись не получится. В футболе команда из 11 человек, в баскетболе из 5-ти, а у нас получалось, что будет команда из 30 участников. Под идеальную scrum команду из 5-9 человек это никак не подходило.</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://res.cloudinary.com/inscriptum/image/upload/v1554174759/blob_b1sj1n.png"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p><strong>Чтобы сдвинуться с места нужно было решить организационную и архитектурную проблему. </strong></p><h4 id="Архитектура">Архитектура</h4><p>Полностью убрать старое и писать новое - это хорошее решение, если есть адекватное и прогнозируемое время такой работы. В нашем случае даже при идеальных условиях приблизительный срок составлял годы. Помимо этого, специфика приложения такова, что для конечного потребителя было бы крайне сложно перейти со старого на новое при полном их различии. Нашим клиентам очень важна обратная совместимость. Её потеря и последующий отказ пользователей переходить на новую версию ставит под сомнение целесообразность такой работы. Было решено, что нужна модернизация архитектуры с сохранением максимальной обратной совместимости. </p><p>Как уже отмечалось ранее, наше приложение - это монолит, интерфейс которого строился на стороне сервера. Frontend только реализовывал полученные от него инструкции. Иными словами, за интерфейс пользователя отвечал не frontend, а backend. Архитектурно frontend и backend работали как одно целое - изменяя одно, были вынуждены менять другое. И это не самое страшное, наибольшей проблемой стала невозможность разработки пользовательского интерфейса без глубинных знаний того, что происходит на сервере. </p><p>Нужно было разделять frontend и backend, делать отдельные программные приложения, только так можно было начать развивать их требуемыми темпами и объемами. Но как делать хотя бы два проекта параллельно, сильно менять их структуру, если они сильно зависят друг от друга?  Решением стала дополнительная система - прослойка. Идея прослойки крайне проста - согласовать работы backend и frontend и взять на себя все дополнительные издержки. </p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://res.cloudinary.com/inscriptum/image/upload/v1554174888/blob_c5inrf.png"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text empty" data-placeholder="Caption (optional)"></figcaption></figure><p>К примеру, если происходит декомпозиция функции оплаты на стороне backend, то прослойка начинает их комбинировать, а на стороне frontend никаких дополнительных изменений не требуется. Другой пример, это когда на дашборде в пользовательском интерфейсе вместе с информацией о пользователе захотели выводить все заказанные им услуги, то не делать дополнительную функцию для этого на backend, а агрегировать данные в прослойке. Помимо этого прослойка должна была добавить определенности в том, что можно позвать у сервера и что в итоге вернется без знания внутреннего устройства функций, которые эту операцию исполняют.</p><h4 id="Коммуникации">Коммуникации</h4><p>Технически сильная зависимость между frontend и backend приводит к невозможности делать работу параллельно, и тем самым тормозит обе части команды. Разделив программно один большой проект на несколько мы получали свободу действий в каждом из них, но при этом сильно возросли требования к коммуникациям. Нужно было сохранить согласованность в работе. Кто-то скажет, что согласованность достигают с помощью повышения soft skills. Да, их нужно развивать, но это не панацея. К примеру, посмотрите на дорожное движение, там тоже важно, чтобы водители были взаимовежливы, умели объезжать случайные препятствия и помогали друг другу на дороге в сложных ситуациях. Но! Без правил дорожного движения мы, даже при наилучших коммуникациях, получили бы аварии на каждом перекрестке и огромные риски не доехать до пункта назначения в запланированное время.</p><p>Нам нужны были правила, которые было бы сложно нарушить. Как говорится, чтобы их было проще исполнять, чем не исполнять. Но любые законы помимо плюсов всегда несут накладные расходы, а нам очень не хотелось втягивать всех и сразу в этот процесс и тем самым тормозить основную работу. Из этих соображений родилась координационная группа, а потом и команда. По сути основной целью этой команды стало создание условий для успешной работы разных частей продукта. Они настроили интерфейсы, которые позволили разным проектам работать как одно целое. Сегодня мы называем эту команду API, хотя непосредственно техническая реализация нового API - это только малая часть их задач. Как и в коде, общие участки выносятся в отдельную функцию, так и команда API разбирает общие вопросы продуктовых команд. Именно здесь происходит соединение нашего frontend и backend, и чтобы всё прошло успешно нужно понимать специфику каждой из частей. </p><p>Возможно, название API и не самое хорошее, оно родилось из первых задач команды, сейчас больше подошло бы название говорящее, за архитектуру или масштабное видение. Думаю, что это мелочи и сути бы не изменило.</p><h3 id="API">API</h3><p>Интерфейс доступа к функциям на сервере существовал и в нашем начальном большом монолитном приложении, но выглядел достаточно хаотично с точки зрения потребителя. При разделении frontend и backend нужно было больше определенности.</p><p>Цели для нового API сформировались сами собой из наших ежедневных трудностей в реализации новых продуктовых и дизайнерских идей:</p><ol start="null" style="counter-reset: list-0 0 null 0;"><li>Слабая связанность компонентов системы. Параллельное развитие frontend и backend.</li><li>Высокая масштабируемость. Иными словами, новое API не должно стать для нас препятствием в наращивании функциональности.</li><li>Стабильность и согласованность.</li></ol><p>Весь research по API начали не с backend, как это обычно принято, а наоборот - подумали, что нужно пользователям нашего API. Понятно, что наиболее распространены решения в виде разного рода REST API. В последние годы к ним добавляют описательные модели через инструменты типо swagger, но нужно понимать, что это тот же REST. И по сути, самым главным его плюсом и минусом являются правила, которые носят исключительно описательный характер. Это значит, что никто не запрещает создателю такого API отклоняться от постулатов REST в ходе реализации отдельных частей. Другим распространенным решением является GraphQL и, хотя, он тоже не идеален, но в отличие от REST, GraphQL API это не просто описательная модель, а настоящие правила.</p><p>Выше я говорил про систему, которая должна была согласовывать работу frontend и backend. Прослойка (interlayer) - это именно тот промежуточный уровень. Рассмотрев возможные варианты работы с сервером мы остановились на GraphQL в качестве API для frontend. Но, так как наш backend на C++, то реализация GraphQL сервера оказалось нетривиальной задачей. Не буду здесь описывать все возникшие сложности и ухищрения, на которые мы шли, реального результата они не принесли. В итоге, посмотрели на проблему с другой стороны и решили, что простота - это залог успеха. Поэтому остановились на проверенных решениях в виде отдельного Node.js сервера с Express.js и Apollo Server.</p><p>Далее нужно было решить как обращаться к API backend'а. Сначала смотрели в сторону поднятия REST API, потом пробовали использовать аддоны на C++ для Node.js. В итоге поняли, что это всё нам не подходит и после подробного анализа выбрали API на базе gRPC сервисов.</p><p>Собрав воедино полученный опыт использования C++, TypesSript, GraphQL и gRPC мы получили архитектуру приложения, позволяющую гибко развивать backend и frontend, продолжая при этом создавать единый программный продукт.</p><p>Как результат, получилась схема, где frontend общается с промежуточным сервером с помощью GraphQL запросов (знает, что спросить и что получит в ответ). GraphQL сервер в резолверах вызывает API функции gRPC сервера, при этом для связи они используют Protobuf схемы. API сервер на базе gRPC знает у какого микросервиса взять данные или кому передать полученный запрос. Сами микросервисы при этом построены также на gRPC, что обеспечивает скорость обработки запросов, типизацию данных и возможность использования различных языков программирования для их разработки.</p><figure contenteditable="false"><div class="figure_wrapper"><img src="https://res.cloudinary.com/inscriptum/image/upload/v1553042495/blob_oxima9.png"></div><span class="cursor_wrapper" contenteditable="true"></span><figcaption class="editable_text" data-placeholder="Caption (optional)">Архитектурная схема нового API</figcaption></figure><p>Есть у этого подхода и ряд минусов, основным из них является дополнительная работа по настройке и согласованию схем, а также написанию вспомогательных функций. Но с увеличением количества потребителей API эти затраты окупаются.</p><h3 id="Заключение">Заключение</h3><p>Мы пошли эволюционным путем развития продукта и команды, что достаточно необычно в рамках нашей компании. Достигли успеха или затея обернулась провалом, наверное, судить рано. Можно подвести промежуточные итоги того, что уже есть:</p><ul start="null" style="counter-reset: list-0 0 null 0;"><li>За отображение отвечает frontend, а за данные backend. </li><li>На frontend сохранилась гибкость в плане запросов и получения данных. Интерфейс знает, что можно попросить у сервера и какие ответы должны быть. </li><li>На backend появилась возможность изменения кода с уверенностью, что интерфейс у пользователя продолжит работать. Стал возможным переход на микросервисную архитектуру без необходимости сразу же переделывать весь frontend. </li><li>Появилась возможность использования mock данных для frontend, когда еще не готов backend. </li><li>Создание схем для совместной работы исключили проблемы взаимодействия, когда команды понимали одну и ту же задачу по разному. Сократилось количество итераций по переделке форматов данных - действуем по принципу "Семь раз отмерь, один раз отрежь". </li><li>Возможность параллельного планирования работ на спринт. </li><li>Возможность набора разработчиков не знакомых с C++ для реализации отдельных микросервисов.</li></ul><p>Статья получилась обзорной и очень общей. Ее целью было показать путь и результаты сложной исследовательской работы на тему как же с технической точки зрения менять архитектуру для дальнейшего развития продукта, а также продемонстрировать организационные сложности деления команды на согласованные части.</p><p>Здесь я поверхностно затронул вопросы командной и межкомандной работы над одним продуктом, выбор технологи API (REST vs GraphQL), связь Node.js приложения с C++ и т.д. Каждая из этих тем тянет на отдельную статью и если вам будет интересно, то мы их обязательно напишем.</p><p><br></p><p><br></p></div></article>
        
        
      </section>
    </div>
  </body>
</html>