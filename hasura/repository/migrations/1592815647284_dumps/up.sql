------------------------------------------------------------------------------------------------
-- DAMP Authors
INSERT INTO
  author ("id", "email", "auth0_id")
VALUES
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    'test@test.test',
    'auth0|5c2b3430c12e3e5be73e5b35'
  );

------------------------------------------------------------------------------------------------
-- DAMP Notes
INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    'e5c2c440-529a-4570-9620-c8d51c904db3',
    'Stencil--kompilyator-Web-Components-i-PWA',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Stencil: компилятор Web Components и PWA',
    '{"ops":[{"insert":"Stencil: компилятор Web Components и PWA"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Кратко об опыте использования Stencil, который позиционируется, как современное развитие UI фреймворков нацеленных на создание визуальных компонентов."},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"link":"https://stenciljs.com/"},"insert":"Stencil"},{"insert":" был создан командой "},{"attributes":{"link":"http://ionicframework.com/"},"insert":"Ionic Framework"},{"insert":" для развития одноименной библиотеки UI компонентов. Сутью инструмента является итоговая компиляция в соответствии со спецификациями "},{"attributes":{"link":"https://w3c.github.io/webcomponents/explainer/"},"insert":"Web Components"},{"insert":". Это позволяет добиться переиспользуемости и универсальности компонентов на Stencil. \nНиже кратко опишу свой опыт использования Stencil на протяжении 5-ти месяцев. За это время я создал несколько десятков UI компонентов разного уровня сложности и написал одно SPA приложение с использование Stencil. Использовал Stencil в монорепозиториях с lerna. Сразу оговорюсь, что не пробовал использовать Stencil для PWA, Web Workers и не представляю насколько хорошо работают компоненты в мобильных браузерах.\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Немного механики"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Хотя Stencil и компилируется в Web Component, но помимо Custom Element и Shadow DOM из спецификации он использует собственный загрузчик (обертка над "},{"attributes":{"code":true},"insert":"customElements.define"},{"insert":") и virtual DOM (VDOM). Это дает возможность использовать HMR и lazy loading при написании Stencil компонентов.\nКомпилируется компонент с помощью TypeScript, а сборка осуществляется посредством Rollup. Нюансы этого процесса скрыты от разработчика обертками компилятора Stencil. Для стилей могут быть использованы sass, less, postcss, stylus.\nStencil сразу содержит cli и dev server. Дополнительно можно использовать плагины Rollup. Для тестов используется Jest и в качестве движка e2e тестов - puppeteer.\nНа выходе Stencil соберет бандлы для разных версий браузеров (с поддержкой  ES6 Module и без неё), полифилы, загрузчик и типы. Дополнительно можно автоматически сгенерировать API компонента и добавить его в README или сохранить в виде "},{"attributes":{"code":true},"insert":"json"},{"insert":" файла.\nОсобенности"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Stencil можно воспринимать как комбайн для написания Web Component с собственным рендером через VDOM. Это накладывает ряд ограничений на изменение процесса создания компонента. К примеру, теряется гибкость настройки Rollup и среды для выполнения тестов. С другой стороны, мы сразу получаем готовую инфраструктуру разработки компонентов. Это существенно экономит время на старте и для несложных наборов UI компонентов.\n\nДля чего Stencil хорошо подходит"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Лучше всего Stencil подходит для создания UI компонентов низкой и средней сложности (т.е. без глобального стейта, с одним или несколькими визуальными представлениями). Собственно, так его и позиционируют разработчики Ionic. При этом неважно насколько много будет компонентов, главное, чтобы они не зависели от единого стейта.\nStencil имеет свои Lifecycle методы в дополнение к тем, что определены в стандарте Web Components. Шаблоном для компонента является JSX разметка. В компонентах активно используются декораторы. Всё это делает из Stencil хороший инструмент для создания библиотек UI компонентов.\nОсобенности"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Благодаря VDOM Stencil дает возможность использовать "},{"attributes":{"code":true},"insert":"ref"},{"insert":" - прямая ссылка на ноду в DOM компонента. Но это же, в свою очередь, приводит к нетипичному поведению "},{"attributes":{"code":true},"insert":"this"},{"insert":" внутри класса компонента. Оно ссылается не на Custom Element, а на компонент Stencil. Получить ссылку на сам элемент можно через специальный декоратор:\nimport { Element } from ''@stencil/core'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"export class TodoList { "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  @Element() el: HTMLElement;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  getListHeight(): number { "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    return this.el.getBoundingClientRect().height; "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  } "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nЕщё один нюанс - это работа с нативными событиями, если их использовать через декоратора "},{"attributes":{"code":true},"insert":"@Event()"},{"insert":", то Stencil выбросит предупреждение при компиляции. Это можно обойти, если диспатчить события самостоятельно, но тогда такое событие не будет учтено при генерации документации.\nИнтересным моментом является использование монорепозитория, в котором каждый компонент является независимым Stencil проектом. При создании библиотеки UI компонентов стоит учитывать, что Stencil не рассчитан на монорепозитории. К примеру, с lerna придется писать дополнительные скрипты публикации. Данный подход помимо явных плюсов независимости компонентов будет приводить к избыточности т.к. каждый компонент Stencil имеет собственный загрузчик и VDOM. На сколько это накладно и при каких объемах начнет сказываться на производительности сказать не могу. Эмпирически выявили, что при использовании до 10-ти таких компонентов в приложении проблем не возникало.\n\nДля чего лучше выбрать другой инструмент"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Если стоит задача создания полноценного SPA приложения. Это обусловлено отсутствием или слабой развитостью инструментов необходимых при разработке масштабных приложений. \nОсобенности"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"В экосистеме Stencil, на данный момент, нет удобного способа для управления маршрутизацией внутри SPA приложения и работой с глобальным состоянием. Команда Ionic предлагает для управления состоянием использовать Redux, но сам пакет "},{"attributes":{"link":"https://github.com/ionic-team/stencil-redux"},"insert":"stencil-redux"},{"insert":" давно не обновлялся и не соответствует последней версии Stencil. Помимо этого использование данного подхода сильно осложнено дополнительными связками, которые отсутствуют в React. Ситуация с роутером схожая. Команда разработчиков Stencil попыталась создать аналог React роутера, но сейчас решение очень \"сырое\" и не подходит для масштабных приложений.\nВозможно, со временем ситуация изменится, но пока разработка SPA на Stencil связана с множеством сложностей.\n\nДокументация"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"У Stencil хорошая "},{"attributes":{"link":"https://stenciljs.com/docs/introduction"},"insert":"начальная документация"},{"insert":", её вполне достаточно для старта и написания небольших или средних UI компонентов. По более глубоким вопросам ответ часто приходится искать в issue или на форумах.\nСтоит отметить, что команда и сообщество Stencil периодически пишет статьи, которые частично раскрывают особенности работы.\n\nКратко"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Идеальным инструмент назвать нельзя, но он решает вполне определенные задачи и может быть использован для создания библиотек UI компонентов независимых от фреймворков. \nБудущее Stencil пока не ясно, сможет ли он найти свою нишу среди популярных инструментов фронтенд разработчиков. \n\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://stenciljs.com/"},"insert":"Стартовая страница"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/ionic-team/stencil"},"insert":"Репозиторий"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/ispsystem/plugin-imunify/tree/master/client"},"insert":"Открытый проект плагина, фронт на Stencil"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"}]}',
    to_timestamp('05/11/2019, 14:14:14', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('02/12/2019, 19:39:21', 'DD/MM/YYYY, HH24:MI:SS')
  );

INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    '1d41de8e-9378-40e5-ac98-293ef81518e1',
    'Bazovy-j-JavaScript',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Базовый JavaScript',
    '{"ops":[{"insert":"Базовый JavaScript"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockDescription":true},"insert":"\n"},{"attributes":{"link":"#%D0%9F%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2"},"insert":"Приведение типов."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE-%20typeof"},"insert":"Оператор typeof."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%A2%D0%B8%D0%BF-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0"},"insert":"Тип объекта."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"http://xn--80aero0aa6e/"},"insert":"Массивы."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%A0%D0%B0%D0%B2%D0%B5%D0%BD%D1%81%D1%82%D0%B2%D0%BE"},"insert":"Равенство."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8"},"insert":"Область видимости."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-let"},"insert":"Ключевое слово let."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0"},"insert":"Функция обратного вызова."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"#%D0%A1%D1%82%D1%80%D0%BE%D0%B3%D0%B8%D0%B9-%D1%80%D0%B5%D0%B6%D0%B8%D0%BC-use-strict"},"insert":"Строгий режим \"use strict\"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"\nПриведение типов"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Преобразование между двумя встроенными типами. \nБывает двух типов: \n"},{"attributes":{"italic":true},"insert":"явное"},{"insert":":\nvar a = \"55\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = Number( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a;\t\t\t\t// \"55\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b;\t\t\t\t// 55 - число"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"italic":true},"insert":"неявное"},{"insert":":\nvar a = \"42\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = a * 1;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a;\t\t\t\t// \"55\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b;\t\t\t\t// 55 - число!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nОператор typeof"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Оператор "},{"attributes":{"code":true},"insert":"typeof"},{"insert":" может проверить значение и сказать, какой это тип:\nvar a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"undefined\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = \"hello world\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"string\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = 42;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"number\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = true;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"boolean\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = null;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"object\" -- странно, ошибка"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = undefined;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"undefined\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = { b: \"c\" };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof a;\t\t\t\t// \"object\""},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Тип объекта"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Относится к составному значению, где можно установить свойства (именованные местоположения), каждое из которых содержит свои собственные значения любого типа.\nvar obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  a: \"hello world\", // свойство"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  b: 42,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  c: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.a;\t\t// \"hello world\", обращение через нотацию с точкой"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.b;\t\t// 42"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.c;\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj[\"a\"];\t// \"hello world\", обращение через нотацию со скобками"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj[\"b\"];\t// 42"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj[\"c\"];\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обращение через нотацию со скобками, если нужно получить доступ к свойству/ключу, и имя хранится в переменной, например как:\nvar obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: \"hello world\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tb: 42"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = \"a\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj[b];\t\t\t// \"hello world\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj[\"b\"];\t\t// 42"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Массивы"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"code":true},"insert":"Массив"},{"insert":" - это объект, который содержит значения (любого типа) не в именованных свойствах/ключах, а в числовых индексированных позициях:\nvar arr = ["},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"hello world\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  42,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"arr[0];\t\t\t// \"hello world\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"arr[1];\t\t\t// 42"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"arr[2];\t\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"arr.length;\t\t// 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof arr;\t\t// \"object\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nРавенство"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Строгое сравнение"},{"insert":" ("},{"attributes":{"code":true},"insert":"==="},{"insert":") проверяет равенство значений, не применяя "},{"attributes":{"italic":true},"insert":"принуждение"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"Абстрактное сравнение"},{"insert":" ("},{"attributes":{"code":true},"insert":"=="},{"insert":") проверяет равенство значений применяя "},{"attributes":{"italic":true},"insert":"принуждение"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"var a = \"42\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = 42;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a == b;\t\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a === b;\t\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Избегайте абстрактное сравнение "},{"attributes":{"code":true},"insert":"=="},{"insert":" в случаях, если какое-либо значение в сравнении может иметь значение:\n"},{"attributes":{"code":true},"insert":"true"},{"insert":" или "},{"attributes":{"code":true},"insert":"false"},{"insert":","},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"0"},{"insert":", "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"\"\""},{"insert":" - пустая строка,"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"[]"},{"insert":" - пустой массив."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true,"link":"https://felix-kling.de/js-loose-comparison/"},"insert":"Пошаговая визуализация алгоритма нестрого сравнения"},{"attributes":{"link":"https://felix-kling.de/js-loose-comparison/"},"insert":" (==) с приведением типов в JavaScript"},{"insert":".\n"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Область видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Необходима для ограничения доступа. Если какая-либо переменная определена внутри функции, то область её видимости ограничивается этой функцией и функциями вложенными в неё.\n\nКлючевое слово let"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Позволяет объявлять переменные, принадлежащие отдельным блокам (парам "},{"attributes":{"code":true},"insert":"{ .. }"},{"insert":"), начиная с ES6.\n\n"},{"attributes":{"italic":true},"insert":"Источник:"},{"insert":"\n"},{"attributes":{"link":"https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md"},"insert":"https://github.com/getify/You-Dont-Know-JS/blob/master/up%20%26%20going/ch2.md"},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"\nФункция обратного вызова"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"code":true},"insert":"callback"},{"insert":" является функцией, которая передается другой функции в качестве аргумента и выполняется после завершения какой-либо операции.\n\nСтрогий режим \"use strict\""},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Помещает программу или функцию в «строгий» или «современный» рабочий контекст. ECMAScript 5 добавил новые возможности в язык и изменил некоторые из существующих. По умолчанию они отключены, включить их нужно явно с помощью специальной директивы: "},{"attributes":{"code":true},"insert":"\"use strict\""},{"insert":". Некоторые функции языка, такие как «классы» и «модули», автоматически включают строгий режим. \nДиректива "},{"attributes":{"code":true},"insert":"\"use strict\""},{"insert":" может быть указана в начале всей программы или отдельной функции, перед её указанием могут быть только комментарии.\nПомимо возможностей, этот контекст предотвращает выполнение определенных действий и вызывает больше исключений.\n"},{"attributes":{"bold":true},"insert":"Поведение в строгом и нестрогом режиме:"},{"insert":"\nприсваивание значений в неопределённую (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x11.html#x11.13.1"},"insert":"§11.13.1"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"(function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  x = 5; // ReferenceError: x is not defined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})(); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"x = 5; // Создает глобальную переменную x"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"присваивание значение в свойство только для чтения:"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"(function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  window.undefined = 5; // TypeError: Cannot assign to read only"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();                   // property ''undefined'' of [object Object]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"window.undefined = 5; // Ничего не делает"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"повторные свойства в литерале объекта (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x11.html#x11.1.5"},"insert":"§11.1.5"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"(function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  var x = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 1,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  };  // SyntaxError: Duplicate data property in object literal "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})(); // not allowed in strict mode"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var x = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  a: 1,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}; // x равно {a: 2} "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"повторные формальные параметры функции (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x13.html#x13.1"},"insert":"§13.1"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x15.3.html#x15.3.2"},"insert":"§15.3.2"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"function f(a, a) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} // SyntaxError: Strict mode function may not have duplicate parameter names"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function f(a, a) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f(1,2); // возвращает 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"изменения объекта "},{"attributes":{"code":true},"insert":"arguments"},{"insert":" (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x10.html#x10.6"},"insert":"§10.6"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"function f(x) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  arguments[0] = 5;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return x;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f(10); // возвращает 10"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function f(x) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  arguments[0] = 5;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return x;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f(10); // возвращает 5"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"delete"},{"insert":" на неизменяемом свойство объекта (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x11.html#x11.4.1"},"insert":"§11.4.1"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"(function f(x) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  var y = 4;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete f; // SyntaxError: Delete of an unqualified identifier in strict mode."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete x; // SyntaxError: Delete of an unqualified identifier in strict mode."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete y; // SyntaxError: Delete of an unqualified identifier in strict mode."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete window.undefined; // TypeError: Cannot delete property "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();                      // ''undefined'' of [object Object]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function f(x) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  var y = 4;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete f; // Возвращает false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete x; // Возвращает false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete y; // Возвращает false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  delete window.undefined; // Возвращает false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"определение переменной и функции в контексте вызова через "},{"attributes":{"code":true},"insert":"eval "},{"insert":"(спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x10.html#x10.4.2"},"insert":"§10.4.2"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"(function () {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  eval(\"var x = 5\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return x; // ReferenceError: x is not defined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function () {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  eval(\"var x = 5\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return x;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})(); // Возвращает 5"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"this"},{"insert":" не преобразуется в объект, а если значение "},{"attributes":{"code":true},"insert":"this"},{"insert":" - "},{"attributes":{"code":true},"insert":"undefined "},{"insert":"или "},{"attributes":{"code":true},"insert":"null"},{"insert":", то не преобразуется в глобальный объект (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x10.html#x10.4.3"},"insert":"§10.4.3"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"function f() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return this;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f.call(4); // возвращает 4"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f.call(null); // возвращает null"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f.call(undefined); // возвращает undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function f() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return this;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f.call(4); // возвращает [object Number]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f.call(null); // возвращает [object global] "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"f.call(undefined); // возвращает [object global]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"литералы восьмеричной системы счисления (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/B.html#B.1.1"},"insert":"B.1.1"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/B.html#B.1.2"},"insert":"B.1.2"},{"insert":"):"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"(function () {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return 010 + // SyntaxError: Octal literals are not allowed in strict mode."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    \"\\077\";    // SyntaxError: Octal literals are not allowed in strict mode."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function () {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  return 010 + \"\\077\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})(); // возвращает \"8?\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"больше слов, зарезервированных для использования в будущем (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x7.html#x7.6.1.2"},"insert":"§7.6.1.2"},{"insert":");"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"eval"},{"insert":" и "},{"attributes":{"code":true},"insert":"arguments"},{"insert":" - нельзя изменить или использовать в качестве имени (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x11.html#x11.4.4"},"insert":"§11.4.4"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x11.html#x11.4.5"},"insert":"§11.4.5"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x11.html#x11.13"},"insert":"§11.13"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x12.html#x12.2.1"},"insert":"§12.2.1"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x12.html#x12.10"},"insert":"§12.10"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x12.html#x12.14.1"},"insert":"§12.14.1"},{"insert":", "},{"attributes":{"link":"http://es5.javascript.ru/x13.html#x13.1"},"insert":"§13.1"},{"insert":");"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"нельзя использовать "},{"attributes":{"code":true},"insert":"argument.caller "},{"insert":"и "},{"attributes":{"code":true},"insert":"arguments.callee "},{"insert":"(спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x13.html#x13.2"},"insert":"§13.2"},{"insert":");"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"нельзя использовать устаревшую инструкцию "},{"attributes":{"code":true},"insert":"with"},{"insert":" (спецификация "},{"attributes":{"link":"http://es5.javascript.ru/x12.html#x12.10"},"insert":"§12.10"},{"insert":")."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"\n"},{"attributes":{"italic":true},"insert":"Источники:"},{"insert":"\n"},{"attributes":{"link":"https://coderbyte.com/algorithm/10-common-javascript-interview-questions"},"insert":"https://coderbyte.com/algorithm/10-common-javascript-interview-questions"},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"attributes":{"link":"https://learn.javascript.ru/strict-mode"},"insert":"https://learn.javascript.ru/strict-mode"},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"attributes":{"link":"https://ru.stackoverflow.com/questions/435546/%D0%A7%D1%82%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82-use-strict"},"insert":"https://ru.stackoverflow.com/questions/435546/%D0%A7%D1%82%D0%BE-%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82-use-strict"},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"\n\n"}]}' :: json,
    to_timestamp('26/09/2019, 13:09:06', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('26/09/2019, 13:09:06', 'DD/MM/YYYY, HH24:MI:SS')
  );

INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    '93dcda1c-0387-4602-b874-7d59a75a043b',
    'Web-Components--Princzip-ispol-zovaniya',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Web Components. Принцип использования',
    '{"ops":[{"insert":"Web Components. Принцип использования"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Рассмотрение вопросов использования Web Components в приложении, какие существуют подходы, их плюсы и минусы. Способы подключения компонентов через HTML Imports и JavaScript."},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Использование Web Components посредством спецификации HTML Imports"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"В предыдущей статье мы рассмотрели четыре спецификации Web Components, одна из них это HTML Imports. Напомню, что основное её назначение это механизм внедрения созданного компонента в приложение. Создадим компонент use.html следующим образом:\n<template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    h1 {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      background-color: dimgray;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      color: darkgray;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <h1>Use Web Components!</h1>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  const $ownerDocument = document.currentScript.ownerDocument;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  const $template = $ownerDocument.querySelector(\"template\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  class UseWebComponents extends HTMLElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    connectedCallback(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      const $content = document.importNode($template.content, true);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      this.appendChild($content);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  window.customElements.define(\"use-web-components\", UseWebComponents);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</script> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Используем компонент use-web-components в файле index.html:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html lang=\"en\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <meta charset=\"UTF-8\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <title>HTML Imports</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <link rel=\"import﻿﻿﻿\" href=\"use.html\" id=\"use\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <use-web-components></use-web-components>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html>﻿"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В примере выше весь код нашего компонента был сосредоточен в html файле. Далее, в соответствии с HTML Imports мы подключили компонент к основному приложению в index.html через строку\n\nПодключение компонентов с помощью спецификации HTML Imports имеет ряд преимуществ:\nАвтоматически исключаются множественные импорты на уровне браузера."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Написание разметки HTML, CSS стилей и JS кода в одном html файле поддерживается всеми редакторами и средами разработки, а также не противоречит принципам Web."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Но есть и весомые отрицательные стороны у данного подхода:\nСпецификация HTML Imports не поддерживается во всех современных браузерах. Их производители до сих пор не пришли к общему мнению по данному вопросу."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Данные подход затруднительно использовать с современными системами сборки, такими как Webpack."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Если в приложении используется несколько компонентов, то все их придется подгружать через link с атрибутом rel=\"import\" или хранить все компоненты в одном файле. И первое и второе нельзя назвать хорошим решением."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"HTML Imports появилась до динамических импортов ES2015. Теперь же гораздо предпочтительнее использовать JavaScript для загрузки дополнительной функциональности, что в некотором роде нивелирует преимущества HTML Imports."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Использование Web Components посредством JavaScript"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Чтобы понять механизм создания и подключения компонента на JavaScript, и сравнить его с предыдущим подходом, создадим аналогичный пример. Компонент use.js:\nclass UseWebComponents extends HTMLElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  connectedCallback(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    this.innerHTML = `"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      <style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        h1 {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"          background-color: dimgray;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"          color: darkgray;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      </style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      <h1>Use Web Components!</h1>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    `;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"window.customElements.define(\"use-web-components\", UseWebComponents); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Используем компонент use-web-components в файле index.html:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html lang=\"en\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <meta charset=\"UTF-8\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <title>HTML Imports</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <script src=\"use.js\"></script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <use-web-components></use-web-components>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"При подключении компонентов с помощью JavaScript гораздо больше преимуществ и меньше недостатков. Из плюсов:\nБлизость современным JavaScript разработчикам. Этот подход не нужно разбирать и заново осмысливать, он близок всем, кто создавал компоненты на ReactJS или Angular."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Подключение компонента подобно подключению любого другого js файла."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Не требует дополнительных полифилов для работы."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Просто использовать вместе с Webpack."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Но есть и весомые отрицательные стороны у данного подхода:\nПисать HTML и CSS внутри JS кода может показаться не лучшей идеей."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Писать разметку в виде шаблонных строк неудобно, тем более, что в этом случае почти все среды разработки будут воспринимать её как обычную строку."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Хоть данный подход и не лишен своих минусов, использовать его гораздо удобнее.\nИтог"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"При создании компонента необходимо заранее определить способ его дальнейшего использования. Существует два подхода:\nподключать компоненты с помощью HTML Imports;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"загружать компоненты как обычные JavaScript файлы."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Оба подхода имеют плюсы и минусы, но, пожалуй, решающим является современная экосистема JavaScript, которая делает второй фаворитом. Помимо возможности использовать сборки и лучшие практики компоновки приложений, он позволяет подключать компоненты в современных браузерах без загрузки дополнительных зависимостей в виде полифилов.\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"bold":true,"link":"https://github.com/webcomponents/webcomponentsjs"},"insert":"webcomponentsjs"},{"insert":" и "},{"attributes":{"bold":true,"link":"https://www.webcomponents.org/polyfills"},"insert":"polyfills"},{"insert":" - полифиллы и как их использовать (для работы еще не реализованных спецификаций в браузерах)."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true,"link":"https://www.html5rocks.com/en/tutorials/webcomponents/imports/"},"insert":"HTML Imports"},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"}]}',
    to_timestamp('26/09/2019, 12:43:16', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('26/09/2019, 12:43:16', 'DD/MM/YYYY, HH24:MI:SS')
  );

INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    '7cba79c0-1e16-46a4-acfb-7b38a0c62363',
    'Web-Components--Osnovy-',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Web Components. Основы',
    '{"ops":[{"insert":"Web Components. Основы"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Базовые вещи касательно Web Components. Способы создания элементов веб-страницы на основе Web Components. Четыре спецификации Web Components. Фундаментальные аспекты компонентов."},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Что из себя представляют Web Components"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Рецепт Web Components прост - это три фундаментальных блока: HTML, CSS и JavaScript.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/recipe.jpg"}}},{"insert":"HTML определяет каркас компонента, является разметкой как и для обычной страницы. CSS отвечает за визуальное отображение. JavaScript - это логика компонента, его поведение и функциональность. Спецификации Web Components позволяют нам использовать эти три технологии вместе для построения собственных компонентов. Отсутствие дополнительных требований и инструментов существенно упрощают создание и использование таких компонентов как отдельно, так и внутри уже существующих приложений.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/wc.jpg"}}},{"insert":"Компоненты, создаваемые на основе принципов Web Components, на сегодняшний день, имеют максимальную модульность, гибкость и переиспользуемость. Независимость от иного контента на странице дает возможность не беспокоиться о неправильном отображении.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-root.png"}}},{"insert":"А наследование и переиспользование уже существующих компонентов делают их универсальным инструментом для приложений любых масштабов. Но, пожалуй, основным достоинством Web Components остается их простота - разработчикам нет необходимости изучать дополнительные фреймворки и библиотеки, все, что нужно - это HTML, CSS и JavaScript.\nТаким образом достигаются следующие цели:\nизоляция стилей;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"отсутствие зависимостей в виде библиотек и фреймворков;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"универсальность и простота компонентов."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Спецификации Web Components"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/spec.jpeg"}}},{"insert":"Web Components состоит из четырех спецификаций:\nCustom Elements"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Shadow DOM"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"HTML Templates"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"HTML Imports"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Каждая из этих спецификаций предоставляет отдельную функциональность для создания и использования компонентов. \nCustom Elements"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/custom-elements.jpeg"}}},{"insert":"Custom Elements описывает как создавать собственные DOM элементы, добавлять свойства и функции к ним, а также расширять их на основе уже существующих элементов. Для создания пользовательского DOM элемента необходимо использовать классы ES2015. Рассмотрим создание пользовательского элемента на простом примере.\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <title>Custom Elements</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <script type=\"text/javascript\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    class FirstCustomElement extends HTMLElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      constructor() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        super();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        console.log(''constructor'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    window.customElements.define(''first-custom-element'', FirstCustomElement);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <first-custom-element></first-custom-element>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Был создан класс расширяющий нативный HTMLElement. Таким образом мы унаследовали функции самого базового DOM элемента. Внутри класса определен конструктор, который будет вызван при создании элемента. В конструкторе обязательно необходимо вызвать метод super() чтобы выполнился конструктор базового класса. Наконец, вызываем метод window.customElements.define, определенный в спецификации Custom Elements v1. На вход он принимает название тега, который в дальнейшем будет использован на странице и, собственно, класс для создания элемента. Теперь мы можем в теле документа вставить наш элемент, после чего в консоли выведется сообщение из метода конструктора.\nПомимо конструктора в Custom Elements присутствует ряд методов, предоставляемых API и описанных в спецификации, как методы жизненного цикла (lifecycle hooks). Они используются для выполнения определенных участков кода в отдельные периоды “жизни” компонента.\nРассмотрим три наиболее употребимых из них. Для этого изменим предыдущий пример следующим образом:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <title>Custom Elements</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script type=\"text/javascript\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        class FirstCustomElement extends HTMLElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            constructor() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                super();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                console.log(''constructor'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            connectedCallback() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                console.log(''connectedCallback'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            static get observedAttributes() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                return [''test'']"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            attributeChangedCallback(name, oldValue, newValue) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                console.log(''attributeChangedCallback '', name, oldValue, newValue);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            disconnectedCallback() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                console.log(''disconnectedCallback'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        window.customElements.define(''first-custom-element'', FirstCustomElement);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <first-custom-element></first-custom-element>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"connectedCallback"},{"insert":" выполняется в момент добавления элемента к DOM;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"attributeChangedCallback"},{"insert":" метод выполняемый в момент изменения атрибутов. Он позволяет подписываться на изменения определенных атрибутов. Для того, чтобы можно было указать какие именно из них отслеживать статический метод observedAttributes должен вернуть их в виде массива текстовых значений."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"disconnectedCallback"},{"insert":" выполняется в момент удаления элемента из DOM. Данный метод наиболее удобен, если необходимо выполнить некоторую работу (удалить интервалы, очистить дополнительные данные) после удаления."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"Расширение Custom Elements"},{"insert":" - это возможность создавать свои элементы, основываясь на уже созданных ранее. Для понимания рассмотрим пример.\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <title>Custom Elements</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script type=\"text/javascript\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        class HelloCustomElement extends HTMLElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            sayHello() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                console.log(''Hello!'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        window.customElements.define(''hello-custom-element'', HelloCustomElement);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        class HowAreYouCustomElement extends HelloCustomElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            constructor() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                super();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                this.howAreYou();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            howAreYou() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                this.sayHello();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                console.log(''How are you!'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        window.customElements.define(''howareyou-custom-element'', HowAreYouCustomElement);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <howareyou-custom-element></howareyou-custom-element>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"После выполнения в консоли будет выведено:\nHello!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"How are you!"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Расширение Custom Elements на основе стандартных элементов"},{"insert":" - еще одна очень важная функция при создании своих элементов. Если необходимо добавить небольшой функционал к стандартному DOM элементу это можно сделать через его расширение. Предположим, что у нас есть input, в котором при его создании должно появиться подготовленное заранее содержимое.\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <title>Custom Elements</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/document-register-element/1.5.0/document-register-element.js\"></script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script type=\"text/javascript\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        class HelloInputCustomElement extends HTMLInputElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            connectedCallback() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                this.setAttribute(''value'', ''Hello'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        window.customElements.define("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"          ''helloinput-custom-element'', "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"          HelloInputCustomElement, {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            extends: ''input''"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"          }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <input is=\"helloinput-custom-element\"></input>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В результате, после создания в нашем элементе input будет содержаться текст "},{"attributes":{"code":true},"insert":"Hello"},{"insert":". Для расширения стандартного элемента мы выполнили следующие шаги:\nУнаследовались от расширяемого элемента extends HTMLInputElement."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"При создании элемента добавили тег расширяемого элемента "},{"attributes":{"code":true},"insert":"window.customElements.define(''helloinput-custom-element'', HelloInputCustomElement, {extends: ''input''})."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"В документе наш элемент используется через указание атрибута is в стандартном теге."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Важно! На данный момент расширение стандартных элементов не реализовано в большинстве браузеров, поэтому необходимо воспользоваться "},{"attributes":{"link":"https://github.com/WebReflection/document-register-element#using-innerhtml"},"insert":"поллифилом"},{"insert":" выше мы подключили его через cdn."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Итак, мы рассмотрели, пожалуй, основную из спецификаций Web Components. Custom Elements является ядром компонента, именно с неё начинается его создание.\nShadow DOM"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-dom.jpeg"}}},{"insert":"Следующая из спецификаций Web Components называется Shadow DOM. Она позволяет создавать дополнительное DOM дерево для создаваемого элемента. Особенность такого внутреннего DOM дерева заключается в его инкапсуляции - независимости от основного DOM дерева.\nСуществует два способа использования Shadow DOM - в закрытом и открытом виде:\n"},{"attributes":{"bold":true},"insert":"open"},{"insert":" - открытый тип, позволяет получить полный контроль над дополнительным DOM-ом;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"close"},{"insert":" - закрытый тип, не позволяет манипулировать дополнительным DOM-ом после его создания."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Рассмотрим пример кода:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <meta charset=\"UTF-8\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <title>Shadow DOM</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t        input {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t            border-color: red;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t            margin: 10px;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t        }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    </style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <input type=\"text\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <div id=\"hello\"></div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <input type=\"text\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t    <script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t        let $helloDiv = document.getElementById(''hello'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t        $helloDiv.attachShadow({"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t            mode: \"open\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t        });"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t        $helloDiv.shadowRoot.innerHTML ="},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t            `<style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t                input {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t                border: none;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t                }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t            </style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\t<input type=\"text\" value=\"hello\"/>`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"             ;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \t    </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \t</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \t"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  \t</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В результате его исполнения браузер отобразит три input элемента, два из них с красной рамкой и один без нее:\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-dom_example.png"}}},{"insert":"Такой результат получился в результате использования функции attachShadow и добавления дополнительного содержимого через shadowRoot.innerHTML. Если посмотреть в инспектор кода, то можно увидеть структуру дерева дополнительного DOM.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/shadow-root.png"}}},{"insert":"Дополнительное содержимое было добавлено в shadow-root. Это позволяет компонентам не влиять на общие стили страницы и не испытывать их влияние на себе.\nHTML Templates"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/html-templates.jpeg"}}},{"insert":"HTML Templates позволяет создавать шаблоны на основе HTML. Такие шаблоны обладают рядом особенностей:\nСоздаются с помощью тега ."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Не отображаются в браузере до момента их явного использования."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Могут быть использованы для определения разметки компонента и её дальнейшего рендеринга во время создания."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Для использования шаблона достаточно создать разметку внутри тега template:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <meta charset=\"UTF-8\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <title>HTML Templates</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <template id=\"task\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        <li>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            <h1>Task name</h1>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            <p>Task body</p>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        </li>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <ui id=\"todo-list\"></ui>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        const tasks = [{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                name: \"Сделать зарядку\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                body: \"Разминка, пробежка, подтягивание на перекладине\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                name: \"Купить продукты\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                body: \"Хлеб, овощи, чай\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                name: \"Подготовить доклад\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                body: \"Найти проблему, описать суть, найти решение\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        ];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        const $template = document.getElementById(''task'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        const $todoList = document.getElementById(''todo-list'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        tasks.forEach(task => {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            const $clone = document.importNode($template.content, true);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            $clone.querySelector(''h1'').innerText = task.name;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            $clone.querySelector(''p'').innerText = task.body;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            $todoList.appendChild($clone);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        });"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В примере выше у нас есть список задач и шаблон для отображения отдельной задачи. С помощью функции document.importNode мы создаем клон шаблона (глубокое клонирование при помощи второго параметра со значением true). Далее измененный шаблон добавляется к элементу списка задач функцией appendChild. Как видно из примера, шаблон был переиспользован несколько раз внутри цикла.\nHTML Templates является наиболее устоявшейся из спецификаций, она реализована во всех современных браузерах.\nHTML Imports"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://inscriptum.js.org/data/articles/webcomponents-base/images/html-imports.jpeg"}}},{"insert":"Последней из спецификаций Web Components является HTML Imports. Как и следует из её названия она описывает способ импорта html файла. Это можно сравнить с импортом css файла внутри страницы. Только в данном случае вместо разметки стилей будет загружен файл с одним или более компонентами.\nДля демонстрации создадим два файла. Первый hello.html с содержимым:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <h1>Hello Web Components!</h1>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Второй index.html:\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html lang=\"en\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <meta charset=\"UTF-8\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <title>HTML Imports</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <link rel=\"import\" href=\"hello.html\" id=\"hello\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        const $link = document.getElementById(\"hello\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        const content = $link.import.querySelector(\"h1\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        document.body.appendChild(content.cloneNode(true));"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Открытие страницы index выведет заголовок из файла hello.html.\nHTML Imports является наиболее спорной из всех спецификаций, на сегодняшний день она реализована только в браузере Chrome и Opera. К тому же, смысл работы данной спецификации выглядит несколько избыточным с появлением динамических импортов в ES2015. Тем не менее, функция загрузки компонентов через импорт html файла существует и может оказаться весьма нужной в отдельных случаях.\nИтог"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"На этом мы закончили рассмотрение основ Web Components. Познакомились с целями, которые позволяют достичь компоненты и как эти цели коррелируют с четырьмя спецификациями:\nCustom Elements - создание элемента внутри страницы со своим жизненным циклом, разметкой и логикой отображения."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Shadow DOM - дополнительный DOM внутри страницы, позволяющий добиться инкапсуляции стилей."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"HTML Templates - шаблон для переиспользуемых частей внутри компонентов."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"HTML Imports - импорт html файлов внутри основной страницы."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Ссылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"bold":true,"link":"https://github.com/webcomponents/webcomponentsjs"},"insert":"webcomponentsjs"},{"insert":" и "},{"attributes":{"bold":true,"link":"https://www.webcomponents.org/polyfills"},"insert":"polyfills"},{"insert":" - полифиллы и как их использовать (для работы еще нереализованных спецификаций в браузерах)."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true,"link":"https://developers.google.com/web/fundamentals/getting-started/primers/customelements"},"insert":"Custom Elements"},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true,"link":"https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom"},"insert":"Shadow DOM"},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true,"link":"https://www.html5rocks.com/en/tutorials/webcomponents/template/"},"insert":"HTML Templates"},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true,"link":"https://www.html5rocks.com/en/tutorials/webcomponents/imports/"},"insert":"HTML Imports"},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"}]}',
    to_timestamp('26/09/2019, 11:19:34', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('26/09/2019, 11:19:34', 'DD/MM/YYYY, HH24:MI:SS')
  );

INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    'f7ae56b4-fe5b-46db-b4f2-bb8ee9f6e2a4',
    'Web-Components--Vvedenie',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Web Components. Введение',
    '{"ops":[{"insert":"Web Components. Введение"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Данная серия статей под одноименным заголовком будет посвящена технологии Web Components. Основным объектом рассмотрения являются именно нативные возможности Web Components без участия сторонних фреймворков, таких как Polymer, X-Tag или SlateJS."},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Плюсы и минусы"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Три основных вопроса, на которые вы найдете ответы:\nЧем являются Web Components и почему они отличаются от современных web-фреймворков и библиотек?"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Каким образом происходит создание Web Components?"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Как можно использовать Web Components уже сегодня?"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Причины появления Web Components"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Идея Web Components родилась в попытках решения ряда проблем, с которыми сталкиваются web-разработчики чуть ли не с зарождения веба:\nИзоляция стилей отдельных элементов на странице."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Переиспользование ранее созданных элементов."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Масштабируемость без ущерба понятности."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Преодолевались эти и другие проблемы front-end через использование различных инструментов. Подход Java -> JavaScript (к примеру, "},{"attributes":{"link":"https://ru.wikipedia.org/wiki/Google_Web_Toolkit"},"insert":"GWT"},{"insert":") или {что-то более удобное} -> JavaScript позволил использовать популярные языки для написания целых web-порталов без необходимости знаний в самом JavaScript. Библиотеки, вроде jQuery дали возможность абстрагироваться от реализации отдельных элементов. Из последних, современные JavaScript фреймворки, такие как React, Angular, Vue.js способные не просто решить все вышеописанные проблемы, но и охватить вопросы роутинга, безопасности и взаимодействия с сервером в прозрачной манере.\nКаждый из этих подходов решает важные задачи, не зря все они в большей или меньшей степени используются во фронтенде уже не первый год. Но тем не менее три вышеописанных проблемы так и остались с нами. Почему же? Дело в том, что в попытках упростить и упорядочить одно, инструменты невольно усложняют и запутывают другое. Современные JavaScript фреймворки решают все три проблемы с лихвой и даже больше, но возможно в этом и проблема - они привносят свою сложность, которая сильно превышает сложность решаемой задачи.\n"},{"attributes":{"bold":true},"insert":"Итак, Web Components это четыре спецификации, которые позволяют создавать изолированные элементы с возможностью прозрачного переиспользования и расширения, основываясь на других таких же элементах."},{"insert":"\nСила Web Components именно в стандарте. А значит, ответственность консорциума и сообщества.\nВ результате следования этим стандартам появляется возможность создания и расширения элементов подобных button или input в HTML. Такой элемент будет являться компонентом, его можно использовать точно так же, как и уже существующие в браузерах. При этом отсутствие дополнительной инфраструктуры в виде библиотек или фреймворков уменьшает кодовую базу и положительно влияет на производительность. Немаловажно значение общего подхода в построении компонентов на основе спецификации. Это позволяет расширять существующие элементы и компоненты без существенного их усложнения.\nВ завершении вводной части скажу о двух важных особенностях. Во-первых Web Components имеют важное преимущество - они могут стать мостом между разными фреймворками и подходами во front-end, так как их удобно использовать и внутри проектов с React, и с Angular и даже рядом с “вечными плагинами” jQuery. Во-вторых, и это отнюдь не плюс Web Components - они поддерживаются не во всех современных браузерах, придется приложить усилия используя их прямо сегодня, но это все же возможно. Тем не менее, Web Components - это завтра front-end и похоже, что в этом уже никто не сомневается.\n\n\n"}]}',
    to_timestamp('11/09/2019, 08:34:53', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('25/09/2019, 19:20:32', 'DD/MM/YYYY, HH24:MI:SS')
  );

INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    'ca21c809-fff4-4a25-832c-a719731b0c52',
    'Ispol-zovanie-Vue-js-dlya-sozdaniya-pol-zovatel-skix-Web-komponentov',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Использование Vue.js для создания пользовательских Web компонентов',
    '{"ops":[{"insert":"Использование Vue.js для создания пользовательских Web компонентов"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Перевод статьи Simon Tarchichi \"Use Vue.js to create custom web components\". Автор делает краткий обзор Web components и показывает как их можно создавать с помощью Vue.js."},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Web компоненты позволяют определять новые HTML теги, которые принято называть пользовательскими элементами (custom elements). Эти теги могут быть в дальнейшем использованы непосредственно в HTML коде вашего приложения:\n<div id=\"my-app\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <p>Introduction text</p>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <share-buttons/>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</div> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В этом примере, будет интерпретирован браузером и \"заменен\" HTML разметкой, которую вы для него определили. В результате получим:\n<div id=\"my-app\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <p>Introduction text</p>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <share-buttons>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <div id=\"share-buttons\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      <a href=\"#\">Facebook</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      <a href=\"#\">Twitter</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </share-buttons>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Так же здесь можно было бы использовать JS логику, чтобы при событии click делиться страницей через Facebook или Twitter.\n"},{"attributes":{"bold":true},"insert":"Web компоненты подобны Vue.js компонентам."},{"insert":" Они имеют жизненный цикл (lifecycle), свойства и могут быть вложенными. Их API менее мощный, но зато следует стандарту, определенному в "},{"attributes":{"link":"https://www.w3.org/standards/techs/components#w3c_all"},"insert":"W3C спецификации"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Проблема в том, что Web компоненты не имеют полной поддержки в браузерах до настоящего момента."},{"insert":" Посмотреть поддержку Web компонентов браузерами можно на сайте "},{"attributes":{"link":"http://jonrimmer.github.io/are-we-componentized-yet/"},"insert":"are-we-componentized-yet"},{"insert":" или "},{"attributes":{"link":"http://caniuse.com/#search=web%20components"},"insert":"caniuse.com"},{"insert":" (*).\nНо, применив немного JS магии "},{"attributes":{"bold":true},"insert":"вы можете прямо сейчас перевести ваши Vue.js компоненты в Web компоненты"},{"insert":", что позволит использовать их в любых web приложениях, даже вместе с React, Angular или .\nКак получить из вашего Vue.js компонента универсальные Web компоненты"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Понадобится "},{"attributes":{"link":"https://karol-f.github.io/vue-custom-element"},"insert":"vue-custom-element"},{"insert":" библиотека написанная "},{"attributes":{"link":"https://github.com/karol-f"},"insert":"@karol-f"},{"insert":". Она позволит вам "},{"attributes":{"bold":true},"insert":"использовать Vue.js компонент как пользовательский элемент"},{"insert":".\nHTML подход"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Один раз зарегистрировав пользовательский компонент вы можете вставлять его тег в обычный HTML, SPA, React, Angular или Vue.js проект.\n<div id=\"my-app\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <p>Introduction text</p>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <share-buttons gplus=\"false\"/>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<template id=\"share-buttons-template\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <div id=\"share-buttons\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <a href=\"#\" @click.prevent=\"share\" v-if=\"facebook\">Facebook</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <a href=\"#\" @click.prevent=\"share\" v-if=\"twitter\">Twitter</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <a href=\"#\" @click.prevent=\"share\" v-if=\"gplus\">Google+</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<script src=\"vue.min.js\"></script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<script src=\"vue-custom-element.min.js\"></script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  Vue.customElement(''share-buttons'', {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    template: ''#share-buttons-template'',"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    props: {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      facebook: { type: Boolean, default: true },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      twitter: { type: Boolean, default: true },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      gplus: { type: Boolean, default: true }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    methods: {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      share ($event) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        window.alert(''Share on '' + $event.target.innerHTML);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  });"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</script> "},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Данный подход требует включения в вашу страницу ядра Vue.js и библиотеки vue-custom-element."},{"insert":"\nProps будут "},{"attributes":{"link":"https://karol-f.github.io/vue-custom-element/#/demos/basic"},"insert":"автоматически интерпретированы к их нативным типам"},{"insert":" (атрибут \"false\" интерпретируется как boolean значение false).\nAPI пользовательского элемента доступно так же как любого другого HTML элемента: document.getElementsByTagName(''share-buttons'').\nПример выше использует HTML тег , но вы можете поместить строку шаблона непосредственно в template свойство вашего компонента.\nПлюсы и минусы"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Из вышеописанного подхода следует что:\nзависимый скрипт должен быть включен в итоговый HTML файл"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"поведение компонента можно прочитать непосредственно из исходного кода страницы"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Это может оказаться как плюсами, так и минусами в зависимости от ваших задач.Наиболее вероятный подход, который я могу представить - это распространение Vue.js компонентов в форме виджетов на множество вебсайтов. Итак, давайте соберем весь этот код в единый файл.\nСборка Vue.js компонентов в единый .js файл"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Посмотрите на "},{"attributes":{"link":"https://github.com/kartsims/vue-customelement-bundler"},"insert":"vue-customelement-bundler"},{"insert":" репозиторий, который содержит:\nнастройки Webpack"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"код компонента (ES2015 во .vue файле)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"NPM зависимости, чтобы можно было собрать и запустить собственный экземпляр"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"Он позволяет взять код Vue.js компонента (в форме .vue файла) и на выходе получить единый .js файл"},{"insert":" с вложенным кодом самого Vue, библиотеки vue-custom-element и вашего Vue.js компонента. Получившийся файл будет зарегистрирован, чтобы использоваться, как пользовательский элемент. Далее, можно использовать ваш компонент в любом HTML/JS приложении, подобно этому:\n<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <my-vue-component/>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <!-- allows multiples instances of the same component -->"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <my-vue-component my-prop=\"true\"/>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <script src=\"my-vue-component.js\"></script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Замечание:  Итоговый файл весит 266kB (предыдущий текст перечеркнут). Слишком большой размер файла. Мои навыки в работе с Webpack не позволили его уменьшить. Попытки ипользовать плагин UglifyJsPlugin привели к ошибке, которую не удалось устранить. Возможно, у вас получиться лучше, пожалуйста сообщите мне как можно оптимизировать мои настройки, уверен их можно улучшить.\nИзменение 5/4: Спасибо "},{"attributes":{"link":"https://github.com/anthonygore"},"insert":"@anthonygore"},{"insert":" и UglifyJS, итоговый файл стал весить 113kB (предыдущий текст перечеркнут).\nИзменение 6/4: Энтони удалось уменьшить сборку еще на 22kB. "},{"attributes":{"bold":true},"insert":"Итоговый файл теперь весит 91kB (32kB в gzip)!"},{"insert":"\nИзменение 11/4: "},{"attributes":{"link":"https://github.com/chimon2000"},"insert":"@chimon2000"},{"insert":" предложено в качестве альтернативы для сборки "},{"attributes":{"bold":true},"insert":"использовать rollup.js, таким образом, вес файла стал 76kB (24kB в gzip)"},{"insert":", спасибо Раян! Эта сборка находится в "},{"attributes":{"link":"https://github.com/kartsims/vue-customelement-bundler/tree/rollup"},"insert":"rollup ветке репозитория"},{"insert":".\nНемного об API Web компонентов (Web Components API)"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Это часть статьи не обязательна для использования Vue.js компонентов, как Web компонентов, но часто бывает полезно знать как это работает, чтобы писать код лучше.\nWeb компоненты включают следующие W3C спецификации:\nCustom Element"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"HTML Template"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"HTML Import"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Рассмотрим каждую из них подробнее.\nCustom Element"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Custom Element является основным API, доступным разработчикам для определения новых HTML тегов, которые могут быть интерпретированы браузером.\n"},{"attributes":{"bold":true},"insert":"Функции обратных вызовов жизненного цикла (иначе говоря, "},{"attributes":{"bold":true,"link":"https://www.w3.org/TR/custom-elements/#custom-element-reactions"},"insert":"реакции"},{"attributes":{"bold":true},"insert":"):"},{"insert":"\nconstructor (элемент обновлен, имеется ввиду вставлен в DOM с помощью JS или изначально там находился)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"connectedCallback (вставка в DOM)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"disconnectedCallback (удаление из DOM)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"adoptedCallback (перемещение в новый документ)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"attributeChangedCallback"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Звучит знакомо? Да, это выглядит как жизненный цикл компонентов Vue.js!Однако, написание пользовательских элементов намного более многословно. Одна из причин этого - вы не можете получить выгоду от магии реактивных свойств во Vue.js, или \"сахара\" в синтаксисе шаблонов типо v-if выражений.\nРегистрация пользовательских элементов выполняется используя window.customElements.define, как в примере ниже:\nclass MyElement extends HTMLElement {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  constructor() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    super();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    this.msg = ''Hello, World!'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  connectedCallback() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    this.innerHTML = `<p>${this.msg}</p>`;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"window.customElements.define(''my-element'', MyElement); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обратите внимание, что connectedCallback вызывается, когда элемент уже вставлен.\nПомимо этого, теги компонентов должны соответствовать нескольким требованиям:\nсодержать дефис"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"не содержать заглавных символов"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"не использовать одно из запрещенных имен (annotation-xml, color-profile и т.д.)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://www.w3.org/TR/custom-elements/#valid-custom-element-name"},"insert":"Подробнее в W3C спецификации."},{"insert":"\nHTML Template"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Разметка пользовательского элемента может содержаться в теге внутри DOM.\n<template id=\"share-buttons-template\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <div id=\"share-buttons\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <a href=\"#\">Facebook</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <a href=\"#\">Twitter</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Эта разметка может быть импортирована и клонирована в пользовательский элемент по реакции на createdCallback.\nHTML Import"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Определяет разметку и JS логику в одном файле, который может быть импортирован в ваше приложение с помощью одного тега.\n<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <link rel=\"import\" href=\"share-buttons.html\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <share-buttons></share-buttons>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Содержимое файла share-buttons.html:\n<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    <div id=\"share-buttons\">"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      <a href=\"#\">Facebook</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      <a href=\"#\">Twitter</a>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    </div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </template>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    (function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"      document.registerElement(''share-buttons'', { prototype: MyCustomElement });"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    });"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  </script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Звучит все более и более знакомо, не так ли?\n(**)\nВзаимодействие компонентов"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Взаимодействие компонента с его родителем происходит посредством событий, точно так же как во Vue.js. События запускаются используя dispatchEvent метод HTML элементов.\nthis.dispatchEvent(new Event(''content-shared'')); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Родительский компонент может взаимодействовать с дочерними двумя способами:\nиспользуя атрибуты"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"используя методы компонента прототипа"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Первый способ точно такой же как во Vue.js. Вы можете установить атрибуты, только они не будут реактивными, так что вам будет нужно использовать attributeChangedCallback если захотите запускать логику, когда заначение атрибутов меняется.\nВторой метод тоже работает во Vue.js, хотя там он и не рекомендуется.\nПоддержка и полифиллы (polyfills)"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Состоянии поддержки браузерами пользовательских компонентов можно узнать на "},{"attributes":{"link":"http://caniuse.com/#search=web%20components"},"insert":"caniuse.com"},{"insert":" или "},{"attributes":{"link":"http://jonrimmer.github.io/are-we-componentized-yet/"},"insert":"are-we-componentized-yet"},{"insert":".\nБиблиотека полифиллов позволяет вам использовать эти API в браузерах, еще не имеющих их поддержки. Ниже ссылки на некоторые из них:\n"},{"attributes":{"link":"https://github.com/webcomponents/custom-elements"},"insert":"Custom Elements polyfill"},{"insert":" (от команды Polymer)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://github.com/WebReflection/document-register-element"},"insert":"document-register-element"},{"insert":" (от Andrea Giammarchi)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"italic":true},"insert":"Замечание: я не упоминал Shadow DOM в этой статье. Думаю это могло бы смутить разработчиков, которые фокусируются на переносе их Vue.js компонентов к пользовательским элементам. Посмотрите ссылки в конце, чтобы получить больше информации по данной теме."},{"insert":"\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://karol-f.github.io/vue-custom-element/"},"insert":"Vue Custom Element"},{"insert":": трансформация Vue.js компонентов в пользовательские элементы."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://github.com/kartsims/vue-customelement-bundler"},"insert":"Vue Custom Element Bundler"},{"insert":": сборка Vue.js компонентов в виде единого .js файла."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://www.webcomponents.org/"},"insert":"WebComponents.org"},{"insert":": каталог и ресурсы по пользовательским элементам (Custom Elements)."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Статья \"The case for Custom Elements\" ("},{"attributes":{"link":"https://medium.com/dev-channel/the-case-for-custom-elements-part-1-65d807b4b439#.lj3f8evee"},"insert":"часть 1"},{"insert":" и "},{"attributes":{"link":"https://medium.com/dev-channel/the-case-for-custom-elements-part-2-2efe42ce9133#.x0xz0nwph"},"insert":"часть 2"},{"insert":") автор Rob Dodson."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"link":"http://www.backalleycoder.com/2016/08/26/demythstifying-web-components/"},"insert":"Demythstifying Web Components"},{"insert":" автор Daniel Buchner."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Примечания к переводу"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"* На начало августа 2019 года все современные браузеры начали поддерживать актуальные спецификации Web Components. Исключением можно назвать MS Edge, но стоит учитывать, что Microsoft отказалась от дальнейшего развития собственной архитектуры и "},{"attributes":{"link":"https://habr.com/en/company/microsoft/blog/447364/"},"insert":"уже планируется выход Edge на основе Chromium"},{"insert":".\n** Со времени написания и перевода статьи спецификации претерпели ряд изменений. Актуальную информацию можно найти на сайте "},{"attributes":{"link":"https://www.webcomponents.org/"},"insert":"webcomponents.org"},{"insert":".\n*** К сожалению, ссылка на оригинал недоступна, раньше статься располагалась по "},{"attributes":{"link":"http://vuetips.com/vue-web-components"},"insert":"этому адресу"},{"insert":".\n"}]}',
    to_timestamp('03/09/2019, 20:52:26', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('17/09/2019, 09:38:34', 'DD/MM/YYYY, HH24:MI:SS')
  );

INSERT INTO
  note (
    "id",
    "name",
    "author_id",
    "title",
    "content",
    "created_at",
    "updated_at"
  )
VALUES
  (
    'ef45f77e-f973-47a5-ba41-a12450ccec3d',
    'Obzor-stat-i--He-who-thinks-change-detection-is-depth-first-and-he-who-thinks-it-s-breadth-first-are-both-usually-right-',
    '83f51013-2a43-4916-89da-6027f91f1190',
    'Обзор статьи "He who thinks change detection is depth-first and he who thinks it’s breadth-first are both usually right"',
    '{"ops":[{"insert":"Обзор статьи \"He who thinks change detection is depth-first and he who thinks it’s breadth-first are both usually right\""},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1567478643/blob_c6wjjv.png"}}},{"insert":"Max NgWizard K рассматривает чем же в сущности является механизм change detection (обнаружения изменений) в Angular - depth first (в глубину) или breadth first (в ширину). depth first - это когда проверяются дочерние компоненты по отношению к текущему, breadth first - проверяются соседние к текущему компоненту.\nПервое, что делает автор, это помещает механизм логирования в метод ngDoCheck. В результате оказывается, что проверка начинается алгоритмом breadth first, но затем останавливается на одной из ветвей дочерних компонентов и продолжается в виде алгоритма depth first. Этот факт вносит смуту и Max NgWizard K переносит логирование к методу, который вызывается в момент, когда механизм change detection оценивает выражения в шаблоне.\nВ результате получается правильный depth-first алгоритм. Чтобы пояснить итоги двух проведенных экспериментов автор напоминает ключевые операции в механизме change detection Angular:\nобновление свойств дочерних компонентов;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"вызов методов жизненного цикла NgDoCheck и NgOnChanges у дочерних компонентов;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"обновление DOM текущего компонента;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"запуск механизма change detection у дочерних компонентов."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Получается, что Angular запускает change detection дочерних компонентов во время обновления DOM текущего компонента. Такое поведение похоже на работу breadth-first алгоритма, что мы и увидели, когда поместили логирование в метод ngDoCheck. Но мы помним, что наряду с этим все еще выполняется операция обновления DOM текущего компонента и только после её завершения обновление перейдет к дочернему компоненту, а это уже depth first алгоритм.\nВ итоге автор приходит к выводу, что механизм change detection в Angular реализует depth-first алгоритм с предварительным вызовом метода ngDoCheck на соседних компонентах.\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Статья Max NgWizard K "},{"attributes":{"bold":true,"link":"https://blog.angularindepth.com/he-who-thinks-change-detection-is-depth-first-and-he-who-thinks-its-breadth-first-are-both-usually-8b6bf24a63e6"},"insert":"\"He who thinks change detection is depth-first and he who thinks it’s breadth-first are both usually right\" "},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"\n\n"}]}',
    to_timestamp('03/09/2019, 10:46:17', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('03/09/2019, 10:46:17', 'DD/MM/YYYY, HH24:MI:SS')
  );

------------------------------------------------------------------------------------------------
-- DAMP Drafts
insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('28/04/2020, 16:58:23', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('28/04/2020, 19:49:59', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Вы не знаете JS: Типы и грамматика"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Конспект по четвёртой книге You Don''t Know JS: Types & Grammar"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/types%20%26%20grammar/cover.jpg"}}},{"insert":"Глава 1: Типы"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Большинство разработчиков скажут, что динамический язык (как JS) не имеет "},{"attributes":{"italic":true},"insert":"типов"},{"insert":". Посмотрим, что спецификация ES5.1 ("},{"attributes":{"link":"http://www.ecma-international.org/ecma-262/5.1/"},"insert":"http://www.ecma-international.org/ecma-262/5.1/"},{"insert":") говорит об этом:\nАлгоритмы в этой спецификации управляют значениями, каждое из которых имеет связанный с ним тип. Возможные типы значений — это именно те, которые "},{"attributes":{"bold":true},"insert":"определены"},{"insert":" в этом разделе. Далее типы подразделяются на типы языка ECMAScript и типы спецификации."},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"Тип языка ECMAScript соответствует значениям, которые непосредственно обрабатываются программистом ECMAScript с использованием языка ECMAScript. Типы языка ECMAScript это: Undefined, Null, Boolean, String, Number и Object."},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"Тип"},{"insert":" — это встроенный набор характеристик, который однозначно идентифицирует поведение конкретного значения и отличает его от других значений, как для движка, так и для разработчика.\n\nТип, как бы он ни назывался..."},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\n\n\n"}]}'
  );

insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('09/04/2020, 21:31:27', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('28/04/2020, 16:45:48', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Вы не знаете JS: this и Прототипы Объектов (приложения)"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Конспект по третьей книге You Don''t Know JS: this & Object Prototypes"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/cover.jpg"}}},{"insert":"Приложение А: class в ES6"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"code":true},"insert":"class"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Давайте вспомним пример "},{"attributes":{"code":true},"insert":"Widget"},{"insert":" / "},{"attributes":{"code":true},"insert":"Button"},{"insert":" из главы 6:\nclass Widget {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor(width,height) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.width = width || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.height = height || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem = null;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\trender($where){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (this.$elem) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tthis.$elem.css( {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\twidth: this.width + \"px\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\theight: this.height + \"px\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t} ).appendTo( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"class Button extends Widget {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor(width,height,label) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsuper( width, height );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.label = label || \"Default\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem = $( \"<button>\" ).text( this.label );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\trender($where) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsuper.render( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem.click( this.onClick.bind( this ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tonClick(evt) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Button ''\" + this.label + \"'' clicked!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Кроме того, что синтаксис "},{"attributes":{"italic":true},"insert":"выглядит"},{"insert":" приятнее, какую проблему решает ES6?\nБольше нет (ну, типа того, см. ниже) отсылок к "},{"attributes":{"code":true},"insert":".prototype"},{"insert":", загромождающих код."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Button"},{"insert":" объявляется напрямую чтобы «унаследовать» ("},{"attributes":{"code":true},"insert":"extends"},{"insert":") "},{"attributes":{"code":true},"insert":"Widget"},{"insert":", вместо использования "},{"attributes":{"code":true},"insert":"Object.create(..)"},{"insert":" для замены привязанного "},{"attributes":{"code":true},"insert":".prototype"},{"insert":" или установки через "},{"attributes":{"code":true},"insert":".__proto__"},{"insert":" или "},{"attributes":{"code":true},"insert":"Object.setPrototypeOf(..)"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"super(..)"},{"insert":" теперь дает нам полезную функцию — относительный полиморфизм, так что любой метод одного уровня цепочки может обратиться к методу с тем же именем на другой уровень выше по цепочке. Сюда входит решение к заметке из главы 4 о странностях конструкторов, не принадлежащих к их классу и не связанных друг с другом — "},{"attributes":{"code":true},"insert":"super()"},{"insert":" работает внутри конструкторов именно так как вы ожидаете."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Литеральный синтаксис "},{"attributes":{"code":true},"insert":"class"},{"insert":" не позволяет указать свойства (только методы). Для кого-то это покажется ограничением, но, скорее всего, большинство ситуаций, в которых свойство (состояние) существует где-либо, кроме конечных экземпляров, являются ошибочными и неожиданными (поскольку это состояние, которе явно «распространяется» по всем «экземплярам»). В общем, "},{"attributes":{"italic":true},"insert":"можно"},{"insert":" сказать, что синтаксис "},{"attributes":{"code":true},"insert":"class"},{"insert":" защищает вас от ошибок."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"extends"},{"insert":" позволяет вам расширить даже встроенные (под)типы объектов, вроде "},{"attributes":{"code":true},"insert":"Array"},{"insert":" или "},{"attributes":{"code":true},"insert":"RegExp"},{"insert":" очень естественным способом. Такие действия без "},{"attributes":{"code":true},"insert":"class .. extends"},{"insert":" долгое время оставались избыточно сложной и удручающей задачей."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"\nГлюки "},{"attributes":{"code":true},"insert":"class"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"code":true},"insert":"class"},{"insert":" на самом деле не копирует содержимое статически во время объявления, как это происходит в традиционных класс-ориентированных языках. Если вы измените/замените метод (намеренно или случайно) родительского «класса», дочерний «класс» и/или экземпляр тоже будет затронут, поскольку они не копируются при объявлении, а всё еще используют модель делегирования, основанного на "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":":\nclass C {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.num = Math.random();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\trand() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Random: \" + this.num );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c1 = new C();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"c1.rand(); // \"Random: 0.4324299...\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"C.prototype.rand = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"Random: \" + Math.round( this.num * 1000 ));"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c2 = new C();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"c2.rand(); // \"Random: 867\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"c1.rand(); // \"Random: 432\" -- Ой!!!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Синтаксис "},{"attributes":{"code":true},"insert":"class"},{"insert":" "},{"attributes":{"italic":true},"insert":"не предоставляет"},{"insert":" способа объявить свойства экземпляра класса (только методы). Поэтому если вам нужно это для отслеживания состояния между экземплярами, вы вернётесь обратно к некрасивому синтаксису "},{"attributes":{"code":true},"insert":".prototype"},{"insert":", вроде такого:\nclass C {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// убедитесь, что изменяете общее состояние,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// а не добавляете затеняющее свойство"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// к экземплярам!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tC.prototype.count++;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// Здесь, `this.count` работает как и ожидается"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// через делегирование"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Hello: \" + this.count );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// добавим свойство для общего состояния напрямую"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// к объекту-прототипу"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"C.prototype.count = 0;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c1 = new C();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Hello: 1"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c2 = new C();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Hello: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"c1.count === 2; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"c1.count === c2.count; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Но у нас всё еще остался неожиданный глюк, когда "},{"attributes":{"code":true},"insert":"this.count++"},{"insert":" неявно создает затеняющее свойство "},{"attributes":{"code":true},"insert":".count"},{"insert":" в обоих объектах "},{"attributes":{"code":true},"insert":"c1"},{"insert":" и "},{"attributes":{"code":true},"insert":"c2"},{"insert":", вместо того, чтобы обновить общее состояние.\nclass C {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor(id) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// Ой, блин, мы затеняем метод `id()`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// значением свойства в экземпляре"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.id = id;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tid() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Id: \" + this.id );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c1 = new C( \"c1\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"c1.id(); // TypeError -- `c1.id` стала строкой \"c1\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Существует еще один тонкий нюанс, связанный с работой "},{"attributes":{"code":true},"insert":"super"},{"insert":". Вы могли предположить, что "},{"attributes":{"code":true},"insert":"super"},{"insert":" будет привязан по аналогии с привязкой "},{"attributes":{"code":true},"insert":"this"},{"insert":" (см. главу 2), что "},{"attributes":{"code":true},"insert":"super"},{"insert":" всегда будет привязан на уровень выше, вне зависимости от текущего положения метода в цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":".\nТем не менее, в целях повышения производительности (привязка "},{"attributes":{"code":true},"insert":"this"},{"insert":" и так дорого стоит), "},{"attributes":{"code":true},"insert":"super"},{"insert":" не привязывается динамически. Его привязка вроде как «статичная», как и момент вызова.\n"},{"attributes":{"italic":true},"insert":"Возможно"},{"insert":", найдутся и пути решения таких проблем. Использование "},{"attributes":{"code":true},"insert":"toMethod(..)"},{"insert":" чтобы привязать/перепривязать "},{"attributes":{"code":true},"insert":"[[HomeObject]]"},{"insert":" для метода (вместе с заданием "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" этого объекта!), кажется, сработает.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": "},{"attributes":{"code":true},"insert":"toMethod(..)"},{"insert":" клонирует метод и принимает "},{"attributes":{"code":true},"insert":"homeObject"},{"insert":" в качестве первого параметра, а второй параметр (необязательный) задаёт "},{"attributes":{"code":true},"insert":"name"},{"insert":" для нового метода.\n\nСтатический > Динамический?"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"В традиционных класс-ориентированных языках вы никогда не измените определение класса в дальнейшем, поэтому классы как паттерн проектирования не предлагают таких возможностей. Но одна из самых мощных особенностей JS состоит в том, что он является "},{"attributes":{"italic":true},"insert":"динамическим"},{"insert":", а определение любого объекта (пока вы не сделаете его иммутабельным) — это "},{"attributes":{"italic":true},"insert":"вещь"},{"insert":" подвижная и мутабельная.\n"},{"attributes":{"code":true},"insert":"class"},{"insert":" вроде подразумевает, что вы не должны делать такие штуки, склоняя вас использовать уродливый синтаксис "},{"attributes":{"code":true},"insert":".prototype"},{"insert":" или заставляя вас думать о подвохах "},{"attributes":{"code":true},"insert":"super"},{"insert":" и т.д. Он также предоставляет "},{"attributes":{"italic":true},"insert":"очень слабую"},{"insert":" поддержку на случай подводных камней, которые может принести такой динамизм.\n"},{"attributes":{"italic":true},"insert":"Примечание:"},{"insert":"* Если вы используете инструмент "},{"attributes":{"code":true},"insert":".bind(..)"},{"insert":", чтобы создать жестко привязанную функцию (см. главу 2), эта функция не может быть наследована с помощью "},{"attributes":{"code":true},"insert":"extend"},{"insert":" из ES6, в отличие от обычных функций.\n\n\n\nИсточник"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://github.com/azat-io/you-dont-know-js-ru/blob/master/this%20%26%20object%20prototypes/apA.md"},"insert":"https://github.com/azat-io/you-dont-know-js-ru/blob/master/this%20%26%20object%20prototypes/apA.md"},{"insert":"\n\n\n"}]}'
  );



insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('09/04/2020, 20:27:17', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('09/04/2020, 21:28:36', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Вы не знаете JS: this и Прототипы Объектов (часть 2)"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Конспект по третьей книге You Don''t Know JS: this & Object Prototypes"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/cover.jpg"}}},{"insert":"Глава 6: Делегирование поведения"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Как вы уже знаете из Главы 5, механизм [[Prototype]] — это внутренняя ссылка, которая существует в одном объекте и ссылается на другой объект.\nЭта ссылка используется при обращении к несуществующему свойству/методу первого объекта. В таком случае ссылка [[Prototype]] говорит движку, что свойство/метод нужно искать в связанном объекте. В свою очередь, если поиск в этом объекте завершается неудачно, то происходит переход уже по его ссылке [[Prototype]] и так далее. Эта последовательность ссылок между объектами образует так называемую \"цепочку прототипов\".\nДругими словами, реальный механизм, важнейшая часть функциональности, доступной нам в JavaScript — это по сути объекты, связанные с другими объектами.\n\nTowards Delegation-Oriented Design"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Чтобы использовать [[Prototype]] наиболее правильным способом, необходимо осознавать, что этот шаблон проектирования фундаментально отличается от классов (см. главу 4).\nНам нужно изменить наш способ мышления с шаблона проектирования \"класс/наследование\" на шаблон проектирования \"делегирование поведения\". \n\nТеория классов\nПредположим, что у нас есть несколько похожих задач (\"XYZ\", \"ABC\", etc), которые мы хотим смоделировать в нашем ПО.\nПри использовании классов проектирование происходит так: определяем общий родительский (базовый) класс Task, в котором задается поведение всех \"похожих\" задач. Затем определяем дочерние классы XYZ и ABC, которые наследуют от Task и добавляют уточненное поведение для выполнения собственных задач.\nВажно отметить, что шаблон проектирования классов диктует нам для получения максимальной выгоды от наследования использовать переопределение методов (и полиморфизм).\nВот примерный псевдокод для такого сценария:\nclass Task {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tid;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// конструктор `Task()`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tTask(ID) { id = ID; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\toutputTask() { output( id ); }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"class XYZ inherits Task {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tlabel;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// конструктор `XYZ()`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tXYZ(ID,Label) { super( ID ); label = Label; }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\toutputTask() { super(); output( label ); }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"class ABC inherits Task {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Эти экземпляры копируют как общее поведение из Task, так и уточненное поведение из XYZ. Обычно после создания вы взаимодействуете только с этими экземплярами (но не с классами), поскольку у каждого экземпляра есть копия всего поведения, которое необходимо для выполнения задачи.\n\nТеория делегирования\nА теперь давайте поразмышляем о той же предметной области, но с использованием делегирования поведения вместо классов.\nСначала определяется объект (не класс и не function, что бы ни говорили вам большинство JS разработчиков) по имени Task с конкретным поведением, включающим в себя вспомогательные методы, которыми могут пользоваться различные задачи (читай делегировать!). Затем для каждой задачи (\"XYZ\", \"ABC\") вы определяете объект с данными/поведением, специфичными для данной задачи. Вы связываете специфические объекты задач со вспомогательным объектом Task, позволяя им делегировать ему в случае необходимости.\nВ сущности, для выполнения задачи \"XYZ\" нам необходимо поведение двух объектов одного уровня (XYZ и Task). Но вместо композиции через копирование классов мы можем оставить их в виде отдельных объектов, и разрешить объекту XYZ делегировать объекту Task, когда это необходимо.\nВот простой пример кода, показывающий как этого добиться:\nvar Task = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tsetID: function(ID) { this.id = ID; },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\toutputID: function() { console.log( this.id ); }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// `XYZ` делегирует `Task`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var XYZ = Object.create( Task );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"XYZ.prepareTask = function(ID,Label) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.setID( ID );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.label = Label;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"XYZ.outputTaskDetails = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.outputID();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.label );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// ABC = Object.create( Task );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// ABC ... = ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В этом примере Task и XYZ не являются классами (или функциями), это просто объекты. С помощью Object.create(..) объект XYZ делегирует объекту Task через ссылку [[Prototype]] (см. главу 5).\nПо аналогии с класс-ориентированностью (или, OO — объектно-ориентированный), я назвал этот стиль кода \"OLOO\" (objects-linked-to-other-objects — \"объекты, связанные с другими объектами\"). Все, что нас действительно интересует — это тот факт, что объект XYZ делегирует объекту Task.\nВот некоторые другие отличия стиля OLOO:\nОба члена данных id и label из предыдущего примера с классами являются здесь свойствами данных непосредственно XYZ (ни одного из них нет в Task). Как правило в случае делегирования через [[Prototype]], вы хотите, чтобы состояние хранилось в делегирующих объектах (XYZ, ABC), а не в делегате (Task)."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"При использовании шаблона проектирования классов мы специально назвали outputTask одинаково как в родителе (Task), так и в потомке (XYZ), чтобы воспользоваться переопределением (полиморфизм). В случае делегирования поведения мы делаем ровно наоборот: при любой возможности избегаем одинаковых имен на разных уровнях цепочки [[Prototype]] (это называется затенением — см. главу 5), поскольку коллизии имен вынуждают использовать ужасный/хрупкий код для устранения неоднозначности ссылок (см. главу 4), а мы хотим избежать этого."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Этот шаблон проектирования предписывает отказ от общих, расплывчатых имен методов (предрасположенных к переопределению) в пользу более описательных имен, характерных для поведения каждого конкретного объекта. Это может сделать код проще для понимания/сопровождения, потому что имена методов (не только в месте их определения, но и по всему коду) становятся более очевидными (самодокументируемыми)."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"this.setID(ID); внутри метода объекта XYZ сначала ищет setID(..) в XYZ, но поскольку метода с таким именем нет в XYZ, делегирование [[Prototype]] означает, что можно пройти по ссылке на Task, чтобы найти там setID(..), что и происходит. Более того, благодаря неявным правилам привязки this (см. главу 2), при выполнении setID(..), хотя этот метод и был найден в Task, this для данного вызова функции — это XYZ, как мы того и желали. То же самое происходит и с this.outputID() чуть дальше в листинге кода."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Делегирование поведения означает: пусть у одного объекта (XYZ) будет делегирование (к Task) для обращения к свойству или методу, отсутствующему в объекте (XYZ).\n\nВзаимное делегирование (запрещено)\nНельзя создавать цикл, где между двумя или более объектами есть взаимное (двунаправленное) делегирование. Если вы создадите B, связанный с A, а затем попытаетесь связать A с B, то получите ошибку.\n\nОтладка\nПосмотрите на этот \"традиционный\" стиль \"конструктора классов\" в JS коде, и то, что отображается в консоли Chrome Developer Tools:\nfunction Foo() {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a1 = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1; // Foo {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обратите внимание на последнюю строку кода: в результате вычисления выражения a1 выводится Foo {}. Если запустить этот код в Firefox, то скорее всего мы увидим Object {}.\nChrome по сути говорит нам, что \"{} — это пустой объект, который был создан функцией с именем ''Foo''\". Firefox же говорит, что \"{} — это пустой объект, созданный на основе Object\". Маленькое отличие состоит в том, что Chrome отслеживает в виде внутреннего свойства имя реальной функции, создавшей объект, а другие браузеры такую информацию не отслеживают.\nЕсть соблазн попытаться объяснить это с помощью механизмов JavaScript:\nfunction Foo() {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a1 = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1.constructor; // Foo(){}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1.constructor.name; // \"Foo\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Получается, что Chrome выводит \"Foo\", всего-навсего проверяя свойство .constructor.name объекта? И \"да\", и \"нет\".\nРассмотрим код:\nfunction Foo() {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a1 = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.constructor = function Gotcha(){};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1.constructor; // Gotcha(){}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1.constructor.name; // \"Gotcha\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1; // Foo {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Несмотря на то, что мы изменили a1.constructor.name на другое значение (\"Gotcha\"), консоль Chrome по-прежнему использует имя \"Foo\".\nИтак, получается, что ответ на предыдущий вопрос (используется ли .constructor.name?) — нет, информация отслеживается где-то в другом месте, внутри движка.\nДавайте посмотрим, как это работает при использовании стиля OLOO:\nvar Foo = {};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a1 = Object.create( Foo );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1; // Object {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( Foo, \"constructor\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tenumerable: false,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvalue: function Gotcha(){}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"});"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1; // Gotcha {}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Ага! Попались! Здесь консоль Chrome нашла и использует .constructor.name. На самом деле, на момент написания этой книги данное поведение было идентифицировано как баг в Chrome, и сейчас, когда вы её читаете, баг скорее всего исправлен. Поэтому в вашем браузере может выдаваться корректный результат a1; // Object {}.\nЕсли не обращать внимания на этот баг, то внутреннее отслеживание \"имени конструктора\" (по-видимому, только в целях отладки в консоли) в Chrome является собственным поведением Chrome, выходящим за рамки спецификации.\nЕсли вы не используете \"конструктор\" для создания объектов, как того и требует OLOO стиль кодирования в этой главе, тогда Chrome не будет отслеживать внутреннее \"имя конструктора\" для этих объектов, и они будут отображаться в консоли как \"Object {}\", то есть, \"объекты, созданные из Object()\".\nНе думайте, что это является недостатком OLOO стиля. Когда вы используете шаблон проектирования на основе OLOO и делегирования поведения, совершенно неважно, кто \"создал\" объект (то есть, какая функция была вызвана с new?). Отслеживание \"имени конструктора\" внутри Chrome полезно только если вы полностью пишете код \"в стиле классов\", но совершенно неактуально при использовании OLOO делегирования.\n\nСравнение мысленных моделей\nМы рассмотрим абстрактный код (\"Foo\", \"Bar\"), и сравним два способа его реализации (OO против OLOO). Первый фрагмент кода использует классический (\"прототипный\") OO стиль:\nfunction Foo(who) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.me = who;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.identify = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn \"I am \" + this.me;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Bar(who) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tFoo.call( this, who );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype = Object.create( Foo.prototype );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype.speak = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\talert( \"Hello, \" + this.identify() + \".\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b1 = new Bar( \"b1\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b2 = new Bar( \"b2\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b1.speak();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b2.speak();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Теперь давайте реализуем ту же самую функциональность, используя код в стиле OLOO:\nvar Foo = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tinit: function(who) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.me = who;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t},"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tidentify: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\treturn \"I am \" + this.me;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Bar = Object.create( Foo );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.speak = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\talert( \"Hello, \" + this.identify() + \".\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b1 = Object.create( Bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b1.init( \"b1\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b2 = Object.create( Bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b2.init( \"b2\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b1.speak();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b2.speak();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Мы используем преимущество делегирования [[Prototype]] от b1 к Bar, и от Bar к Foo, аналогично тому, как сделали это в предыдущем примере с b1, Bar.prototype, и Foo.prototype. У нас по-прежнему есть те же самые 3 объекта, связанные вместе.\nДавайте рассмотрим мысленные модели, связанные с двумя этими примерами.\nПример с классами предполагает следующую мысленную модель сущностей и взаимосвязей между ними:\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/fig4.png"}}},{"insert":"На самом деле, это немного нечестно, потому что здесь показано множество дополнительных нюансов, которые вы строго говоря не должны постоянно держать в голове (хотя вам надо понимать их!). С одной стороны, это довольно сложная последовательность взаимосвязей. Но с другой стороны, если вы внимательно изучите эти стрелки со связями, то поймете, что механизмы JS обладают потрясающей внутренней целостностью и непротиворечивостью.\nХорошо, давайте теперь посмотрим на слегка упрощенную версию этой диаграммы, чтобы сделать наше сравнение чуть более \"честным\". Здесь показаны лишь ключевые сущности и взаимосвязи.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/fig5.png"}}},{"insert":"Пунктирными линиями обозначены неявные взаимосвязи, когда вы установили \"наследование\" между Foo.prototype и Bar.prototype, но пока еще не исправили ссылку на отсутствующее свойство .constructor (см. раздел \"И снова о конструкторе\" в главе 5).\nА теперь давайте посмотрим на мысленную модель для кода в OLOO-стиле:\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/fig6.png"}}},{"insert":"Из этого сравнения очевидно, что в OLOO-стиле вам нужно учитывать гораздо меньшее количество нюансов, поскольку в OLOO принимается за аксиому тот факт, что нас интересуют только объекты, связанные с другими объектами.\n\nКлассы против объектов"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"\n\"Классы\" виджетов\nДавайте посмотрим, как бы мы могли реализовать архитектуру \"классов\" на чистом JS, без каких-либо вспомогательных библиотек \"классов\" или синтаксиса:\n// Родительский класс"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Widget(width,height) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.width = width || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.height = height || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.$elem = null;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Widget.prototype.render = function($where){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tif (this.$elem) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem.css( {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\twidth: this.width + \"px\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\theight: this.height + \"px\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t} ).appendTo( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Дочерний класс"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Button(width,height,label) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// вызов конструктора \"super\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tWidget.call( this, width, height );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.label = label || \"Default\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.$elem = $( \"<button>\" ).text( this.label );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// `Button` \"наследует\" от `Widget`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Button.prototype = Object.create( Widget.prototype );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// переопределяем базовый \"унаследованный\" `render(..)`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Button.prototype.render = function($where) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// вызов \"super\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tWidget.prototype.render.call( this, $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.$elem.click( this.onClick.bind( this ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Button.prototype.onClick = function(evt) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"Button ''\" + this.label + \"'' clicked!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"$( document ).ready( function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar $body = $( document.body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar btn1 = new Button( 125, 30, \"Hello\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar btn2 = new Button( 150, 40, \"World\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn1.render( $body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn2.render( $body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обратите внимание на уродливый явный псевдополиморфизм ссылок Widget.call и Widget.prototype.render.call для имитации вызова \"super\" из методов дочернего \"класса\".\n\nСинтаксический сахар ES6: class\nМы подробно рассмотрим синтаксический сахар class в ES6 в Приложении А. Ну а пока давайте узнаем, как мы могли бы реализовать тот же самый код с помощью class:\nclass Widget {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor(width,height) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.width = width || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.height = height || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem = null;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\trender($where){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (this.$elem) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tthis.$elem.css( {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\twidth: this.width + \"px\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\theight: this.height + \"px\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t} ).appendTo( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"class Button extends Widget {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconstructor(width,height,label) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsuper( width, height );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.label = label || \"Default\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem = $( \"<button>\" ).text( this.label );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\trender($where) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsuper.render( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem.click( this.onClick.bind( this ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tonClick(evt) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Button ''\" + this.label + \"'' clicked!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"$( document ).ready( function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar $body = $( document.body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar btn1 = new Button( 125, 30, \"Hello\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar btn2 = new Button( 150, 40, \"World\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn1.render( $body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn2.render( $body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Несмотря на улучшение синтаксиса, это не настоящие классы, поскольку они по-прежнему работают поверх механизма [[Prototype]].\n\nДелегирование объектов виджетов\nВот более простая реализация нашего примера с Widget / Button, использующая делегирование в стиле OLOO:\nvar Widget = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tinit: function(width,height){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.width = width || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.height = height || 50;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.$elem = null;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t},"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tinsert: function($where){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (this.$elem) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tthis.$elem.css( {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\twidth: this.width + \"px\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\theight: this.height + \"px\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t} ).appendTo( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Button = Object.create( Widget );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Button.setup = function(width,height,label){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// делегированный вызов"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.init( width, height );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.label = label || \"Default\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.$elem = $( \"<button>\" ).text( this.label );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Button.build = function($where) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// делегированный вызов"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.insert( $where );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.$elem.click( this.onClick.bind( this ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Button.onClick = function(evt) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"Button ''\" + this.label + \"'' clicked!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"$( document ).ready( function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar $body = $( document.body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar btn1 = Object.create( Button );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn1.setup( 125, 30, \"Hello\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar btn2 = Object.create( Button );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn2.setup( 150, 40, \"World\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn1.build( $body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbtn2.build( $body );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Применяя OLOO-стиль, мы не думаем о Widget и Button как о родительском и дочернем классах. Вместо этого, Widget — это просто объект, некий набор утилит, которым может делегировать любой конкретный тип виджета, а Button — это тоже самостоятельный объект (с делегирующей ссылкой на Widget, разумеется!).\nМы не используем в обоих объектах одно и то же имя метода render(..), как то предписывается шаблоном проектирования классов. Вместо этого мы выбрали разные имена (insert(..) и build(..)), которые более точно описывают решаемую каждым классом задачу. Инициализирующие методы названы init(..) и setup(..), соответственно, по тем же причинам.\n\nБолее элегантный синтаксис"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Одно из приятных новшеств, которое делает class в ES6 обманчиво притягательным (о том, почему стоит его избегать, см. в Приложении А!), — сокращенный синтаксис для объявления методов класса:\nclass Foo {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tmethodName() { /* .. */ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Мы избавились от ключевого слова function в объявлении, что обрадовало JS-разработчиков по всему миру!\nВы наверное заметили, что в OLOO синтаксисе function встречается на каждом шагу, что немного расходится с нашей целью упростить код. Но мы можем это исправить!\nВ ES6 мы можем использовать сокращенные объявления методов в любом объектном литерале, поэтому объект в OLOO-стиле можно объявить так (такой же сокращенный синтаксис, что и в теле class):\nvar LoginController = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\terrors: [],"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tgetUser() { // Смотри-ка, нет `function`!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t},"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tgetPassword() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Единственная разница в том, что в объектных литералах по-прежнему надо использовать разделители , между элементами, тогда как синтаксис class этого не требует. \n\n"},{"attributes":{"bold":true},"insert":"Лексический недостаток"},{"insert":"\nУ кратких методов есть небольшой недостаток, о котором нужно знать. Рассмотрим код:\nvar Foo = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbar() { /*..*/ },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbaz: function baz() { /*..*/ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Если убрать синтаксический сахар, то этот код будет работать так:\nvar Foo = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbar: function() { /*..*/ },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbaz: function baz() { /*..*/ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Отсутствие идентификатора "},{"attributes":{"code":true},"insert":"name"},{"insert":" у анонимной функции:\nусложняет отладку стектрейсов (stack traces)"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"усложняет работу с функциями, ссылающимися на самих себя (рекурсия, подписка/отписка обработчика события, и т.п.)"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"немного затрудняет понимание кода"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"\nИнтроспекция"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"интроспекция типа"},{"insert":": проверка экземпляра с целью выяснить, какого "},{"attributes":{"italic":true},"insert":"вида"},{"insert":" объект перед вами. Основная цель "},{"attributes":{"italic":true},"insert":"интроспекции типа"},{"insert":" экземпляра класса — узнать о структуре и функциональных возможностях объекта исходя из того "},{"attributes":{"italic":true},"insert":"как он был создан"},{"insert":".\nРассмотрим пример кода, в котором для интроспекции объекта "},{"attributes":{"code":true},"insert":"a1"},{"insert":" используется "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" (см. главу 5):\nfunction Foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.something = function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a1 = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// позднее"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (a1 instanceof Foo) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta1.something();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Благодаря "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":" (не "},{"attributes":{"code":true},"insert":"Foo"},{"insert":"!) в цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" (см. главу 5) объекта "},{"attributes":{"code":true},"insert":"a1"},{"insert":", оператор "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" сообщает нам, что "},{"attributes":{"code":true},"insert":"a1"},{"insert":" будто бы является экземпляром \"класса\" "},{"attributes":{"code":true},"insert":"Foo"},{"insert":". Исходя из этого мы предполагаем, что у "},{"attributes":{"code":true},"insert":"a1"},{"insert":" есть функциональные возможности, описанные в \"классе\" "},{"attributes":{"code":true},"insert":"Foo"},{"insert":".\nСемантическая путаница (и косвенность) синтаксиса "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" приводит к тому, что для интроспекции объекта "},{"attributes":{"code":true},"insert":"a1"},{"insert":" с целью выяснить, обладает ли он функциональными возможностями искомого объекта, вам "},{"attributes":{"italic":true},"insert":"необходима"},{"insert":" функция, содержащая ссылку на этот объект. То есть, вы не можете напрямую узнать, связаны ли два объекта.\nВспомните абстрактный пример "},{"attributes":{"code":true},"insert":"Foo"},{"insert":" / "},{"attributes":{"code":true},"insert":"Bar"},{"insert":" / "},{"attributes":{"code":true},"insert":"b1"},{"insert":", который мы рассматривали ранее в этой главе:\nfunction Foo() { /* .. */ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Bar() { /* .. */ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype = Object.create( Foo.prototype );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b1 = new Bar( \"b1\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Вот список проверок, которые вам придется выполнить для "},{"attributes":{"italic":true},"insert":"интроспекции типов"},{"insert":" этих сущностей с помощью семантики "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" и "},{"attributes":{"code":true},"insert":".prototype"},{"insert":":\n// устанавливаем связь между `Foo` и `Bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype instanceof Foo; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getPrototypeOf( Bar.prototype ) === Foo.prototype; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.isPrototypeOf( Bar.prototype ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// устанавливаем связь между `b1` и `Foo` и `Bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b1 instanceof Foo; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b1 instanceof Bar; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getPrototypeOf( b1 ) === Bar.prototype; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.isPrototypeOf( b1 ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype.isPrototypeOf( b1 ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Еще один распространенный, но возможно менее надежный метод интроспекции типов, который многие разработчики предпочитают оператору instanceof, называется \"утиная типизация\". Этот термин берет свое начало из афоризма \"если нечто выглядит как утка и крякает как утка, то возможно это и есть утка\".\nПример:\nif (a1.something) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta1.something();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Однако зачастую понятие \"утиной типизации\" расширяется, и делаются дополнительные предположения о возможностях объекта, выходящие за рамки проверки. Разумеется, это увеличивает риски и делает дизайн более хрупким.\nЯрким примером \"утиной типизации\" являются обещания (Promises) в ES6. "},{"attributes":{"bold":true},"insert":"Если у какого угодно объекта найдется метод"},{"insert":" "},{"attributes":{"code":true},"insert":"then()"},{"insert":", то механизм обещаний ES6 будет считать что это \""},{"attributes":{"bold":true},"insert":"thenable"},{"insert":"\" объект, и будет ожидать от него стандартного поведения Promises.\nЭтот пример наглядно иллюстрирует риски \"утиной типизации\". Подобные вещи следует использовать лишь в разумных пределах и в контролируемом окружении.\nВозвращаясь к коду в стиле OLOO отметим, что "},{"attributes":{"italic":true},"insert":"интроспекция типов"},{"insert":" в данном случае может быть гораздо элегантнее. Давайте вспомним фрагмент OLOO кода "},{"attributes":{"code":true},"insert":"Foo"},{"insert":" / "},{"attributes":{"code":true},"insert":"Bar"},{"insert":" / "},{"attributes":{"code":true},"insert":"b1"},{"insert":", рассмотренный ранее в этой главе:\nvar Foo = { /* .. */ };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Bar = Object.create( Foo );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b1 = Object.create( Bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Поскольку в OLOO у нас есть лишь обычные объекты, связанные делегированием "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", мы можем использовать гораздо более простую форму "},{"attributes":{"italic":true},"insert":"интроспекции типов"},{"insert":":\n// устанавливаем связь между `Foo` и `Bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.isPrototypeOf( Bar ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getPrototypeOf( Bar ) === Foo; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// устанавливаем связь между `b1` и `Foo` и `Bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.isPrototypeOf( b1 ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.isPrototypeOf( b1 ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getPrototypeOf( b1 ) === Bar; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Мы больше не используем "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":", потому что он претендует на то, что каким-то образом связан с классами. Теперь мы просто задаем (неформальный) вопрос \"являешься ли ты моим прототипом?\"\n\nОбзор (TL;DR)"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Классы и наследование — это один из возможных шаблонов проектирования, который вы можете "},{"attributes":{"italic":true},"insert":"использовать"},{"insert":" или "},{"attributes":{"italic":true},"insert":"не использовать"},{"insert":" в архитектуре вашего ПО. Большинство разработчиков считают само собой разумеющимся тот факт, что классы являются единственным (правильным) способом организации кода. Но в этой главе мы увидели другой, менее популярный, но весьма мощный шаблон проектирования: делегирование поведения.\nДелегирование поведения предполагает, что все объекты находятся на одном уровне и связаны друг с другом делегированием, а не отношениями родитель-потомок. Механизм "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" в JavaScript по своему замыслу является механизмом делегирования поведения. Это значит, что мы можем либо всячески пытаться реализовать механику классов поверх JS (см. главы 4 и 5), либо принять истинную сущность "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" как механизма делегирования.\nЕсли вы проектируете код, используя только объекты, это не только упрощает синтаксис, но и позволяет добиться более простой архитектуры кода.\nOLOO (объекты, связанные с другими объектами) — это стиль кодирования, в котором объекты создаются и связываются друг с другом без абстракции классов. OLOO вполне естественным образом реализует делегирование поведения при помощи "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":".\n\n\nИсточник"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"https://github.com/azat-io/you-dont-know-js-ru/tree/master/this%20%26%20object%20prototypes\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('23/03/2020, 15:20:33', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('23/03/2020, 17:44:55', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Анализ работы listener"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Логи listener (первого из подов):\nfor p in (kubectl get pods -n lims-dev | grep listener | head -n1 | awk ''{print $1}'')"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  kubectl logs --since=30m -f $p -n lims-dev"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"end"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nУдаление одного пода по имени:\nkubectl delete pod storages-646b7f97b-dxbsq --grace-period=0 --force -n lims-dev "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nУдаление всех подов listener:\nfor p in (kubectl get pods -n lims-dev | grep listener | awk ''{print $1}'')"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  kubectl delete pod $p --grace-period=0 --force -n lims-dev"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"end "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nСписок подов:\nkubectl get pods -n lims-dev "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"с лейблами:\nkubectl get pods --show-labels -n lims-dev "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nЗайти в под:\nkubectl exec -it storages-646b7f97b-dxbsq -n lims-dev bash "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"insert":{"blockDivider":true}},{"insert":"\nHow to select list of active connections to a PostgreSQL database:\nSELECT * FROM pg_stat_activity; "},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"link":"https://stackoverflow.com/questions/3185266/postgresql-temporarily-disable-connections"},"insert":"PostgreSQL: Temporarily disable connections"},{"insert":":\nupdate pg_database set datallowconn = false where datname = ''applogs''; "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n\n\n\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"http://fishshell.com/docs/current/faq.html#faq-subcommand"},"insert":"http://fishshell.com/docs/current/faq.html#faq-subcommand"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"\n\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('31/01/2020, 16:56:42', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('09/04/2020, 20:28:23', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Вы не знаете JS: this и Прототипы Объектов (часть 1)"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Конспект по третьей книге You Don''t Know JS: this & Object Prototypes"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/cover.jpg"}}},{"insert":"Глава 1: this (тут) или That (там)?"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nЗачем нужен this?"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Давайте попытаемся проиллюстрировать мотивацию и полезность механизма this:\nfunction identify() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.name.toUpperCase();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function speak() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar greeting = \"Hello, I''m \" + identify.call( this );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( greeting );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var me = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tname: \"Kyle\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var you = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tname: \"Reader\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"identify.call( me ); // KYLE"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"identify.call( you ); // READER"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"speak.call( me ); // Hello, I''m KYLE"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"speak.call( you ); // Hello, I''m READER"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Заблуждения"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Сама функция"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Первый общий соблазн это предполагать, что this ссылается на саму функцию. Это, как минимум, резонное грамматическое заключение.\nРассмотрим следующий код, где мы попытаемся отследить сколько раз функция (foo) была вызвана:\nfunction foo(num) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"foo: \" + num );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// Отслеживаем сколько раз `foo` была вызвана"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.count++;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.count = 0;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var i;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (i=0; i<10; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tif (i > 5) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tfoo( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 6"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 7"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 8"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 9"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Сколько раз была вызвана `foo`?"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( foo.count ); // 0 -- WTF?"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"foo.count"},{"insert":" до сих пор равен "},{"attributes":{"code":true},"insert":"0"},{"insert":", даже не смотря на то, что 4 инструкции "},{"attributes":{"code":true},"insert":"console.log"},{"insert":" очевидно показывают, что "},{"attributes":{"code":true},"insert":"foo(..)"},{"insert":" на самом деле была вызвана "},{"attributes":{"code":true},"insert":"4"},{"insert":" раза.\nКогда код выполняет команду "},{"attributes":{"code":true},"insert":"foo.count = 0"},{"insert":", он на самом деле добавляет свойство "},{"attributes":{"code":true},"insert":"count"},{"insert":" в объект функции "},{"attributes":{"code":true},"insert":"foo"},{"insert":". Но для ссылки "},{"attributes":{"code":true},"insert":"this.count"},{"insert":" внутри функции "},{"attributes":{"code":true},"insert":"this"},{"insert":" фактически не указывает на тот же объект функции, и несмотря на то, что имена свойств одинаковые, это разные объекты.\nНа самом деле мы создали глобальную переменную "},{"attributes":{"code":true},"insert":"count"},{"insert":" (смотрите в главе 2 как это произошло!), а её текущим значением является NaN.\nРассмотрим эти 2 функции:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo.count = 4; // `foo` ссылается на саму себя"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"setTimeout( function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// анонимная функция (без имени), не может"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ссылаться на себя"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}, 10 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В первой функции вызывалась \"именованная функция\", "},{"attributes":{"code":true},"insert":"foo"},{"insert":" — это ссылка, которая может быть использована для ссылки на функцию из самой себя.\nНо во втором примере функция обратного вызова, передаваемая в "},{"attributes":{"code":true},"insert":"setTimeout(..)"},{"insert":", не имела имени идентификатора (так называемая \"анонимная функция\"), так что у неё нет правильного пути чтобы обратиться к её объекту.\nТаким образом, другое решение нашего примера — это использовать идентификатор "},{"attributes":{"code":true},"insert":"foo"},{"insert":" как ссылку на объект функции в каждом месте и вообще не использовать "},{"attributes":{"code":true},"insert":"this"},{"insert":", и это работает:\nfunction foo(num) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"foo: \" + num );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// следим, сколько раз вызывается функция"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo.count++;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.count = 0;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var i;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (i=0; i<10; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tif (i > 5) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tfoo( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 6"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 7"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 8"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 9"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// сколько раз `foo` была вызвана?"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( foo.count ); // 4"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Однако, этот подход также является уклонением от фактического понимания "},{"attributes":{"code":true},"insert":"this"},{"insert":", и полностью зависит от области видимости переменной "},{"attributes":{"code":true},"insert":"foo"},{"insert":".\nЕще один путь решения проблемы - это заставить "},{"attributes":{"code":true},"insert":"this"},{"insert":" действительно указывать на объект функции "},{"attributes":{"code":true},"insert":"foo"},{"insert":":\nfunction foo(num) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"foo: \" + num );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// следим, сколько раз вызывается функция"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// Заметьте: `this` теперь действительно ссылается на `foo`, это основано на том,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// как `foo` вызывается (см. ниже)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.count++;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.count = 0;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var i;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (i=0; i<10; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tif (i > 5) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// используя `call(..)` мы гарантируем что `this`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// ссылается на объект функции (`foo`) изнутри"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tfoo.call( foo, i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 6"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 7"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 8"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// foo: 9"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// сколько раз `foo` была вызвана?"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( foo.count ); // 4"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nЭто область видимости функции"},{"attributes":{"list":{"type":"ordered","start":"1"}},"insert":"\n"},{"insert":"Следующее большое общее заблуждение касательно того, на что указывает this - это то, что он каким-то образом ссылается на область видимости функции.\nДля ясности, this, в любом случае, не ссылается на область видимости функции. Это правда, что внутри область видимости имеет вид объекта со свойствами для каждого определенного значения. Но \"объект\" области видимости не доступен в JavaScript коде. Это внутренняя часть механизма реализации языка (интерпретатора).\nРассмотрим код, который пытается (и безуспешно!) перейти границу и использовать this неявно ссылаясь на область видимости функции:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.bar();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo(); //undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Во-первых, попытка ссылаться на функцию bar() как this.bar(). Это почти наверняка случайность, что это работает, но мы коротко объясним как это работает позже. Наиболее естественным путем вызвать bar() было бы опустить предшествующий this. и просто сделать ссылку на идентификатор.\nОднако, разработчик, который писал этот код, пытался использовать "},{"attributes":{"code":true},"insert":"this"},{"insert":", чтобы создать мост между областями видимости "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" и "},{"attributes":{"code":true},"insert":"bar()"},{"insert":" так, чтобы "},{"attributes":{"code":true},"insert":"bar()"},{"insert":" получила доступ к переменной "},{"attributes":{"code":true},"insert":"a"},{"insert":" внутри области видимости "},{"attributes":{"code":true},"insert":"foo()"},{"insert":". Не всякий мост возможен. Вы не можете использовать ссылку this, чтобы найти что-нибудь в области видимости. Это невозможно.\n\nЧто же такое this?"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Мы ранее сказали, что "},{"attributes":{"code":true},"insert":"this"},{"insert":" привязывается не во время написания функции, а во время её вызова. Это вытекает из контекста, который основывается на обстоятельствах вызова функции. Привязка "},{"attributes":{"code":true},"insert":"this"},{"insert":" не имеет ничего общего с определением функции, но зависит от того при каких условиях функция была вызвана.\nКогда функция вызывается, создается запись активации, также известная как контекст вызова. Эта запись содержит информацию о том, откуда функция была вызвана (стэк вызова), как функция была вызвана, какие параметры были в неё переданы и т.д. Одним из свойств этой записи является ссылка "},{"attributes":{"code":true},"insert":"this"},{"insert":", которая будет использоваться на протяжении выполнения этой функции.\n\n\nГлава 2: Весь this теперь приобретает смысл!"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Точка вызова"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Это место в коде, где была вызвана функция (не там, где она объявлена). Мы должны исследовать точку вызова, чтобы ответить на вопрос: на что же "},{"attributes":{"italic":true},"insert":"этот"},{"insert":" "},{"attributes":{"code":true},"insert":"this"},{"insert":" указывает?\nВажно поразмышлять над стеком вызовов (стеком функций, которые были вызваны, чтобы привести нас к текущей точке исполнения кода). Точка вызова, которая нас интересует, находится "},{"attributes":{"italic":true},"insert":"в"},{"insert":" вызове "},{"attributes":{"italic":true},"insert":"перед"},{"insert":" текущей выполняемой функцией.\nПродемонстрируем стек вызовов и точку вызова:\nfunction baz() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // стек вызовов: `baz`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // поэтому наша точка вызова — глобальная область видимости"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( \"baz\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    bar(); // <-- точка вызова для `bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // стек вызовов: `baz` -> `bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // поэтому наша точка вызова в `baz`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( \"bar\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    foo(); // <-- точка вызова для `foo`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // стек вызовов: `baz` -> `bar` -> `foo`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // поэтому наша точка вызова в `bar`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( \"foo\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"baz(); // <-- точка вызова для `baz`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nНичего кроме правил"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Теперь обратим наш взор на то, "},{"attributes":{"italic":true},"insert":"как"},{"insert":" точка вызова определяет на что будет указывать "},{"attributes":{"code":true},"insert":"this"},{"insert":" во время выполнения функции.\n\n"},{"attributes":{"bold":true},"insert":"Привязка по умолчанию"},{"insert":"\nПервое правило, которое мы изучим, исходит из самого распространенного случая вызовов функции: отдельный вызов функции. Представьте себе "},{"attributes":{"italic":true},"insert":"это"},{"insert":" правило "},{"attributes":{"code":true},"insert":"this"},{"insert":" как правило, действующее по умолчанию когда остальные правила не применяются.\nРассмотрим такой код:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo(); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Первая вещь, которую можно отметить, если вы еще не сделали этого, то, что переменные, объявленные в глобальной области видимости, как например "},{"attributes":{"code":true},"insert":"var a = 2"},{"insert":", являются синонимами глобальных свойств-объектов с таким же именем. Они не являются копиями друг друга, они и "},{"attributes":{"italic":true},"insert":"есть"},{"insert":" одно и то же. Представляйте их как две стороны одной монеты.\nВо-вторых, видно, что когда вызывается "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" "},{"attributes":{"code":true},"insert":"this.a"},{"insert":" указывает на нашу глобальную переменную "},{"attributes":{"code":true},"insert":"a"},{"insert":". Почему? Потому что в этом случае, для "},{"attributes":{"code":true},"insert":"this"},{"insert":" применяется "},{"attributes":{"italic":true},"insert":"привязка по умолчанию"},{"insert":" при вызове функции и поэтому "},{"attributes":{"code":true},"insert":"this"},{"insert":" указывает на глобальный объект.\nКогда включен "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":", объект ''global'' не подпадает под действие "},{"attributes":{"italic":true},"insert":"привязки по умолчанию"},{"insert":", поэтому в противоположность обычному режиму "},{"attributes":{"code":true},"insert":"this"},{"insert":" устанавливается в "},{"attributes":{"code":true},"insert":"undefined"},{"insert":".\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo(); // TypeError: `this` is `undefined`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Едва уловимая, но важная деталь: даже если все правила привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":" целиком основываются на точке вызова, глобальный объект подпадает под "},{"attributes":{"italic":true},"insert":"привязку по умолчанию"},{"insert":" только если содержимое "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" не выполняется в режиме "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":"; Состояние "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":" в точке вызова "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" не имеет значения.\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo(); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Неявная привязка"},{"insert":"\nРассмотрим еще одно правило: есть ли у точки вызова объект контекста, также называемый как владеющий или содержащий объект, хотя "},{"attributes":{"italic":true},"insert":"эти"},{"insert":" альтернативные термины могут немного вводить в заблуждение.\nРассмотрим:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.foo(); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Независимо от того была ли "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" изначально объявлена "},{"attributes":{"italic":true},"insert":"в"},{"insert":" "},{"attributes":{"code":true},"insert":"obj"},{"insert":" или добавлена позднее как ссылка (как в вышеприведенном коде), ни в том, ни в другом случае функция на самом деле не \"принадлежит\" или \"содержится\" в объекте "},{"attributes":{"code":true},"insert":"obj"},{"insert":".\nОднако, точка вызова "},{"attributes":{"italic":true},"insert":"использует"},{"insert":" контекст "},{"attributes":{"code":true},"insert":"obj"},{"insert":", чтобы ссылаться на функцию, поэтому "},{"attributes":{"italic":true},"insert":"можно"},{"insert":" сказать, что объект "},{"attributes":{"code":true},"insert":"obj"},{"insert":" \"владеет\" или \"содержит\" ссылку на функцию в момент вызова функции.\n"},{"attributes":{"italic":true,"bold":true},"insert":"Неявно потерянный"},{"insert":"\nОдним из самых распространенных недовольств, которые вызывает привязка "},{"attributes":{"code":true},"insert":"this"},{"insert":" — когда "},{"attributes":{"italic":true},"insert":"неявно привязанная"},{"insert":" функция теряет эту привязку, что обычно означает что она вернется к "},{"attributes":{"italic":true},"insert":"привязке по умолчанию"},{"insert":", либо объекта "},{"attributes":{"code":true},"insert":"global"},{"insert":", либо "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", в зависимости от режима "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":".\nПредставим такой код:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = obj.foo; // ссылка/алиас на функцию!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = \"ой, глобальная\"; // `a` также и свойство глобального объекта"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar(); // \"ой, глобальная\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Несмотря на то, что "},{"attributes":{"code":true},"insert":"bar"},{"insert":" по всей видимости ссылка на "},{"attributes":{"code":true},"insert":"obj.foo"},{"insert":", фактически, это на самом деле другая ссылка на саму "},{"attributes":{"code":true},"insert":"foo"},{"insert":". Более того, именно точка вызова тут имеет значение, а точкой вызова является "},{"attributes":{"code":true},"insert":"bar()"},{"insert":", который является прямым непривязанным вызовом, а следовательно применяется "},{"attributes":{"italic":true},"insert":"привязка по умолчанию"},{"insert":".\nБолее неочевидный, более распространенный и более неожиданный путь получить такую ситуацию когда мы предполагаем передать функцию обратного вызова:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function doFoo(fn) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// `fn` — просто еще одна ссылка на `foo`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfn(); // <-- точка вызова!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = \"ой, глобальная\"; // `a` еще и переменная в глобальном объекте"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"doFoo( obj.foo ); // \"ой, глобальная\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Передаваемый параметр — всего лишь неявное присваивание, а поскольку мы передаем функцию, это неявное присваивание ссылки, поэтому окончательный результат будет таким же как в предыдущем случае.\nЧто если функция, в которую вы передаете функцию обратного вызова, не ваша собственная, а встроенная в язык? Никакой разницы, такой же результат.\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = \"ой, глобальная\"; // `a` еще и переменная в глобальном объекте"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"setTimeout( obj.foo, 100 ); // \"ой, глобальная\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Поразмышляйте над этой грубой теоретической псевдо-реализацией "},{"attributes":{"code":true},"insert":"setTimeout()"},{"insert":", которая есть в качестве встроенной в JavaScript-среде:\nfunction setTimeout(fn,delay) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// подождать (так или иначе) `delay` миллисекунд"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfn(); // <-- точка вызова!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Явная привязка"},{"insert":"\nУ \"всех\" функций в языке есть несколько инструментов, доступных для них (через их "},{"attributes":{"code":true},"insert":"[[Прототип]]"},{"insert":", о котором подробности будут позже), которые могут оказаться полезными в решении этой задачи. Говоря конкретнее, у функций есть методы "},{"attributes":{"code":true},"insert":"call(..)"},{"insert":" и "},{"attributes":{"code":true},"insert":"apply(..)"},{"insert":" . Технически, управляющие среды JavaScript иногда обеспечивают функции, которые настолько специфичны, что у них нет такой функциональности. Но таких мало. Абсолютное большинство предоставляемых функций и конечно все функции, которые создаете вы сами, безусловно имеют доступ к "},{"attributes":{"code":true},"insert":"call(..)"},{"insert":" и "},{"attributes":{"code":true},"insert":"apply(..)"},{"insert":".\nЕсли в качестве привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":" вы передадите примитивное значение (типа "},{"attributes":{"code":true},"insert":"string"},{"insert":", "},{"attributes":{"code":true},"insert":"boolean"},{"insert":" или "},{"attributes":{"code":true},"insert":"number"},{"insert":"), то это примитивное значение будет обернуто в свою объектную форму ("},{"attributes":{"code":true},"insert":"new String(..)"},{"insert":", "},{"attributes":{"code":true},"insert":"new Boolean(..)"},{"insert":" или "},{"attributes":{"code":true},"insert":"new Number(..)"},{"insert":" соответственно). Часто это называют \"упаковка\".\n"},{"attributes":{"italic":true,"bold":true},"insert":"Жесткая привязка"},{"insert":"\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo.call( obj );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar(); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"setTimeout( bar, 100 ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// `bar` жестко привязывает `this` в `foo` к `obj`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// поэтому его нельзя перекрыть"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar.call( window ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Мы создаем функцию "},{"attributes":{"code":true},"insert":"bar()"},{"insert":", которая внутри вручную вызывает "},{"attributes":{"code":true},"insert":"foo.call(obj)"},{"insert":", таким образом принудительно вызывая "},{"attributes":{"code":true},"insert":"foo"},{"insert":" с привязкой "},{"attributes":{"code":true},"insert":"obj"},{"insert":" для "},{"attributes":{"code":true},"insert":"this"},{"insert":". Неважно как вы потом вызовете функцию "},{"attributes":{"code":true},"insert":"bar"},{"insert":", она всегда будет вручную вызывать "},{"attributes":{"code":true},"insert":"foo"},{"insert":" с "},{"attributes":{"code":true},"insert":"obj"},{"insert":". Такая привязка одновременно явная и сильная, поэтому мы называем ее "},{"attributes":{"italic":true},"insert":"жесткой привязкой"},{"insert":".\nСамый типичный способ обернуть функцию с "},{"attributes":{"italic":true},"insert":"жесткой привязкой"},{"insert":" — создать сквозную обертку, передающую все параметры и возвращающую полученное значение:\nfunction foo(something) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a, something );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.a + something;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn foo.apply( obj, arguments );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = bar( 3 ); // 2 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( b ); // 5"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Еще один способ выразить этот шаблон — создать переиспользуемую вспомогательную функцию:\nfunction foo(something) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a, something );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.a + something;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// простая вспомогательная функция `bind`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function bind(fn, obj) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\treturn fn.apply( obj, arguments );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = bind( foo, obj );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = bar( 3 ); // 2 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( b ); // 5"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Поскольку "},{"attributes":{"italic":true},"insert":"жесткая привязка"},{"insert":" — очень распространеный шаблон, он есть как встроенный инструмент в ES5: "},{"attributes":{"code":true},"insert":"Function.prototype.bind"},{"insert":", а используется вот так:\nfunction foo(something) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a, something );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.a + something;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = foo.bind( obj );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = bar( 3 ); // 2 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( b ); // 5"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"bind(..)"},{"insert":" возвращает новую функцию, в которой жестко задан вызов оригинальной функции с именно тем контекстом "},{"attributes":{"code":true},"insert":"this"},{"insert":", который вы указываете.\n"},{"attributes":{"bold":true},"insert":"Примечание: "},{"insert":"Начиная с ES6, в функции жесткой привязки, выдаваемой "},{"attributes":{"code":true},"insert":"bind(..)"},{"insert":", есть свойство "},{"attributes":{"code":true},"insert":".name"},{"insert":", наследуемое от исходной "},{"attributes":{"italic":true},"insert":"функции"},{"insert":". Например: у "},{"attributes":{"code":true},"insert":"bar = foo.bind(..)"},{"insert":" должно быть в "},{"attributes":{"code":true},"insert":"bar.name"},{"insert":" значение "},{"attributes":{"code":true},"insert":"\"bound foo\""},{"insert":", которое является названием вызова функции, которое должно отражаться в стеке вызовов.\n"},{"attributes":{"italic":true,"bold":true},"insert":"\"Контексты\" в вызовах API"},{"insert":"\nФункции многих библиотек, и разумеется многие встроенные в язык JavaScript и во внешнее окружение функции, предоставляют необязательный параметр, обычно называемый \"контекст\", который спроектирован как обходной вариант для вас, чтобы не пользоваться "},{"attributes":{"code":true},"insert":"bind(..)"},{"insert":", чтобы гарантировать, что ваша функция обратного вызова использует данный "},{"attributes":{"code":true},"insert":"this"},{"insert":".\nНапример:\nfunction foo(el) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( el, this.id );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tid: \"awesome\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// используем `obj` как `this` для вызовов `foo(..)`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"[1, 2, 3].forEach( foo, obj ); // 1 awesome  2 awesome  3 awesome"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Внутренне эти различные функции почти наверняка используют "},{"attributes":{"italic":true},"insert":"явную привязку"},{"insert":" через "},{"attributes":{"code":true},"insert":"call(..)"},{"insert":" или "},{"attributes":{"code":true},"insert":"apply(..)"},{"insert":", избавляя вас от хлопот.\n\n"},{"attributes":{"bold":true},"insert":"Привязка "},{"attributes":{"bold":true,"code":true},"insert":"new"},{"insert":"\nВ традиционных классо-ориентированных языках, \"конструкторы\" — это особые методы, связанные с классами, таким образом, что когда создается экземпляр класса с помощью операции "},{"attributes":{"code":true},"insert":"new"},{"insert":", вызывается конструктор этого класса. Обычно это выглядит как-то так:\nsomething = new MyClass(..);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В JavaScript есть операция "},{"attributes":{"code":true},"insert":"new"},{"insert":" и шаблон кода, который используется для этого, выглядит в основном идентично такой же операции в класс-ориентированных языках; многие разработчики полагают, что механизм JavaScript выполняет что-то похожее. Однако, на самом деле "},{"attributes":{"italic":true},"insert":"нет никакой связи"},{"insert":" с классо-ориентированной функциональностью у той, что предполагает использование "},{"attributes":{"code":true},"insert":"new"},{"insert":" в JS.\nВо-первых, давайте еще раз посмотрим что такое \"конструктор\" в JavaScript. В JS конструкторы — это всего лишь функции, которые, так уж получилось, были вызваны с операцией "},{"attributes":{"code":true},"insert":"new"},{"insert":" перед ними. Они ни связаны с классами, ни создают экземпляров классов. Они — даже не особые типы функций. Они — всего лишь обычные функции, которые, по своей сути, \"украдены\" операцией "},{"attributes":{"code":true},"insert":"new"},{"insert":" при их вызове.\nНапример, функция "},{"attributes":{"code":true},"insert":"Number(..)"},{"insert":" действует как конструктор, цитируя спецификацию ES5.1:\n15.7.2 Конструктор Number"},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"Когда Number вызывается как часть выражения new, оно является конструктором: оно инициализирует только что созданный объект."},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"Так что, практически любая старенькая функция, включая встроенные объектные функции, такие как "},{"attributes":{"code":true},"insert":"Number(..)"},{"insert":" (см. главу 3), могут вызываться с "},{"attributes":{"code":true},"insert":"new"},{"insert":" перед ними и это превратит такой вызов функции в "},{"attributes":{"italic":true},"insert":"вызов конструктора"},{"insert":". Это важное, но едва уловимое различие: нет такой вещи как \"функции-конструкторы\", а скорее есть вызовы, конструирующие "},{"attributes":{"italic":true},"insert":"из"},{"insert":" функций.\nКогда функция вызывается с указанием перед ней "},{"attributes":{"code":true},"insert":"new"},{"insert":", также известный как вызов конструктора, автоматически выполняются следующие вещи:\nСоздается новенький объект (т.е. конструируется) прямо из воздуха"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"italic":true},"insert":"Только что сконструированный объект связывается с "},{"attributes":{"italic":true,"code":true},"insert":"[[Прототипом]]"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Только что сконструированный объект устанавливается как привязка "},{"attributes":{"code":true},"insert":"this"},{"insert":" для этого вызова функции"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, вызов функции с "},{"attributes":{"code":true},"insert":"new"},{"insert":" "},{"attributes":{"italic":true},"insert":"автоматически"},{"insert":" вернет только что сконструированный объект."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Взглянем на такой код:\nfunction foo(a) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.a = a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = new foo( 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( bar.a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Вызывая "},{"attributes":{"code":true},"insert":"foo(..)"},{"insert":" с "},{"attributes":{"code":true},"insert":"new"},{"insert":" впереди нее, мы конструируем новый объект и устанавливаем этот новый объект как "},{"attributes":{"code":true},"insert":"this"},{"insert":" для вызова "},{"attributes":{"code":true},"insert":"foo(..)"},{"insert":". Таким образом "},{"attributes":{"code":true},"insert":"new"},{"insert":" — единственный путь, которым "},{"attributes":{"code":true},"insert":"this"},{"insert":" при вызове функции может быть привязан. Мы называем это "},{"attributes":{"italic":true},"insert":"привязкой new"},{"insert":".\n\nВсё по порядку"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"Всё"},{"insert":", что вам нужно сделать — это найти точку вызова и исследовать ее, чтобы понять какое правило применяется. Но что если к точке вызова можно применить несколько соответствующих правил? Должен быть порядок очередности применения этих правил.\n"},{"attributes":{"italic":true},"insert":"привязка по умолчанию"},{"insert":" имеет самый низкий приоритет из четырех. Поэтому мы отложим ее в сторону.\nЧто должно идти раньше: "},{"attributes":{"italic":true},"insert":"неявная привязка"},{"insert":" или "},{"attributes":{"italic":true},"insert":"явная привязка"},{"insert":"? Давайте проверим:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj1 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj2 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 3,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj1.foo(); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj2.foo(); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj1.foo.call( obj2 ); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj2.foo.call( obj1 ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Итак, "},{"attributes":{"italic":true},"insert":"явная привязка"},{"insert":" имеет приоритет над "},{"attributes":{"italic":true},"insert":"неявной привязкой."},{"insert":"\nТеперь, нам нужно всего лишь указать куда подходит по приоритету "},{"attributes":{"italic":true},"insert":"привязка new"},{"insert":".\nfunction foo(something) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.a = something;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj1 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj2 = {};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj1.foo( 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( obj1.a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj1.foo.call( obj2, 3 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( obj2.a ); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = new obj1.foo( 4 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( obj1.a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( bar.a ); // 4"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Хорошо, "},{"attributes":{"italic":true},"insert":"привязка new"},{"insert":" более приоритетна, чем "},{"attributes":{"italic":true},"insert":"неявная привязка"},{"insert":". \nПочему перекрытие операцией "},{"attributes":{"code":true},"insert":"new"},{"insert":" "},{"attributes":{"italic":true},"insert":"жесткой привязки"},{"insert":" может быть полезным?\nОсновная причина такого поведения — чтобы создать функцию (которую можно использовать вместе с "},{"attributes":{"code":true},"insert":"new"},{"insert":" для конструирования объектов), которая фактически игнорирует "},{"attributes":{"italic":true},"insert":"жесткую привязку"},{"insert":" "},{"attributes":{"code":true},"insert":"this"},{"insert":", но которая инициализирует некоторые или все аргументы функции. Одной из возможностей "},{"attributes":{"code":true},"insert":"bind(..)"},{"insert":" является умение сделать аргументы, переданные после после аргумента, привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":", стандартными аргументами по умолчанию для предшествующей функции (технически называемое \"частичным применением\", которое является подмножеством \"карринга\").\nПример:\nfunction foo(p1,p2) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.val = p1 + p2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// используем здесь `null`, т.к. нам нет дела до "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// жесткой привязки `this` в этом сценарии, и она "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// будет переопределена вызовом с операцией `new` в любом случае!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = foo.bind( null, \"p1\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var baz = new bar( \"p2\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"baz.val; // p1p2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Определяем "},{"attributes":{"bold":true,"code":true},"insert":"this"},{"insert":"\nТеперь можно кратко сформулировать правила для определения "},{"attributes":{"code":true},"insert":"this"},{"insert":" по точке вызова функции, в порядке их приоритет:\nФункция вызвана с "},{"attributes":{"code":true},"insert":"new"},{"insert":" ("},{"attributes":{"bold":true},"insert":"привязка new"},{"insert":")? Раз так, то "},{"attributes":{"code":true},"insert":"this"},{"insert":" — новый сконструированный объект."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"var bar = new foo()"},{"insert":"\nФункция вызвана с "},{"attributes":{"code":true},"insert":"call"},{"insert":" или "},{"attributes":{"code":true},"insert":"apply"},{"insert":" ("},{"attributes":{"bold":true},"insert":"явная привязка"},{"insert":"), даже скрыто внутри "},{"attributes":{"italic":true},"insert":"жесткой привязки"},{"insert":" в "},{"attributes":{"code":true},"insert":"bind"},{"insert":"? Раз так, "},{"attributes":{"code":true},"insert":"this"},{"insert":" — явно указанный объект."},{"attributes":{"list":{"type":"ordered","start":"1"}},"insert":"\n"},{"attributes":{"code":true},"insert":"var bar = foo.call( obj2 )"},{"insert":"\nФункция вызвана с контекстом ("},{"attributes":{"bold":true},"insert":"неявная привязка"},{"insert":"), иначе называемым как владеющий или содержащий объект? Раз так, "},{"attributes":{"code":true},"insert":"this"},{"insert":" является "},{"attributes":{"italic":true},"insert":"тем самым"},{"insert":" объектом контекста."},{"attributes":{"list":{"type":"ordered","start":"2"}},"insert":"\n"},{"attributes":{"code":true},"insert":"var bar = obj1.foo()"},{"insert":"\nВ противном случае, будет "},{"attributes":{"code":true},"insert":"this"},{"insert":" по умолчанию (привязка по умолчанию). В режиме "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":", это будет "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", иначе будет объект "},{"attributes":{"code":true},"insert":"global"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"3"}},"insert":"\n"},{"attributes":{"code":true},"insert":"var bar = foo()"},{"insert":"\n\nИсключения привязок"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Проигнорированный "},{"attributes":{"bold":true,"code":true},"insert":"this"},{"insert":"\nЕсли вы передаете "},{"attributes":{"code":true},"insert":"null"},{"insert":" или "},{"attributes":{"code":true},"insert":"undefined"},{"insert":" в качестве параметра привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":" в "},{"attributes":{"code":true},"insert":"call"},{"insert":", "},{"attributes":{"code":true},"insert":"apply"},{"insert":" или "},{"attributes":{"code":true},"insert":"bind"},{"insert":", то эти значения фактически игнорируются, а взамен к вызову применяется правило "},{"attributes":{"italic":true},"insert":"привязки по умолчанию"},{"insert":".\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.call( null ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Довольно распространено использовать "},{"attributes":{"code":true},"insert":"apply(..)"},{"insert":" для распаковки массива значений в качестве параметров вызова функции. Аналогично и "},{"attributes":{"code":true},"insert":"bind(..)"},{"insert":" может каррировать параметры (предварительно заданные значения), что может быть очень полезно.\nfunction foo(a,b) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"a:\" + a + \", b:\" + b );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// распакуем массив как параметры"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.apply( null, [2, 3] ); // a:2, b:3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// каррируем с помощью `bind(..)`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = foo.bind( null, 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar( 3 ); // a:2, b:3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Однако, есть некоторая скрытая \"опасность\" в том, чтобы всегда использовать "},{"attributes":{"code":true},"insert":"null"},{"insert":", когда вам не нужна привязка "},{"attributes":{"code":true},"insert":"this"},{"insert":". Если вы когда-нибудь воспользуетесь этим при вызове функции (например, функции сторонней библиотеки, которой вы не управляете) и эта функция "},{"attributes":{"italic":true},"insert":"все-таки"},{"insert":" воспользуется ссылкой на "},{"attributes":{"code":true},"insert":"this"},{"insert":", сработает правило "},{"attributes":{"italic":true},"insert":"привязки по умолчанию"},{"insert":", что повлечет за собой ненамеренно ссылку (или еще хуже, мутацию!) на объект "},{"attributes":{"code":true},"insert":"global"},{"insert":" ("},{"attributes":{"code":true},"insert":"window"},{"insert":" в браузере).\nОчевидно, что такая ловушка может привести к ряду "},{"attributes":{"italic":true},"insert":"очень трудно"},{"insert":" диагностируемых/отслеживаемых ошибок.\n"},{"attributes":{"italic":true,"bold":true},"insert":"Более безопасный "},{"attributes":{"italic":true,"bold":true,"code":true},"insert":"this"},{"insert":"\nПожалуй в некоторой степени \"более безопасная\" практика — передавать особым образом настроенный объект для "},{"attributes":{"code":true},"insert":"this"},{"insert":", который гарантирует отсутствие побочных эффектов в вашей программе. Заимствуя терминологию из сетевых (и военных) технологий, мы можем создать объект \"DMZ\" (демилитаризованной зоны (de-militarized zone)) — не более чем полностью пустой, неделегированный (см. главы 5 и 6) объект.\nПоскольку этот объект совершенно пустой, лично я люблю давать его переменной имя "},{"attributes":{"code":true},"insert":"ø"},{"insert":" (математический символ пустого множества в нижнем регистре). На многих клавиатурах (как например US-раскладка на Mac), этот символ легко можно ввести с помощью "},{"attributes":{"code":true},"insert":"⌥"},{"insert":"+"},{"attributes":{"code":true},"insert":"o"},{"insert":" (option+"},{"attributes":{"code":true},"insert":"o"},{"insert":"). В некоторых системах есть возможность назначать горячие клавиши на определенные символы. Если вам не нравится символ "},{"attributes":{"code":true},"insert":"ø"},{"insert":" или на вашей клавиатуре сложно набрать такой символ, вы конечно же можете назвать переменную как вам угодно.\nКак бы вы ни назвали ее, самый простой путь получить абсолютно пустой объект — это "},{"attributes":{"code":true},"insert":"Object.create(null)"},{"insert":" (см. главу 5). "},{"attributes":{"code":true},"insert":"Object.create(null)"},{"insert":" — похож на "},{"attributes":{"code":true},"insert":"{ }"},{"insert":", но без передачи "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":", поэтому он \"более пустой\", чем просто "},{"attributes":{"code":true},"insert":"{ }"},{"insert":".\nfunction foo(a,b) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"a:\" + a + \", b:\" + b );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// наш пустой DMZ-объект"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var ø = Object.create( null );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// распаковываем массив как параметры"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.apply( ø, [2, 3] ); // a:2, b:3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// каррируем с помощью `bind(..)`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = foo.bind( ø, 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar( 3 ); // a:2, b:3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Косвенность"},{"insert":"\nСамый распространенный путь появления "},{"attributes":{"italic":true},"insert":"косвенных ссылок"},{"insert":" — при присваивании:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var o = { a: 3, foo: foo };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var p = { a: 4 };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"o.foo(); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(p.foo = o.foo)(); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"Результатом"},{"insert":" выражения присваивания "},{"attributes":{"code":true},"insert":"p.foo = o.foo"},{"insert":" будет всего лишь ссылка на внутренний объект функции. В силу этого, настоящая точка вызова - это просто "},{"attributes":{"code":true},"insert":"foo()"},{"insert":", а не "},{"attributes":{"code":true},"insert":"p.foo()"},{"insert":" или "},{"attributes":{"code":true},"insert":"o.foo()"},{"insert":". Согласно вышеприведенным правилам будет применено правило "},{"attributes":{"italic":true},"insert":"привязки по умолчанию"},{"insert":".\nНапоминание: независимо от того как вы добрались до вызова функции используя правило "},{"attributes":{"italic":true},"insert":"привязки по умолчанию"},{"insert":", статус содержимого вызванной функции в режиме "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":", использующего ссылку на "},{"attributes":{"code":true},"insert":"this"},{"insert":", а не точка вызова функции, определяет значение "},{"attributes":{"italic":true},"insert":"привязки по умолчанию"},{"insert":": либо объект "},{"attributes":{"code":true},"insert":"global"},{"insert":" если не в "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":" или "},{"attributes":{"code":true},"insert":"undefined"},{"insert":" в "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":".\n\nЛексический this"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Вместо использования четырех стандартных "},{"attributes":{"code":true},"insert":"this"},{"insert":"-правил, стрелочные функции заимствуют привязку "},{"attributes":{"code":true},"insert":"this"},{"insert":" из окружающей (функции или глобальной) области видимости.\nПроиллюстрируем лексическую область видимости стрелочной функции:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// возвращаем стрелочную функцию"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn (a) => {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// Здесь `this` лексически заимствован из `foo()`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( this.a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj1 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj2 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = foo.call( obj1 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar.call( obj2 ); // 2, а не 3!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Поскольку в "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" "},{"attributes":{"code":true},"insert":"this"},{"insert":" был привязан к "},{"attributes":{"code":true},"insert":"obj1"},{"insert":", "},{"attributes":{"code":true},"insert":"bar"},{"insert":" (ссылка на возвращаемую стрелочную функцию) также будет с привязкой "},{"attributes":{"code":true},"insert":"this"},{"insert":" к "},{"attributes":{"code":true},"insert":"obj1"},{"insert":". Лексическая привязка стрелочной функции не может быть перекрыта (даже с помощью "},{"attributes":{"code":true},"insert":"new"},{"insert":"!).\n\n\nГлава 3: Объекты"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Синтаксис"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Объекты создаются двумя способами: декларативно (литерально) и с помощью конструктора.\n"},{"attributes":{"italic":true},"insert":"Литеральный"},{"insert":" синтаксис для объекта выглядит так:\nvar myObj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"key: value"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"Конструкторная"},{"insert":" форма выглядит так:\nvar myObj = new Object();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObj.key = value;"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"Конструкторная"},{"insert":" и "},{"attributes":{"italic":true},"insert":"литеральная"},{"insert":" формы в результате дают одинаковые объекты. Единственное отличие в том, что в литеральной форме вы можете добавлять сразу несколько пар ключ-значение, в то время как с конструктором вам нужно добавлять свойства по одному.\n\nТип"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"В JS есть шесть основных типов (в спецификации называются «языковые типы»):\n"},{"attributes":{"code":true},"insert":"string"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"number"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"boolean"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"null"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"undefined"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"object"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"Есть распространённое заблуждение, что «в JS всё является объектом». Это совсем не так. "},{"insert":"Обратите внимание, что "},{"attributes":{"italic":true},"insert":"простые примитивы"},{"insert":" сами по себе не являются объектами.\n"},{"attributes":{"code":true},"insert":"function"},{"insert":" - это подтип объекта (технически, «вызываемый объект»). Говорят, что функции в JS это объекты «первого класса» т.е. можно работать как с любым другим объектом.\nМассивы - это форма объекта с расширенным поведением.\n\n"},{"attributes":{"bold":true},"insert":"Встроенные Объекты"},{"insert":"\n"},{"attributes":{"code":true},"insert":"String"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Number"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Boolean"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Object"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Function"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Array"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Date"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"RegExp"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Error"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"В JS это встроенные функции. Каждая из этих встроенных функций может быть использована как конструктор, в результатом будет новый сконструированный объект указанного подтипа.\nvar strPrimitive = \"I am a string\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof strPrimitive;\t// \"string\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"strPrimitive instanceof String;\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var strObject = new String( \"I am a string\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"typeof strObject; // \"object\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"strObject instanceof String;\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// проверим подтип объекта"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.prototype.toString.call( strObject );\t// [object String]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Через "},{"attributes":{"code":true},"insert":"Object.prototype.toString..."},{"insert":" можем проверить внутренний подтип. Как видите, он показывает, что этот "},{"attributes":{"code":true},"insert":"strObject"},{"insert":" - на самом деле объект, созданный конструктором "},{"attributes":{"code":true},"insert":"String"},{"insert":".\nЗначение примитива "},{"attributes":{"italic":true},"insert":"«I am a string»"},{"insert":" это не объект, а литерал примитива и его значение иммутабельно. Чтобы выполнять над ним операции вроде проверки длины, доступа к содержимому символов и т. д. требуется объект "},{"attributes":{"code":true},"insert":"String"},{"insert":".\nК счастью, при необходимости язык автоматически приводит примитив "},{"attributes":{"code":true},"insert":"\"string\""},{"insert":" к объекту "},{"attributes":{"code":true},"insert":"String"},{"insert":", а значит вам почти никогда не придется дополнительно создавать форму Объекта. Большая часть сообщества JS настоятельно рекомендует по возможности использовать литеральную форму вместо конструкторной формы.\n"},{"attributes":{"code":true},"insert":"null"},{"insert":" и "},{"attributes":{"code":true},"insert":"undefined"},{"insert":" не имеют формы Объекта, только значения их примитивов. Для примера, значения "},{"attributes":{"code":true},"insert":"Date"},{"insert":" могут быть созданы "},{"attributes":{"italic":true},"insert":"только"},{"insert":" с помощью их конструкторной формы объекта, так как у них нет соответствующей литеральной формы.\n"},{"attributes":{"code":true},"insert":"Object"},{"insert":", "},{"attributes":{"code":true},"insert":"Array"},{"insert":", "},{"attributes":{"code":true},"insert":"Function"},{"insert":", и "},{"attributes":{"code":true},"insert":"RegExp"},{"insert":" (регулярные выражения) -- это объекты, не зависимо от того используется литеральная или конструкторная форма.\n\nСодержимое"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Содержимое не обязательно хранится прямо внутри объекта, это лишь абстракция. Движок хранит значения в зависимости от его реализации и может запросто не хранить их "},{"attributes":{"italic":true},"insert":"внутри"},{"insert":" какого-нибудь контейнера объекта. Что "},{"attributes":{"italic":true},"insert":"действительно"},{"insert":" хранится в контейнере, так это названия свойств, которые работают как указатели (технически, "},{"attributes":{"italic":true},"insert":"ссылаются"},{"insert":") туда, где хранятся значения.\nРассмотрим:\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;\t    // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject[\"a\"];\t// 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Чтобы получить значение по "},{"attributes":{"italic":true},"insert":"адресу"},{"insert":" "},{"attributes":{"code":true},"insert":"a"},{"insert":" в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" мы должны использовать либо оператор "},{"attributes":{"code":true},"insert":"."},{"insert":" либо оператор "},{"attributes":{"code":true},"insert":"[]"},{"insert":". Синтаксис "},{"attributes":{"code":true},"insert":".a"},{"insert":" обычно описывают как доступ к «свойству», а синтаксис "},{"attributes":{"code":true},"insert":"[\"a\"]"},{"insert":" называют доступ по «ключу». \n\n"},{"attributes":{"bold":true},"insert":"Вычисляемые имена свойств"},{"insert":"\nОписанный выше синтаксис доступа к свойствам вида "},{"attributes":{"code":true},"insert":"myObject[..]"},{"insert":" полезен когда необходимо использовать результат выражения "},{"attributes":{"italic":true},"insert":"в качестве"},{"insert":" ключа, вроде "},{"attributes":{"code":true},"insert":"myObject[prefix + name]"},{"insert":". Но это не сильно помогает при объявлении объектов через объектно-литеральный синтаксис.\nES6 добавляет "},{"attributes":{"italic":true},"insert":"вычисляемые имена свойств"},{"insert":", где можно указать выражение, обрамленное "},{"attributes":{"code":true},"insert":"[ ]"},{"insert":", в качестве пары ключ-значение при литеральном объявлении объекта:\nvar prefix = \"foo\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    [prefix + \"bar\"]: \"hello\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    [prefix + \"baz\"]: \"world\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject[\"foobar\"]; // hello"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject[\"foobaz\"]; // world"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Свойство против Метода"},{"insert":"\nКаждый раз, когда вы запрашиваете свойство объекта, это обращение к свойству, вне зависимости от типа значения, которое вы получаете. Если "},{"attributes":{"italic":true},"insert":"вдруг"},{"insert":" вы получите в результате обращения к этому свойству функцию, она не превратится волшебным образом в «метод». Нет ничего особенного в том, что функция выводится при обращении к свойству.\nНапример:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( \"foo\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var someFoo = foo;\t// переменная указывает на `foo`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    someFoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo;\t            // function foo(){..}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"someFoo;\t        // function foo(){..}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.someFoo;\t// function foo(){..}"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"someFoo"},{"insert":" и "},{"attributes":{"code":true},"insert":"myObject.someFoo"},{"insert":" это лишь две разных ссылки на одну функцию и ни одна из них не подразумевает, что функция является особенной или «принадлежит» какому-то другому объекту.\nВозможно, самым безопасным выводом будет такой: «функция» и «метод» взаимозаменяемы в JavaScript.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": ES6 добавляет указатель "},{"attributes":{"code":true},"insert":"super"},{"insert":", который обычно используется вместе с "},{"attributes":{"code":true},"insert":"class"},{"insert":" (см. Приложение А). То, как работает "},{"attributes":{"code":true},"insert":"super"},{"insert":" (статическая привязка вместо поздней привязки в виде "},{"attributes":{"code":true},"insert":"this"},{"insert":") прибавляет весомости идее, что функция, которую привязывает "},{"attributes":{"code":true},"insert":"super"},{"insert":" больше похожа на «метод», чем на «функцию». Но опять же, это лишь тонкие нюансы семантики (и механики).\n\n"},{"attributes":{"bold":true},"insert":"Массивы"},{"insert":"\nМассивы -- "},{"attributes":{"italic":true},"insert":"это"},{"insert":" объекты, поэтому даже если каждый индекс является положительным целым числом, вы можете "},{"attributes":{"italic":true},"insert":"также"},{"insert":" добавить свойства массива:\nvar myArray = [ \"foo\", 42, \"bar\" ];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myArray.baz = \"baz\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myArray.length;\t// 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myArray.baz;\t// \"baz\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обратите внимание, что добавление именованных свойств (не зависимо от синтаксиса "},{"attributes":{"code":true},"insert":"."},{"insert":" или "},{"attributes":{"code":true},"insert":"[ ]"},{"insert":") не влияет на выводимый результат свойства "},{"attributes":{"code":true},"insert":"length"},{"insert":".\nВы можете использовать массив как простой объект вида ключ/значение и не добавлять числовые индексы, но это плохая идея, поскольку у массивов есть особенное поведение и оптимизации, заточенные для их использования; то же самое и с обычными объектами. Используйте объекты для хранения пар ключ/значение и массивы для хранения значений с числовыми индексами.\n\n"},{"attributes":{"bold":true},"insert":"Дублирование Объектов"},{"insert":"\nВо-первых, мы должны решить будет это "},{"attributes":{"italic":true},"insert":"поверхностная"},{"insert":" или "},{"attributes":{"italic":true},"insert":"глубокая"},{"insert":" копия? Результатом "},{"attributes":{"italic":true},"insert":"поверхностного копирования"},{"insert":" в новом объекте будет свойство элементарного типа и ссылки на объекты. "},{"attributes":{"italic":true},"insert":"Глубокая копия"},{"insert":" продублирует так же и объекты. Здесь может возникнуть проблема бесконечного дублирования из-за зацикленности ссылок. Более того, не до конца ясно что будет означать "},{"attributes":{"italic":true},"insert":"дублирование"},{"insert":" функции.\nОдно из решений заключается в том, что объекты безопасные для JSON (то есть те, которые можно преобразовать в строку JSON и распарсить с теми же значениями и структурой) могут быть легко продублированы с помощью:\nvar newObj = JSON.parse( JSON.stringify( someObj ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В то же время, поверхностное копирование достаточно понятно и имеет меньше проблем, поэтому в ES6 для этой задачи есть "},{"attributes":{"code":true},"insert":"Object.assign(..)"},{"insert":". "},{"attributes":{"code":true},"insert":"Object.assign(..)"},{"insert":" принимает "},{"attributes":{"italic":true},"insert":"целевой"},{"insert":" объект в качестве первого параметра, а также один или более "},{"attributes":{"italic":true},"insert":"исходных"},{"insert":" объектов в качестве последующих параметров. Он проходит по всем "},{"attributes":{"italic":true},"insert":"перечисляемым"},{"insert":" (см. ниже), "},{"attributes":{"italic":true},"insert":"собственным ключам"},{"insert":" (существующим непосредственно) в "},{"attributes":{"italic":true},"insert":"исходном"},{"insert":" объекте(тах) и копирует их (только через присваивание "},{"attributes":{"code":true},"insert":"="},{"insert":") в "},{"attributes":{"italic":true},"insert":"целевой"},{"insert":" объект. Кроме того, удобно, что он возвращает "},{"attributes":{"italic":true},"insert":"целевой"},{"insert":" объект, как показано ниже:\nvar newObj = Object.assign({}, myObject);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"newObj.a;\t                    // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"newObj.b === anotherObject;\t    // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"newObj.c === anotherArray;\t    // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"newObj.d === anotherFunction;\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Дескрипторы свойств"},{"insert":"\nРассмотрим такой код:\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getOwnPropertyDescriptor( myObject, \"a\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// value: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// writable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// enumerable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// configurable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Как видно, "},{"attributes":{"bold":true},"insert":"дескриптор"},{"insert":" "},{"attributes":{"bold":true},"insert":"свойства"},{"insert":" (называемый «дескриптором данных» поскольку он хранит только значение данных) для нашего обычного свойства "},{"attributes":{"code":true},"insert":"a"},{"insert":" это больше чем просто его "},{"attributes":{"code":true},"insert":"value"},{"insert":", равное "},{"attributes":{"code":true},"insert":"2"},{"insert":".\nМы можем использовать "},{"attributes":{"code":true},"insert":"Object.defineProperty(..)"},{"insert":" для добавления нового или изменения существующего свойства (если оно является "},{"attributes":{"code":true},"insert":"configurable"},{"insert":"!) с желаемыми характеристиками.\nНапример:\nvar myObject = {};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, \"a\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"С помощью "},{"attributes":{"code":true},"insert":"defineProperty(..)"},{"insert":" мы вручную добавили простое, обычное свойство "},{"attributes":{"code":true},"insert":"a"},{"insert":" к объекту "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" в явном виде.\n"},{"attributes":{"bold":true},"insert":"Перезаписываемое"},{"insert":"\nВозможность изменить значение свойства контролируется характеристикой "},{"attributes":{"code":true},"insert":"writable"},{"insert":".\nРассмотрим:\nvar myObject = {};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, \"a\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: false, // не перезаписываемо!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;         // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Как видите, наша попытка модифицировать "},{"attributes":{"code":true},"insert":"value"},{"insert":" не удалась, молча. В строгом режиме "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":" мы получим ошибку:\n\"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = {};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, \"a\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: false, // не перезаписываемо!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a = 3;     // TypeError"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"TypeError"},{"insert":" говорит о том, что мы не можем изменить неперезаписываемое свойство.\n"},{"attributes":{"bold":true},"insert":"Конфигурируемое"},{"insert":"\nПока свойство является конфигурируемым, мы можем изменять описание дескриптора, используя всё тот же инструмент "},{"attributes":{"code":true},"insert":"defineProperty(..)"},{"insert":".\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;\t// 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, \"a\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 4,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: false,\t// не конфигурируемо!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;\t// 4"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a = 5;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;\t// 5"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, \"a\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 6,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );        // TypeError"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Последний вызов "},{"attributes":{"code":true},"insert":"defineProperty(..)"},{"insert":" приводит к ошибке TypeError, вне зависимости от "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":", если вы пытаетесь изменить значение дескриптора неконфигурируемого свойства. Осторожно: как видите, изменение "},{"attributes":{"code":true},"insert":"configurable"},{"insert":" на "},{"attributes":{"code":true},"insert":"false"},{"insert":" необратимо и его нельзя отменить.\n"},{"attributes":{"italic":true,"bold":true},"insert":"Примечание:"},{"insert":" существует особенное исключение, о котором стоит помнить: если для свойства уже задано "},{"attributes":{"code":true},"insert":"configurable:false"},{"insert":", то "},{"attributes":{"code":true},"insert":"writable"},{"insert":" может быть изменено с "},{"attributes":{"code":true},"insert":"true"},{"insert":" на "},{"attributes":{"code":true},"insert":"false"},{"insert":" без ошибки, но не обратно в "},{"attributes":{"code":true},"insert":"true"},{"insert":" если оно уже "},{"attributes":{"code":true},"insert":"false"},{"insert":".\nА еще "},{"attributes":{"code":true},"insert":"configurable:false"},{"insert":" препятствует возможности использовать оператор "},{"attributes":{"code":true},"insert":"delete"},{"insert":" для удаления существующего свойства.\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;     // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"delete myObject.a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;     // undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, \"a\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: false,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;     // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"delete myObject.a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a;     // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Как видите, последний вызов "},{"attributes":{"code":true},"insert":"delete"},{"insert":" не удался (молча), потому что мы сделали свойство "},{"attributes":{"code":true},"insert":"a"},{"insert":" неконфигурируемым.\n"},{"attributes":{"code":true},"insert":"delete"},{"insert":" используется только для удаления свойств объекта (которое может быть удалено) напрямую из указанного объекта. Если свойство объекта -- это последняя оставшаяся "},{"attributes":{"italic":true},"insert":"ссылка"},{"insert":" на некоторый объект/функцию и вы удаляете его, то ссылка удалится и теперь не имеющий ссылок объект/функция могут быть убраны сборщиком мусора.\nПеречисляемое\n "},{"attributes":{"code":true},"insert":"enumerable"},{"insert":" указывает, появится ли свойство в определенных перечислениях свойств объекта, таких как цикл "},{"attributes":{"code":true},"insert":"for..in"},{"insert":". Установите "},{"attributes":{"code":true},"insert":"false"},{"insert":", чтобы свойство не появлялось в подобных перечислениях, даже если оно по-прежнему полностью доступно. Установите "},{"attributes":{"code":true},"insert":"true"},{"insert":", чтобы оно присутствовало.\nВсе нормальные свойства, заданные пользователем, по умолчанию являются "},{"attributes":{"code":true},"insert":"enumerable"},{"insert":".\n\n"},{"attributes":{"bold":true},"insert":"Иммутабельность"},{"insert":"\nВажно отметить, что всё это -- попытки создать неглубокую иммутабельность. Они влияют только на объект и характеристики его непосредственных свойств. Если объект содержит указатель на другой объект (массив, объект, функцию и т.д.), то "},{"attributes":{"italic":true},"insert":"содержимое"},{"insert":" другого объекта не будет затронуто и останется изменяемым.\n"},{"attributes":{"bold":true},"insert":"Константа объекта"},{"insert":"\nКомбинируя "},{"attributes":{"code":true},"insert":"writable:false"},{"insert":" и "},{"attributes":{"code":true},"insert":"configurable:false"},{"insert":" вы по сути можете создать "},{"attributes":{"italic":true},"insert":"константу"},{"insert":" (не может быть изменена, переопределенна или удалена) в качестве свойства объекта, вроде:\nvar myObject = {};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty(myObject, \"FAVORITE_NUMBER\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: 42,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: false,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"});"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Запрет расширения"},{"insert":"\nЕсли вы хотите запретить добавление новых свойств объекта, но в то же время оставить существующие свойства нетронутыми, используйте "},{"attributes":{"code":true},"insert":"Object.preventExtensions(..)"},{"insert":"\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.preventExtensions( myObject );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.b = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.b; // undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В "},{"attributes":{"code":true},"insert":"нестрогом режиме"},{"insert":", создание "},{"attributes":{"code":true},"insert":"b"},{"insert":" завершится неудачей без ошибок. В "},{"attributes":{"code":true},"insert":"строгом режиме"},{"insert":" это приведет к ошибке "},{"attributes":{"code":true},"insert":"TypeError"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Запечатывание"},{"insert":"\nМетод "},{"attributes":{"code":true},"insert":"Object.seal(..)"},{"insert":" создает «запечатанный» объект -- то есть принимает существующий объект и по сути применяет к нему "},{"attributes":{"code":true},"insert":"Object.preventExtensions(..)"},{"insert":", но также помечает все существующие свойства как "},{"attributes":{"code":true},"insert":"configurable:false"},{"insert":".\nТаким образом, вы не можете не только добавлять свойства, но и переконфигурировать или удалить существующие (хотя вы всё еще "},{"attributes":{"italic":true},"insert":"можете"},{"insert":" изменять их значения).\n"},{"attributes":{"bold":true},"insert":"Заморозка"},{"insert":"\nМетод "},{"attributes":{"code":true},"insert":"Object.freeze(..)"},{"insert":" создает замороженный объект, что означает, что он принимает существующий объект и по сути применяет к нему "},{"attributes":{"code":true},"insert":"Object.seal(..)"},{"insert":", но также помечает все свойства «доступа к данным» как "},{"attributes":{"code":true},"insert":"writable:false"},{"insert":", так, что их значения не могут быть изменены.\nЭтот подход дает наивысший уровень иммутабельности, который вы можете получить для самого объекта, поскольку он предотвращает любые изменения в объекте или его непосредственных свойствах, хотя содержимое любых других привязанных объектов не затрагивается.\nВы можете «глубоко заморозить» объект, применив "},{"attributes":{"code":true},"insert":"Object.freeze(..)"},{"insert":" к объекту и рекурсивно перебрать все объекты, на которые он ссылается (которые еще не были затронуты) применив к ним "},{"attributes":{"code":true},"insert":"Object.freeze(..)"},{"insert":". Однако, будьте осторожны, поскольку это может затронуть другие (общие) объекты, которые вы не планировали менять.\n\n[[Get]]"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"var myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"myObject.a"},{"insert":" - это запрос свойства, но он не "},{"attributes":{"italic":true},"insert":"просто"},{"insert":" ищет в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" свойство с именем "},{"attributes":{"code":true},"insert":"a"},{"insert":". Согласно спецификации, код выше выполняет операцию "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" (что-то вроде вызова функции "},{"attributes":{"code":true},"insert":"[[Get]]()"},{"insert":") с объектом "},{"attributes":{"code":true},"insert":"myObject"},{"insert":". Стандартная встроенная операция "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" проверяет объект на наличие запрашиваемого свойства и если находит его, то возвращает соответствующее значение.\nОднако, в алгоритме "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" описано важное поведение для случая, когда она "},{"attributes":{"italic":true},"insert":"не"},{"insert":" находит запрошенное свойство - обход по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":".\nНо один из важных результатов операции "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" заключается в том, что если она по какой-либо причине не может найти значение запрошенного свойства, то вернёт значение "},{"attributes":{"code":true},"insert":"undefined"},{"insert":".\nЭто поведение отличается от случая, когда вы обращаетесь к "},{"attributes":{"italic":true},"insert":"переменным"},{"insert":" по имени их идентификатора. Если вы запросите переменную, которая не может быть найдена с помощью поиска по лексической области видимости, то результатом будет не "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", как у свойств объекта, а ошибка "},{"attributes":{"code":true},"insert":"ReferenceError"},{"insert":".\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.b; // undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"С точки зрения "},{"attributes":{"italic":true},"insert":"значения"},{"insert":", нет разницы между этими двумя вызовами -- они оба выдадут "},{"attributes":{"code":true},"insert":"undefined"},{"insert":". Однако, внутри операции "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":", хоть это и не заметно на первый взгляд, потенциально выполняется немного больше «работы» для вывода "},{"attributes":{"code":true},"insert":"myObject.b"},{"insert":", чем для вывода "},{"attributes":{"code":true},"insert":"myObject.a"},{"insert":".\nПроверяя лишь результаты вывода значения, вы не можете отличить когда существует свойство, явно содержащее значение "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", а когда свойство "},{"attributes":{"italic":true},"insert":"не"},{"insert":" существует и "},{"attributes":{"code":true},"insert":"undefined"},{"insert":".\n\n[[Put]]"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Поскольку существует встроенная операция "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" для получения значения свойства, очевидно, должна существовать и стандартная операция "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":".\nПоведение "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" при вызове зависит от нескольких факторов, включая (наиболее значимый): существует ли такое свойство у объекта или нет.\nЕсли свойство существует, то алгоритм "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" проверит примерно следующее:\nЯвляется ли свойство дескриптором доступа (смотрите раздел «Геттеры и Сеттеры» ниже)? "},{"attributes":{"bold":true},"insert":"Если да, то вызовет сеттер, если он есть."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Является ли свойство дескриптором данных с ключом "},{"attributes":{"code":true},"insert":"writable"},{"insert":" равным "},{"attributes":{"code":true},"insert":"false"},{"insert":"? "},{"attributes":{"bold":true},"insert":"Если да, то тихо завершится в нестрогом режиме ["},{"attributes":{"bold":true,"code":true},"insert":"non-strict mode"},{"attributes":{"bold":true},"insert":"], или выдаст ошибку "},{"attributes":{"bold":true,"code":true},"insert":"TypeError"},{"attributes":{"bold":true},"insert":" в строгом режиме ["},{"attributes":{"bold":true,"code":true},"insert":"strict mode"},{"attributes":{"bold":true},"insert":"]."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Иначе, установит значение существующего свойства как обычно."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Если свойство запрашиваемого объекта еще не задано, то операция "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" еще более сложная и запутанная (вернемся к этому сценарию в Главе 5, когда обсудим "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":").\n\nГеттеры и Сеттеры"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Стандартные операции объектов "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" и "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" полностью контролируют как значения задаются для существующих или новых свойств и, соответственно, запрашиваются из существующих свойств.\nES5 представил способ переопределения части этих стандартных операций не на уровне объекта, а на уровне свойств, через использование геттеров и сеттеров. Геттеры - это свойства, которые на самом деле вызывают скрытую функцию для получения значения. Сеттеры - это свойства, которые на самом деле вызывают скрытую функцию для задания значения.\nКогда вы задаете свойству геттер или сеттер, оно определяется как «дескриптор доступа» (в противовес «дескриптору данных»). Для дескрипторов доступа, характеристики дескриптора "},{"attributes":{"code":true},"insert":"value"},{"insert":" и "},{"attributes":{"code":true},"insert":"writable"},{"insert":" игнорируются, а вместо этого JS рассматривает характеристики свойства "},{"attributes":{"code":true},"insert":"set"},{"insert":" и "},{"attributes":{"code":true},"insert":"get"},{"insert":" (а также "},{"attributes":{"code":true},"insert":"configurable"},{"insert":" и "},{"attributes":{"code":true},"insert":"enumerable"},{"insert":").\nРассмотрим:\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // определяем геттер для `a`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    get a() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        return 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    myObject,\t// цель"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    \"b\",\t    // имя свойства"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    {\t// дескриптор"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        // определяем геттер для `b`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        get: function(){ return this.a * 2 },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        // убедимся что `b` будет отображаться как свойство объекта"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        enumerable: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.b; // 4"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Как в объектно-литеральном синтаксисе с использованием "},{"attributes":{"code":true},"insert":"get a() { .. }"},{"insert":", так и с помощью явного определения через "},{"attributes":{"code":true},"insert":"defineProperty(..)"},{"insert":" мы создали свойство объекта, которое на самом деле не содержит значение, но доступ к которому приводит к вызову функции-геттера, чьё возвращаемое значение и будет результатом обращения к свойству.\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // определяем геттер для `a`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    get a() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        return 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Поскольку мы определили геттер для "},{"attributes":{"code":true},"insert":"a"},{"insert":", то если мы попытаемся установить значение "},{"attributes":{"code":true},"insert":"a"},{"insert":", операция не выдаст ошибки, а молча отбросит присваивание. Даже если бы тут был валидный сеттер, в нашем геттере жестко прописано вернуть только "},{"attributes":{"code":true},"insert":"2"},{"insert":", так что операция присваивания будет спорной.\nЧтобы сделать этот сценарий более разумным, свойства должны быть заданы с помощью сеттеров, которые переопределяют стандартную операцию "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" (известную как присваивание) для каждого свойства, как вы того и ожидали:\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // определим геттер для `a`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    get a() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        return this._a_;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    },"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // определим сеттер для `a`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    set a(val) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        this._a_ = val * 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 4"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Имя "},{"attributes":{"code":true},"insert":"_a_"},{"insert":" здесь чисто для примера и не означает никакого особенного поведения - это обычное свойство, как и любое другое.\n\nСуществование"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Мы можем спросить есть ли у объекта свойство, не запрашивая значение свойства:\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(\"a\" in myObject);\t            // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(\"b\" in myObject);\t            // false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.hasOwnProperty( \"a\" );\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.hasOwnProperty( \"b\" );\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Оператор "},{"attributes":{"code":true},"insert":"in"},{"insert":" проверит находится ли свойство "},{"attributes":{"code":true},"insert":"в"},{"insert":" объекте или существует ли оно уровнем выше в цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта (смотрите Главу 5). "},{"attributes":{"code":true},"insert":"hasOwnProperty(..)"},{"insert":" наоборот проверяет есть ли свойство "},{"attributes":{"italic":true},"insert":"только"},{"insert":" у объекта "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" или нет и "},{"attributes":{"italic":true},"insert":"не"},{"insert":" опрашивает цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":".\nМетод "},{"attributes":{"code":true},"insert":"hasOwnProperty(..)"},{"insert":" доступен для всех нормальных объектов через делегирование "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":" (см. Главу 5). Но можно создать объект, который не привязан к "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":" (с помощью"},{"attributes":{"code":true},"insert":"Object.create(null)"},{"insert":" -- см. Главу 5). В этом случае, вызвать метод "},{"attributes":{"code":true},"insert":"myObject.hasOwnProperty(..)"},{"insert":" не получится.\nПри таком сценарии более надежным способом выполнить подобную проверку будет "},{"attributes":{"code":true},"insert":"Object.prototype.hasOwnProperty.call(myObject,\"a\")"},{"insert":", который заимствует базовый метод "},{"attributes":{"code":true},"insert":"hasOwnProperty"},{"insert":" и использует "},{"attributes":{"italic":true},"insert":"явную привязку "},{"attributes":{"italic":true,"code":true},"insert":"this"},{"insert":" (см. Главу 2), чтобы применить его к нашему "},{"attributes":{"code":true},"insert":"myObject"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Оператор "},{"attributes":{"code":true},"insert":"in"},{"insert":" выглядит так, будто он проверяет существование "},{"attributes":{"italic":true},"insert":"значения"},{"insert":" внутри контейнера, но на самом деле он проверяет существование имени свойства. Это отличие важно учитывать применительно к массивам, поскольку велик соблазн сделать проверку вроде "},{"attributes":{"code":true},"insert":"4 in [2, 4, 6]"},{"insert":", но она не будет вести себя так, как вы ожидали.\n\n"},{"attributes":{"bold":true},"insert":"Перечисление"},{"insert":"\nРанее мы кратко объяснили идею «перечисляемости», когда рассматривали "},{"attributes":{"code":true},"insert":"enumerable"},{"insert":" -- характеристику дескриптора свойства. Давайте вернемся и рассмотрим её более подробно.\nvar myObject = { };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    myObject,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    \"a\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // сделаем `a` перечисляемой, как обычно"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    { enumerable: true, value: 2 }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    \"b\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // сделаем `b` НЕперечисляемой"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    { enumerable: false, value: 3 }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.b;                     // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(\"b\" in myObject);              // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.hasOwnProperty( \"b\" ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// ......."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (var k in myObject) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( k, myObject[k] );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// \"a\" 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Вы заметите, что "},{"attributes":{"code":true},"insert":"myObject.b"},{"insert":" по факту существует и имеет доступное значение, но оно не отображается в цикле "},{"attributes":{"code":true},"insert":"for..in"},{"insert":" (хотя, внезапно, оно "},{"attributes":{"italic":true},"insert":"обнаружилось"},{"insert":" проверкой на существование оператором "},{"attributes":{"code":true},"insert":"in"},{"insert":"). Всё потому, что по сути «перечислимое» означает «будет учтено, если пройти перебором по свойствам объекта»).\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Использование циклов "},{"attributes":{"code":true},"insert":"for..in"},{"insert":" с массивами может выдать неожиданный результат, поскольку перечисление массива будет включать не только все численные индексы, но также перечисляемые свойства. Хорошая идея использовать циклы "},{"attributes":{"code":true},"insert":"for..in"},{"insert":" "},{"attributes":{"italic":true},"insert":"только"},{"insert":" с объектами, а традиционные циклы "},{"attributes":{"code":true},"insert":"for"},{"insert":" для перебора по численным индексам значений, хранящихся в массивах.\nЕще один способ определить перечисляемые и неперечисляемые свойства:\nvar myObject = { };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    Object.defineProperty("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    myObject,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    \"a\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // сделаем `a` перечисляемым, как обычно"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    { enumerable: true, value: 2 }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    myObject,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    \"b\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // сделаем `b` неперечисляемым"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    { enumerable: false, value: 3 }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.propertyIsEnumerable( \"a\" );   // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.propertyIsEnumerable( \"b\" );   // false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.keys( myObject );                // [\"a\"]"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getOwnPropertyNames( myObject ); // [\"a\", \"b\"]"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"propertyIsEnumerable(..)"},{"insert":" проверяет существует ли данное имя свойства "},{"attributes":{"italic":true},"insert":"непосредственно"},{"insert":" в объекте и установлено ли "},{"attributes":{"code":true},"insert":"enumerable:true"},{"insert":".\n"},{"attributes":{"code":true},"insert":"Object.keys(..)"},{"insert":" возвращает массив всех перечисляемых свойств, в то время как "},{"attributes":{"code":true},"insert":"Object.getOwnPropertyNames(..)"},{"insert":" возвращает массив "},{"attributes":{"italic":true},"insert":"всех"},{"insert":" свойств -- перечисляемых или нет.\nОтличия "},{"attributes":{"code":true},"insert":"in"},{"insert":" от "},{"attributes":{"code":true},"insert":"hasOwnProperty(..)"},{"insert":" в том, опрашивают ли они цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" или нет. В то время как "},{"attributes":{"code":true},"insert":"Object.keys(..)"},{"insert":" и "},{"attributes":{"code":true},"insert":"Object.getOwnPropertyNames(..)"},{"insert":" проверяют "},{"attributes":{"italic":true},"insert":"только"},{"insert":" конкретный указанный объект.\nНе существует (пока) встроенного способа получить список всех свойств, эквивалентного тому, как опрашивает оператор "},{"attributes":{"code":true},"insert":"in"},{"insert":" (перебирая все свойства по всей цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", как описано в Главе 5). Приблизительно, такой инструмент можно сделать, если рекурсивно перебирать цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта и на каждом уровне выбирать список из "},{"attributes":{"code":true},"insert":"Object.keys(..)"},{"insert":" - только перечисляемых свойств.\n\nИтерация"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Цикл "},{"attributes":{"code":true},"insert":"for..in"},{"insert":" проходит по списку перечисляемых свойств объекта (включая его цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":"). \nВ массивах с числовыми индексами перебор значений обычно выполняется стандартным циклом "},{"attributes":{"code":true},"insert":"for"},{"insert":", вроде:\nvar myArray = [1, 2, 3];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (var i = 0; i < myArray.length; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( myArray[i] );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// 1 2 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Это не перебор значений, а перебор индексов, где вы используете индекс для получения значения, наподобие "},{"attributes":{"code":true},"insert":"myArray[i]"},{"insert":".\nES5 добавил несколько вспомогательных итераторов для массивов, включая "},{"attributes":{"code":true},"insert":"forEach(..)"},{"insert":", "},{"attributes":{"code":true},"insert":"every(..)"},{"insert":", и "},{"attributes":{"code":true},"insert":"some(..)"},{"insert":". Каждый из этих помощников принимает функцию обратного вызова для каждого элемента массива. Отличия только в том, как они реагируют на значение, возвращаемое этой функцией.\n"},{"attributes":{"code":true},"insert":"forEach(..)"},{"insert":" перебирает все значения массива и игнорирует любые значения, возвращаемые функцией обратного вызова. "},{"attributes":{"code":true},"insert":"every(..)"},{"insert":" продолжает перебор до конца "},{"attributes":{"italic":true},"insert":"или"},{"insert":" пока функция не вернёт "},{"attributes":{"code":true},"insert":"false"},{"insert":" (или «ложное» значение), в то время как "},{"attributes":{"code":true},"insert":"some(..)"},{"insert":" продолжает до конца "},{"attributes":{"italic":true},"insert":"или"},{"insert":" пока функция не вернёт значение "},{"attributes":{"code":true},"insert":"true"},{"insert":" (или «истинное» значение).\nЭти специальные возвращаемые значения внутри "},{"attributes":{"code":true},"insert":"every(..)"},{"insert":" и "},{"attributes":{"code":true},"insert":"some(..)"},{"insert":" действуют наподобие инструкции "},{"attributes":{"code":true},"insert":"break"},{"insert":" внутри обычного цикла, поскольку они прекращают перебор задолго до конца.\nЕсли вы перебираете объект циклом "},{"attributes":{"code":true},"insert":"for..in"},{"insert":", вы также лишь косвенно запрашиваете значения, поскольку он на самом деле перебирает только перечисляемые свойства объекта, заставляя вас обращаться к свойствам вручную для получения значений.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": В противовес перебору индексов массива в числовой последовательности (циклы "},{"attributes":{"code":true},"insert":"for"},{"insert":" или другие итераторы), порядок перебора свойств объекта "},{"attributes":{"italic":true},"insert":"не гарантирован"},{"insert":" и может различаться в разных движках JS. Не полагайтесь на любую наблюдаемую последовательность для всего, что требует постоянства окружения, поскольку любое наблюдаемое ненадежно.\nНо что если вместо индексов массива (или свойств объекта) вы хотите перебрать значения напрямую? К счастью, ES6 добавляет синтаксис цикла "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" для перебора массивов (и объектов, если объект определяет свой собственный итератор).\nvar myArray = [ 1, 2, 3 ];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (var v of myArray) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( v );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// 1"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Цикл "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" запрашивает объект-итератор (из стандартной встроенной функции, на языке спецификации известной как "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":") у перебираемой сущности, а затем перебирает возвращаемые значения, вызывая метод "},{"attributes":{"code":true},"insert":"next()"},{"insert":" объекта-итератора для каждой итерации цикла.\nМассивы имеют встроенный "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":", поэтому "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" легко работает с ними, как показано выше. Давайте переберем массив вручную, используя встроенный "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":", чтобы посмотреть как он работает:\nvar myArray = [ 1, 2, 3 ];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var it = myArray[Symbol.iterator]();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { value:1, done:false }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { value:2, done:false }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { value:3, done:false }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { done:true }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Примечание: В "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":" мы получаем "},{"attributes":{"italic":true},"insert":"внутреннее свойство"},{"insert":" объекта, используя "},{"attributes":{"code":true},"insert":"Symbol"},{"insert":" из ES6: "},{"attributes":{"code":true},"insert":"Symbol.iterator"},{"insert":". Мы уже упоминали семантику "},{"attributes":{"code":true},"insert":"Symbol"},{"insert":" ранее в этой главе (см. «Вычисляемые имена свойств»), поэтому здесь применяются те же рассуждения. Как правило, вы захотите обращаться к таким особенным свойствам через имя "},{"attributes":{"code":true},"insert":"Symbol"},{"insert":", а не через специальное значение, которое оно может содержать. Не смотря на подтекст в названии, "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":" является не объектом-итератором, а функцией, возвращающей объект-итератор -- маленькая, но важная деталь.\nКак показывает фрагмент выше, значение, которое возвращает вызов "},{"attributes":{"code":true},"insert":"next()"},{"insert":" итератора, -- это объект вида "},{"attributes":{"code":true},"insert":"{ value: .. , done: .. }"},{"insert":", где "},{"attributes":{"code":true},"insert":"value"},{"insert":" -- это значение текущей итерации, а "},{"attributes":{"code":true},"insert":"done"},{"insert":" -- это "},{"attributes":{"code":true},"insert":"boolean"},{"insert":", показывающее, остались ли элементы для перебора.\nОбратите внимание, что значение "},{"attributes":{"code":true},"insert":"3"},{"insert":" вернулось вместе с "},{"attributes":{"code":true},"insert":"done:false"},{"insert":", что на первый взгляд может показаться странным. Вам нужно вызвать "},{"attributes":{"code":true},"insert":"next()"},{"insert":" четвертый раз (что автоматически делает "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" из предыдущего фрагмента) чтобы получить "},{"attributes":{"code":true},"insert":"done:true"},{"insert":" и понять, что вы действительно закончили перебор. Причина такого костыля находится за рамками текущего обсуждения, но она исходит из семантики генерирующих функций стандарта ES6.\nВ то время как массивы автоматически перебираются циклами "},{"attributes":{"code":true},"insert":"for..of"},{"insert":", обычные объекты не имеют встроенного "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":". В общих чертах, правильным было решение не добавлять реализацию, которая будет проблемной для будущих типов объектов.\nДля перебора любого объекта "},{"attributes":{"italic":true},"insert":"можно"},{"insert":" определить свой собственный стандартный "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":". Например:\nvar myObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    a: 2,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    b: 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( myObject, Symbol.iterator, {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    enumerable: false,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    writable: false,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    configurable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    value: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        var o = this;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        var idx = 0;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        var ks = Object.keys( o );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        return {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            next: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                return {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                    value: o[ks[idx++]],"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                    done: (idx > ks.length)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// перебираем `myObject` вручную"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var it = myObject[Symbol.iterator]();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { value:2, done:false }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { value:3, done:false }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"it.next(); // { value:undefined, done:true }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// перебираем `myObject` с помощью `for..of`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (var v of myObject) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    console.log( v );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// 3"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Мы использовали "},{"attributes":{"code":true},"insert":"Object.defineProperty(..)"},{"insert":" чтобы задать свой "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":" (в основном для того, чтобы сделать его неперечисляемым), но, используя "},{"attributes":{"code":true},"insert":"Symbol"},{"insert":" как "},{"attributes":{"italic":true},"insert":"рассчитанное имя свойства"},{"insert":" (описанное ранее в этой главе), мы могли бы объявить его напрямую, вроде "},{"attributes":{"code":true},"insert":"var myObject = { a:2, b:3, [Symbol.iterator]: function(){ /* .. */ } }"},{"insert":".\nКаждый раз, когда цикл "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" вызовет "},{"attributes":{"code":true},"insert":"next()"},{"insert":" из итератора объекта "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", внутренний указатель переместится и вернёт следующее значение из списка свойств объекта (см. примечание о порядке перебора свойств/значений объекта).\nМы продемонстрировали простой перебор «значение за значением», но вы, конечно, можете задать перебор произвольной сложности для своих структур данных так, как вам будет удобней. Самодельные итераторы вкупе с циклом "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" из ES6 -- мощный инструмент для работы с объектами, определяемыми пользователем.\nНапример, для списка объектов "},{"attributes":{"code":true},"insert":"Pixel"},{"insert":" (со значениями координат "},{"attributes":{"code":true},"insert":"x"},{"insert":" и "},{"attributes":{"code":true},"insert":"y"},{"insert":") можно упорядочить перебор в зависимости от линейного расстояния до начала координат "},{"attributes":{"code":true},"insert":"(0,0)"},{"insert":" или отфильтровать точки, которые расположены «слишком далеко». Пока ваш итератор возвращает предполагаемое "},{"attributes":{"code":true},"insert":"{ value: .. }"},{"insert":", возвращает значения при вызове "},{"attributes":{"code":true},"insert":"next()"},{"insert":" и "},{"attributes":{"code":true},"insert":"{ done: true }"},{"insert":", когда перебор завершен, цикл "},{"attributes":{"code":true},"insert":"for..of"},{"insert":" стандарта ES6 сможет выполнить перебор.\nФактически, вы можете сгенерировать «бесконечные» итераторы, которые никогда не «завершатся» и всегда будут возвращать новое значение (вроде случайного числа, инкрементированного значения, уникального идентификатора и т.д.), хотя, скорее всего, вы не захотите использовать такие итераторы в неограниченном цикле "},{"attributes":{"code":true},"insert":"for..of"},{"insert":", поскольку он никогда не закончится и повесит вашу программу.\nvar randoms = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    [Symbol.iterator]: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        return {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            next: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"                return { value: Math.random() };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"            }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"        };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var randoms_pool = [];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (var n of randoms) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    randoms_pool.push( n );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // не продолжаем бесконечно!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    if (randoms_pool.length === 100) break;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот итератор будет генерировать случайные числа «вечно», поэтому мы позаботились о том, чтобы получить только 100 значений и наша программа не зависла.\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Обзор (TL;DR)"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Объекты в JS имеют литеральную форму (вроде "},{"attributes":{"code":true},"insert":"var a = { .. }"},{"insert":") и конструкторную форму (вроде "},{"attributes":{"code":true},"insert":"var a = new Array(..)"},{"insert":"). Литеральная форма почти всегда предпочтительнее, но конструкторная форма в некоторых случаях предлагает больше опций при создании.\nМногие ошибочно заявляют, что «в JS всё является объектом», но это некорректно. Объекты -- это один из 6 (или 7, в зависимости от ваших взглядов) примитивных типов. Существуют подтипы объектов, в том числе "},{"attributes":{"code":true},"insert":"function"},{"insert":", а также подтипы со специальным поведением, наподобие "},{"attributes":{"code":true},"insert":"[object Array]"},{"insert":", представляющего внутреннее обозначение такого подтипа объекта, как массив.\nОбъекты -- это коллекции ключ-значение. Значения могут быть получены через свойства, посредством синтаксиса "},{"attributes":{"code":true},"insert":".propName"},{"insert":" или "},{"attributes":{"code":true},"insert":"[\"propName\"]"},{"insert":". Вне зависимости от синтаксиса, движок вызывает встроенную стандартную операцию "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" (и "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" для установки значений), которая не только ищет свойство непосредственно в объекте, но и перемещается по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" (см. Главу 5), если свойство не найдено.\nУ свойств есть определенные характеристики, которыми можно управлять через дескрипторы свойств, такие как "},{"attributes":{"code":true},"insert":"writable"},{"insert":" и "},{"attributes":{"code":true},"insert":"configurable"},{"insert":". В дополнение, мутабельностью объектов (и их свойств) можно управлять на разных уровнях иммутабельности, используя "},{"attributes":{"code":true},"insert":"Object.preventExtensions(..)"},{"insert":", "},{"attributes":{"code":true},"insert":"Object.seal(..)"},{"insert":", и "},{"attributes":{"code":true},"insert":"Object.freeze(..)"},{"insert":".\nСвойства не обязательно содержат значения -- они могут быть также «свойствами доступа» с геттерами/сеттерами. Они могут быть "},{"attributes":{"italic":true},"insert":"перечисляемыми"},{"insert":" или нет, что влияет на их появление в итерациях цикла, например "},{"attributes":{"code":true},"insert":"for..in"},{"insert":".\nВы также можете перебирать значения структур данных (массивов, объектов и т.п.) используя синтаксис ES6 "},{"attributes":{"code":true},"insert":"for..of"},{"insert":", который ищет встроенный или самодельный объект "},{"attributes":{"code":true},"insert":"@@iterator"},{"insert":", содержащий метод "},{"attributes":{"code":true},"insert":"next()"},{"insert":" для перебора значений по одному.\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":{"blockDivider":true}},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Глава 4: Смешивая объекты \"классов\""},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nТеория классов"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\"Классовое наследование\" описывает определенный подход к архитектуре и организации кода.\nШаблон проектирования \"Класс\""},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Возможно, вы никогда не смотрели на классы как на \"шаблон проектирования\", так как чаще всего обсуждаются популярные \"OO шаблоны проектирования\", такие как \"итератор\", \"наблюдатель\", \"фабрика\", \"синглтон\" и т.д. При этом сразу предполагается, что OO классы являются механизмами более низкого уровня, с помощью которых мы реализуем все шаблоны проектирования.\nКонечно, если у вас есть опыт в \"функциональном программировании\" (монады и др.), вы хорошо знаете, что классы являются лишь одним из нескольких распространенных шаблонов проектирования. \nНекоторые языки (например, Java) не оставляют вам выбора, поэтому это вовсе не "},{"attributes":{"italic":true},"insert":"опционально"},{"insert":" - все это класс. Другие языки, такие как C/C++ или PHP, предоставляют вам как процедурные, так и классовые синтаксисы, и больше зависит от выбора разработчика, какой стиль или смесь стилей ему подойдет.\n\"Классы\" JavaScript"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"JS имеет "},{"attributes":{"italic":true},"insert":"некоторые"},{"insert":" синтаксические элементы, подобные классу (например, "},{"attributes":{"code":true},"insert":"new"},{"insert":" и "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":") довольно давно, а в последнее время в ES6 появились некоторые дополнения, такие как ключевое слово "},{"attributes":{"code":true},"insert":"class"},{"insert":".\nНо значит ли это, что в JavaScript действительно "},{"attributes":{"italic":true},"insert":"есть"},{"insert":" классы? Строго и однозначно: Нет.\nМеханика Классов"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Во многих классовых языках \"стандартная библиотека\" предоставляет \"стековую\" структуру данных (push, pop и др.) как класс "},{"attributes":{"code":true},"insert":"Stack"},{"insert":". Этот класс имеет внутренний набор переменных, которые хранят данные, и набор публичных методов, которые дают вашему коду возможность взаимодействовать со (скрытыми) данными (добавление и удаление данных и т. д.).\nНо в подобных языках вы на самом деле не работаете непосредственно со "},{"attributes":{"code":true},"insert":"Stack"},{"insert":" (если только речь не идет о Static члене класса, но это выходит за рамки нашего обсуждения). Класс "},{"attributes":{"code":true},"insert":"Stack"},{"insert":" - это просто абстрактное описание того, что должен делать "},{"attributes":{"italic":true},"insert":"любой"},{"insert":" \"стек\", но это не "},{"attributes":{"italic":true},"insert":"сам"},{"insert":" \"стек\". Вы должны создать экземпляр класса "},{"attributes":{"code":true},"insert":"Stack"},{"insert":", прежде чем у вас будет конкретная структура данных "},{"attributes":{"italic":true},"insert":"нечто"},{"insert":" для работы с ней.\n"},{"attributes":{"bold":true},"insert":"Строительство"},{"insert":"\nКласс - это план. Чтобы на самом деле "},{"attributes":{"italic":true},"insert":"получить"},{"insert":" объект, с которым мы можем взаимодействовать, мы должны построить (иначе, \"создать экземпляр\") что-то из класса. Конечным результатом такой «конструкции» является объект, обычно называемый «экземпляром», с помощью которого мы можем напрямую вызывать методы и обращаться к любым общедоступным свойствам данных при необходимости.\nЭтот объект является "},{"attributes":{"italic":true},"insert":"копией"},{"insert":" всех характеристик, описанных классом.\nКласс создается в форме объекта с помощью операции копирования.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/fig1.png"}}},{"insert":"\nКак видно, стрелки перемещаются слева направо и сверху вниз, что указывает на операции копирования, которые происходят как концептуально, так и физически.\n"},{"attributes":{"bold":true},"insert":"Конструктор"},{"insert":"\nЭкземпляры классов создаются специальным методом класса, обычно с тем же именем, что и класс, называемым "},{"attributes":{"italic":true},"insert":"конструктор"},{"insert":". Задача этого метода - инициализировать любую информацию (состояние), которая понадобится экземпляру.\nКонструктор класса "},{"attributes":{"italic":true},"insert":"принадлежит"},{"insert":" классу. Кроме того, конструкторы всегда нужно вызывать с помощью "},{"attributes":{"code":true},"insert":"new"},{"insert":", чтобы языковой движок знал, что вы хотите создать "},{"attributes":{"italic":true},"insert":"новый"},{"insert":" экземпляр класса.\nНаследование классов"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Полиморфизм"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Множественное наследование"},{"insert":"\nНекоторые ориентированные на классы языки позволяют указывать более одного «родительского» класса для «наследования». Множественное наследование означает, что каждое определение родительского класса копируется в дочерний класс.\nОднако, безусловно, возникают некоторые сложные вопросы. Если оба родительских класса предоставляют метод с именем "},{"attributes":{"code":true},"insert":"drive()"},{"insert":", на какую версию ссылается ссылка "},{"attributes":{"code":true},"insert":"drive()"},{"insert":" в дочернем элементе?\nЕсть еще один вариант, так называемая «проблема алмазов», которая относится к сценарию, где дочерний класс «D» наследует от двух родительских классов («B» и «C»), а каждый из них, в свою очередь, наследуется от общего класса «A». «A» предоставляет метод "},{"attributes":{"code":true},"insert":"drive()"},{"insert":", и оба класса \"B\" и \"C\" переопределяют (полиморфируют) этот метод. Когда "},{"attributes":{"code":true},"insert":"D"},{"insert":" ссылается на "},{"attributes":{"code":true},"insert":"drive()"},{"insert":", какую версию следует использовать ("},{"attributes":{"code":true},"insert":"B:drive()"},{"insert":" или "},{"attributes":{"code":true},"insert":"C:drive()"},{"insert":")?\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/fig2.png"}}},{"insert":"JavaScript проще: он не предоставляет нативный механизм «множественного наследования».\nMixins - Примеси"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Механизм объектов JavaScript не "},{"attributes":{"italic":true},"insert":"автоматически"},{"insert":" выполняет поведение копирования, когда вы «наследуете» или «создаете экземпляр». Проще говоря, в JavaScript нет «классов» для создания экземпляров, только объекты. И объекты не копируются в другие объекты, они "},{"attributes":{"italic":true},"insert":"связываются вместе"},{"insert":".\nПоскольку наблюдаемое поведение классов в других языках подразумевает наличие копий, давайте рассмотрим, как разработчики JS подделывают поведение копирования "},{"attributes":{"italic":true},"insert":"отсутствующего"},{"insert":" в JavaScript классах с помощью примесей(Mixins). Мы рассмотрим два типа «примесей»: явные и неявные.\n\n"},{"attributes":{"bold":true},"insert":"Явные примеси"},{"insert":"\nакая утилита часто называется "},{"attributes":{"code":true},"insert":"extend(..)"},{"insert":" многими библиотеками / фреймворками, но мы будем называть ее "},{"attributes":{"code":true},"insert":"mixin(..)"},{"insert":" здесь для наглядности.\n// значительно упрощенный пример `mixin(..)`:"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function mixin( sourceObj, targetObj ) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfor (var key in sourceObj) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// копируем только если его еще нет"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (!(key in targetObj)) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\ttargetObj[key] = sourceObj[key];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn targetObj;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Vehicle = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tengines: 1,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tignition: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Завожу двигатель.\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t},"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tdrive: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.ignition();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Двигаюсь вперёд!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Car = mixin( Vehicle, {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\twheels: 4,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tdrive: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tVehicle.drive.call( this );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Еду на всех моих \" + this.wheels + \" колёсах!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Важная деталь - мы больше не имеем дело с классами, потому что в JavaScript нет классов. «Транспортное средство» - "},{"attributes":{"code":true},"insert":"Vehicle"},{"insert":" и «Автомобиль» - "},{"attributes":{"code":true},"insert":"Car"},{"insert":" — это просто объекты, с которых мы делаем копии, соответственно.\n"},{"attributes":{"italic":true,"bold":true},"insert":"\"Полиморфизм\" вновь"},{"insert":"\nДавайте рассмотрим это утверждение: "},{"attributes":{"code":true},"insert":"Vehicle.drive.call(this)"},{"insert":". avaScript не имеет (до ES6; см. Приложение A) средства для относительного полиморфизма. Итак, потому что "},{"attributes":{"code":true},"insert":"Car"},{"insert":" и "},{"attributes":{"code":true},"insert":"Vehicle"},{"insert":" имеют функцию с одинаковым именем: "},{"attributes":{"code":true},"insert":"drive()"},{"insert":", чтобы различать вызов той или иной функции, мы должны сделать абсолютную (не относительную) ссылку. Мы явно указываем объект "},{"attributes":{"code":true},"insert":"Vehicle"},{"insert":" по имени и вызываем функцию "},{"attributes":{"code":true},"insert":"drive()"},{"insert":" для него.\nНо если бы мы сказали "},{"attributes":{"code":true},"insert":"Vehicle.drive()"},{"insert":", привязка "},{"attributes":{"code":true},"insert":"this"},{"insert":" для этого вызова функции была бы объектом "},{"attributes":{"code":true},"insert":"Vehicle"},{"insert":" вместо объекта "},{"attributes":{"code":true},"insert":"Car"},{"insert":", а это не то, что нам нужно.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Если идентификатор имени функции для "},{"attributes":{"code":true},"insert":"Car.drive()"},{"insert":" не перекрывался с "},{"attributes":{"code":true},"insert":"Vehicle.drive()"},{"insert":", мы бы не выполняли «метод полиморфизма». Таким образом, ссылка на "},{"attributes":{"code":true},"insert":"Vehicle.drive()"},{"insert":" была бы скопирована вызовом "},{"attributes":{"code":true},"insert":"mixin(..)"},{"insert":", и мы могли бы получить прямой доступ с помощью "},{"attributes":{"code":true},"insert":"this.drive()"},{"insert":". Выбранный идентификатор перекрывается "},{"attributes":{"bold":true},"insert":"затенением"},{"insert":", поэтому "},{"attributes":{"italic":true},"insert":"мы"},{"insert":" должны использовать более сложный "},{"attributes":{"italic":true},"insert":"явный подход псевдополиморфизма"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"По возможности следует избегать явного псевдополиморфизма"},{"insert":", потому что стоимость в большинстве случаев перевешивает выгоду.\n"},{"attributes":{"italic":true,"bold":true},"insert":"Смешивание копий"},{"insert":"\nЕсли мы сначала сделаем копии, прежде чем указывать содержимое "},{"attributes":{"code":true},"insert":"Car"},{"insert":", мы могли бы опустить эту проверку для "},{"attributes":{"code":true},"insert":"targetObj"},{"insert":", но это немного более неуклюже и менее эффективно, поэтому обычно это менее предпочтительно:\n// альтернативный миксин, менее \"безопасный\" для перезаписи"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function mixin( sourceObj, targetObj ) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfor (var key in sourceObj) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\ttargetObj[key] = sourceObj[key];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn targetObj;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Vehicle = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// сначала создаем пустой объект со"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// скопированными свойствами `Vehicle`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Car = mixin( Vehicle, { } );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// теперь копируем содержимое в Car"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"mixin( {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\twheels: 4,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tdrive: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}, Car );"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"italic":true,"bold":true},"insert":"Паразитическое наследование"},{"insert":"\nВариант этого явного паттерна подмешивания, который в некоторых отношениях явный, а в других неявный, называется «паразитическим наследованием», популяризируемый в основном Дугласом Крокфордом.\nВот как это может работать:\n// \"Традиционный JS класс\" `Vehicle`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Vehicle() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.engines = 1;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Vehicle.prototype.ignition = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"Завожу двигатель.\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Vehicle.prototype.drive = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.ignition();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"Двигаюсь вперёд!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// \"Паразитический класс\" `Car`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Car() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// во-первых, `car` это `Vehicle`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar car = new Vehicle();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// теперь, давайте модифицируем `car` чтобы придать ей специфичности"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcar.wheels = 4;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// сохранить привилегированную ссылку в `Vehicle::drive()`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar vehDrive = car.drive;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// переопределяем `Vehicle::drive()`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcar.drive = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tvehDrive.call( this );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Еду на всех моих \" + this.wheels + \" колёсах!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn car;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myCar = new Car();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myCar.drive();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Завожу двигатель."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Двигаюсь вперёд!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Еду на всех моих 4 колёсах!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Примечание: когда мы вызываем "},{"attributes":{"code":true},"insert":"new Car()"},{"insert":", создается новый объект и на него ссылается ссылка "},{"attributes":{"code":true},"insert":"this"},{"insert":". Но поскольку мы не используем этот объект и вместо этого возвращаем наш собственный объект "},{"attributes":{"code":true},"insert":"car"},{"insert":", первоначально созданный объект просто отбрасывается. Таким образом, "},{"attributes":{"code":true},"insert":"Car()"},{"insert":" может быть вызван без ключевого слова "},{"attributes":{"code":true},"insert":"new"},{"insert":", а приведенные выше функциональные возможности будут идентичны, но без ненужного создания объекта/сборки мусора.\n\n"},{"attributes":{"bold":true},"insert":"Неявные примеси"},{"insert":"\nНеявные примеси тесно связаны с "},{"attributes":{"italic":true},"insert":"явным псевдополиморфизмом"},{"insert":", как объяснено ранее.\nvar Something = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.greeting = \"Привет, мир\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tthis.count = this.count ? this.count + 1 : 1;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Something.cool();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Something.greeting; // \"Привет, мир\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Something.count; // 1"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var Another = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// неявное смешивание `Something` с `Another`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tSomething.cool.call( this );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Another.cool();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Another.greeting; // \"Привет, мир\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Another.count; // 1 (нет общего состояния с `Something`)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"С помощью "},{"attributes":{"code":true},"insert":"Something.cool.call(this)"},{"insert":", которое может происходить либо при вызове «конструктора» (наиболее часто), либо при вызове метода (показано здесь), мы, по сути, «заимствуем» функцию "},{"attributes":{"code":true},"insert":"Something.cool()"},{"insert":" и вызываем его в контексте "},{"attributes":{"code":true},"insert":"Another"},{"insert":" (через привязку "},{"attributes":{"code":true},"insert":"this"},{"insert":"; см. главу 2) вместо "},{"attributes":{"code":true},"insert":"Something"},{"insert":". Конечным результатом является то, что назначения, которые выполняет "},{"attributes":{"code":true},"insert":"Something.cool()"},{"insert":", применяются к объекту "},{"attributes":{"code":true},"insert":"Another"},{"insert":", а не к объекту "},{"attributes":{"code":true},"insert":"Something"},{"insert":".\nЭто хрупкий вызов "},{"attributes":{"code":true},"insert":"Something.cool.call(this)"},{"insert":", который нельзя превратить в относительную (и, следовательно, более гибкую) ссылку, с которой вам следует соблюдать осторожность. Как правило, "},{"attributes":{"bold":true},"insert":"по возможности избегайте таких конструкций"},{"insert":", чтобы сохранить более чистый и более понятный код.\nОбзор (TL; DR)"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Классы - это шаблон кодирования. Многие языки предоставляют синтаксис, который позволяет проектировать класс-ориентированное программное обеспечение. JS также имеет похожий синтаксис, но он ведет себя совсем иначе, чем вы ожидаете от классов из этих других языков.\nКлассы означают копии.\nКогда создаются традиционные классы, происходит копирование поведения от класса к экземпляру. Когда классы наследуются, также происходит копирование поведения от родителя к потомку.\nМожет показаться что полиморфизм (имеющий разные функции на нескольких уровнях цепочки наследования с одним и тем же именем) подразумевает относительную ссылку от дочернего элемента к родительскому, но это все еще просто результат поведения копирования.\nJavaScript автоматически не создает копии (как подразумевают классы) между объектами.\nШаблон примеси (как явный, так и неявный) часто используется для "},{"attributes":{"italic":true},"insert":"эмуляции"},{"insert":" поведения копирования классов, но это обычно приводит к уродливому и хрупкому синтаксису, например явному псевдополиморфизму ("},{"attributes":{"code":true},"insert":"OtherObj.methodName.call(this, ...)"},{"insert":"), что часто приводит к усложнению понимания и поддержки кода.\nЯвные примеси также не совсем совпадают с "},{"attributes":{"italic":true},"insert":"копированием"},{"insert":" классов, поскольку объекты (и функции!) дублируются только общими ссылками, а сами объекты/функции не дублируются. Не обратив внимания на такой нюанс вы получите источник множества недочетов.\nВ целом, фальшивые классы в JS часто устанавливают больше мин для будущего кодирования, вместо решения "},{"attributes":{"italic":true},"insert":"реальных"},{"insert":" проблем.\n\n"},{"insert":{"blockDivider":true}},{"insert":"\nГлава 5: Прототипы"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Объекты в JavaScript имеют внутреннее свойство, обозначенное в спецификации как "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", которое является всего лишь ссылкой на другой объект. Почти у всех объектов при создании это свойство получает не-"},{"attributes":{"code":true},"insert":"null"},{"insert":" значение.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Обсуждаемое нами стандартное поведение "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" и "},{"attributes":{"code":true},"insert":"[[Put]] "},{"insert":"неприменимо если используются "},{"attributes":{"code":true},"insert":"Proxy"},{"insert":".\nЕсли стандартная операция "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" не может найти запрашиваемое свойство в самом объекте, то она следует по ссылке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" этого объекта.\nvar anotherObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// создаем объект, привязанный к `anotherObject`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = Object.create( anotherObject );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот процесс продолжается до тех пор, пока либо не будет найдено свойство с совпадающим именем, либо не закончится цепочка "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":". Если по достижении конца цепочки искомое свойство "},{"attributes":{"italic":true},"insert":"так и не будет"},{"insert":" найдено, операция "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" вернет "},{"attributes":{"code":true},"insert":"undefined"},{"insert":".\nПо аналогии с этим процессом поиска по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", если вы используете цикл "},{"attributes":{"code":true},"insert":"for..in"},{"insert":" для итерации по объекту, будут перечислены все свойства, достижимые по его цепочке (при условии, что они перечислимые — см. "},{"attributes":{"code":true},"insert":"enumerable"},{"insert":" в главе 3). Если вы используете оператор "},{"attributes":{"code":true},"insert":"in"},{"insert":" для проверки существования свойства в объекте, то "},{"attributes":{"code":true},"insert":"in"},{"insert":" проверит всю цепочку объекта (независимо от "},{"attributes":{"italic":true},"insert":"перечисляемости"},{"insert":").\nvar anotherObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// создаем объект, привязанный к `anotherObject`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = Object.create( anotherObject );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"for (var k in myObject) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log(\"найдено: \" + k);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// найдено: a"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(\"a\" in myObject); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true,"code":true},"insert":"Object.prototype"},{"insert":"\nВ конце каждой "},{"attributes":{"italic":true},"insert":"типичной"},{"insert":" цепочки "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" находится встроенный объект "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":". Этот объект содержит различные утилиты, некоторые утилиты этого объекта: "},{"attributes":{"code":true},"insert":".toString()"},{"insert":" и "},{"attributes":{"code":true},"insert":".valueOf(), .hasOwnProperty(..),"},{"insert":" "},{"attributes":{"code":true},"insert":".isPrototypeOf(..)"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Установка и затенение свойств"},{"insert":"\nmyObject.foo = \"bar\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Если непосредственно у "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" есть обычное свойство доступа к данным с именем "},{"attributes":{"code":true},"insert":"foo"},{"insert":", то присваивание сводится к изменению значения существующего свойства.\nЕсли непосредственно у "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" нет "},{"attributes":{"code":true},"insert":"foo"},{"insert":", то выполняется обход цепочки "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" по аналогии с операцией "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":". Если "},{"attributes":{"code":true},"insert":"foo"},{"insert":" не будет найдено в цепочке, то свойство "},{"attributes":{"code":true},"insert":"foo"},{"insert":" добавляется непосредственно к "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" и получает указанное значение, как мы того и ожидаем.\nЕсли свойство с именем "},{"attributes":{"code":true},"insert":"foo"},{"insert":" присутствует как у самого "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", так и где-либо выше в цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", начинающейся с "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", то такая ситуация называется "},{"attributes":{"italic":true},"insert":"затенением"},{"insert":". Свойство "},{"attributes":{"code":true},"insert":"foo"},{"insert":" самого "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" "},{"attributes":{"italic":true},"insert":"затеняет"},{"insert":" любые свойства "},{"attributes":{"code":true},"insert":"foo"},{"insert":", расположенные выше по цепочке, потому что поиск "},{"attributes":{"code":true},"insert":"myObject.foo"},{"insert":" всегда находит свойство "},{"attributes":{"code":true},"insert":"foo"},{"insert":", ближайшее к началу цепочки.\nКак уже отмечалось, затенение "},{"attributes":{"code":true},"insert":"foo"},{"insert":" в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":" происходит не так просто, как может показаться. Мы рассмотрим три сценария присваивания "},{"attributes":{"code":true},"insert":"myObject.foo = \"bar\""},{"insert":", когда "},{"attributes":{"code":true},"insert":"foo"},{"insert":" "},{"attributes":{"bold":true},"insert":"не"},{"insert":" содержится непосредственно в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", а "},{"attributes":{"bold":true},"insert":"находится "},{"insert":"выше по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта "},{"attributes":{"code":true},"insert":"myObject"},{"insert":":\nЕсли обычное свойство доступа к данным (см. главу 3) с именем "},{"attributes":{"code":true},"insert":"foo "},{"insert":"находится где-либо выше по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", "},{"attributes":{"bold":true},"insert":"и не отмечено как только для чтения ("},{"attributes":{"bold":true,"code":true},"insert":"writable:false"},{"attributes":{"bold":true},"insert":")"},{"insert":", то новое свойство "},{"attributes":{"code":true},"insert":"foo"},{"insert":" добавляется непосредственно в объект "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", и происходит "},{"attributes":{"bold":true},"insert":"затенение свойства"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Если "},{"attributes":{"code":true},"insert":"foo"},{"insert":" находится выше по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", но отмечено как "},{"attributes":{"bold":true},"insert":"только для чтения ("},{"attributes":{"bold":true,"code":true},"insert":"writable:true"},{"attributes":{"bold":true},"insert":")"},{"insert":", то установка значения этого существующего свойства, равно как и создание затененного свойства у "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", "},{"attributes":{"bold":true},"insert":"запрещены"},{"insert":". Если код выполняется в "},{"attributes":{"code":true},"insert":"strict mode"},{"insert":", то будет выброшена ошибка, если нет, то попытка установить значение свойства будет проигнорирована. В любом случае, "},{"attributes":{"bold":true},"insert":"затенения не происходит"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Если "},{"attributes":{"code":true},"insert":"foo"},{"insert":" находится выше по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" и является сеттером (см. главу 3), то всегда будет вызываться сеттер. Свойство "},{"attributes":{"code":true},"insert":"foo"},{"insert":" не будет добавлено в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", сеттер "},{"attributes":{"code":true},"insert":"foo"},{"insert":" не будет переопределен."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Если вы хотите затенить "},{"attributes":{"code":true},"insert":"foo"},{"insert":" в случаях №2 и №3, то вместо присваивания "},{"attributes":{"code":true},"insert":"= "},{"insert":"нужно использовать "},{"attributes":{"code":true},"insert":"Object.defineProperty(..)"},{"insert":" (см. главу 3) чтобы добавить "},{"attributes":{"code":true},"insert":"foo"},{"insert":" в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Обычно затенение приносит больше проблем и сложностей, чем пользы, поэтому старайтесь избегать его если это возможно."},{"insert":"\nЗатенение может даже произойти неявно, поэтому если вы хотите его избежать, будьте бдительны. Например:\nvar anotherObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta: 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = Object.create( anotherObject );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"anotherObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"anotherObject.hasOwnProperty( \"a\" ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.hasOwnProperty( \"a\" ); // false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a++; // ой, неявное затенение!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"anotherObject.a; // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.a; // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.hasOwnProperty( \"a\" ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Хотя может показаться, что выражение "},{"attributes":{"code":true},"insert":"myObject.a++"},{"insert":" должно (через делегирование) найти и просто инкрементировать свойство "},{"attributes":{"code":true},"insert":"anotherObject.a"},{"insert":", вместо этого операция "},{"attributes":{"code":true},"insert":"++"},{"insert":" соответствует выражению "},{"attributes":{"code":true},"insert":"myObject.a = myObject.a + 1"},{"insert":". В результате "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" ищет свойство "},{"attributes":{"code":true},"insert":"a"},{"insert":" через "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" и получает текущее значение "},{"attributes":{"code":true},"insert":"2"},{"insert":" из "},{"attributes":{"code":true},"insert":"anotherObject.a"},{"insert":", далее это значение увеличивается на 1, после чего "},{"attributes":{"code":true},"insert":"[[Put]]"},{"insert":" присваивает значение "},{"attributes":{"code":true},"insert":"3"},{"insert":" новому затененному свойству "},{"attributes":{"code":true},"insert":"a"},{"insert":" в "},{"attributes":{"code":true},"insert":"myObject"},{"insert":".\nБудьте очень осторожны при работе с делегированными свойствами, пытаясь изменить их значение. Если вам нужно инкрементировать "},{"attributes":{"code":true},"insert":"anotherObject.a"},{"insert":", то вот единственно верный способ сделать это: "},{"attributes":{"code":true},"insert":"anotherObject.a++"},{"insert":".\n\n\"Класс\""},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"В JavaScript классы не могут описывать поведение объекта. Объект сам определяет собственное поведение. "},{"attributes":{"bold":true},"insert":"Есть "},{"attributes":{"italic":true,"bold":true},"insert":"только"},{"attributes":{"bold":true},"insert":" объект."},{"insert":"\n\n"},{"attributes":{"bold":true},"insert":"Функции \"классов\""},{"insert":"\nСпецифическое поведение \"как бы классов\" основано на одной странной особенности: у всех функций по умолчанию есть публичное, неперечислимое (см. главу 3) свойство, называемое "},{"attributes":{"code":true},"insert":"prototype"},{"insert":", которое указывает на некий объект.\nfunction Foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype; // { }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот объект часто называют \"прототипом Foo\". \nПроиллюстрируем на примере:\nfunction Foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.getPrototypeOf( a ) === Foo.prototype; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Когда "},{"attributes":{"code":true},"insert":"a"},{"insert":" создается путем вызова "},{"attributes":{"code":true},"insert":"new Foo()"},{"insert":", одним из результатов (все "},{"attributes":{"italic":true},"insert":"четыре"},{"insert":" шага см. в главе 2) будет создание в "},{"attributes":{"code":true},"insert":"a"},{"insert":" внутренней ссылки "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" на объект, на который указывает "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":".\nВ класс-ориентированных языках множественные "},{"attributes":{"bold":true},"insert":"копии"},{"insert":" (или \"экземпляры\") создаются как детали, штампуемые на пресс-форме. Но в JavaScript такого копирования не происходит. Вы можете создать множество объектов, "},{"attributes":{"italic":true},"insert":"связанных"},{"insert":"* ссылкой "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" с общим объектом. Но по умолчанию никакого копирования не происходит, поэтому эти объекты не становятся полностью автономными и не соединенными друг с другом, напротив, они весьма "},{"attributes":{"italic":true,"bold":true},"insert":"связаны"},{"insert":".\nНа самом деле секрет, о котором не догадывается большинство JS разработчиков, состоит в том, что вызов функции "},{"attributes":{"code":true},"insert":"new Foo()"},{"insert":" практически никак "},{"attributes":{"italic":true},"insert":"напрямую"},{"insert":" не связан с процессом создания ссылки. "},{"attributes":{"bold":true},"insert":"Это всегда было неким побочным эффектом"},{"insert":". "},{"attributes":{"code":true},"insert":"new Foo()"},{"insert":" — это косвенный, окольный путь к желаемому результату: "},{"attributes":{"bold":true},"insert":"новому объекту, связанному с другим объектом"},{"insert":".\n\n"},{"attributes":{"bold":true},"insert":"Что значит имя?"},{"insert":"\nВ JavaScript мы не делаем "},{"attributes":{"italic":true},"insert":"копии"},{"insert":" из одного объекта (\"класса\") в другой (\"экземпляр\"). Мы создаем "},{"attributes":{"italic":true},"insert":"ссылки"},{"insert":" между объектами. В механизме "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" визуально стрелки идут справа налево и снизу вверх.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/this%20%26%20object%20prototypes/fig3.png"}}},{"insert":"Этот механизм часто называют \"прототипным наследованием\". Термин \"наследование\" имеет очень четкий смысл (см. главу 4). Добавление перед ним слова \"прототипное\" чтобы обозначить "},{"attributes":{"italic":true},"insert":"на самом деле почти противоположное"},{"insert":" поведение привело к неразберихе в течение двух десятков лет.\n\"Наследование\" подразумевает операцию "},{"attributes":{"italic":true},"insert":"копирования"},{"insert":", а JavaScript не копирует свойства объекта (по умолчанию). Вместо этого JS создает ссылку между двумя объектами, в результате один объект по сути "},{"attributes":{"italic":true},"insert":"делегирует"},{"insert":" доступ к свойствам/функциям другому объекту. \"Делегирование\" (см. главу 6) — более точный термин для описания механизма связывания объектов в JavaScript.\n\n"},{"attributes":{"bold":true},"insert":"\"Конструкторы\""},{"insert":"\nУ объекта "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":" есть еще один фокус, который усиливает недоразумение, связанное с семантикой \"конструкторов\". Посмотрите на этот код:\nfunction Foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.constructor === Foo; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a.constructor === Foo; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"По умолчанию объект "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":" (во время объявления в первой строке примера!) получает публичное неперечислимое (см. главу 3) свойство "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", и это свойство является обратной ссылкой на функцию (в данном случае "},{"attributes":{"code":true},"insert":"Foo"},{"insert":"), с которой связан этот объект. Более того, мы видим, что объект "},{"attributes":{"code":true},"insert":"a"},{"insert":", созданный путем вызова \"конструктора\" "},{"attributes":{"code":true},"insert":"new Foo()"},{"insert":", похоже тоже имеет свойство с именем "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", также указывающее на \"функцию, создавшую его\".\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": На самом деле это неправда. У "},{"attributes":{"code":true},"insert":"a"},{"insert":" нет свойства "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", и хотя "},{"attributes":{"code":true},"insert":"a.constructor"},{"insert":" действительно разрешается в функцию "},{"attributes":{"code":true},"insert":"Foo"},{"insert":", \"конструктор\" "},{"attributes":{"bold":true},"insert":"на самом деле не значит"},{"insert":" \"был сконструирован этой функцией\". \n\n"},{"attributes":{"bold":true},"insert":"Конструктор или вызов?"},{"insert":"\nОднако когда вы добавляете ключевое слово "},{"attributes":{"code":true},"insert":"new"},{"insert":" перед обычным вызовом функции, это превращает вызов функции в \"вызов конструктора\". На самом деле "},{"attributes":{"code":true},"insert":"new"},{"insert":" как бы перехватывает любую обычную функцию и вызывает её так, что в результате создается объект, а также выполняется код самой функции.\nНапример:\nfunction NothingSpecial() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"Don''t mind me!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = new NothingSpecial();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// \"Don''t mind me!\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a; // {}"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"NothingSpecial"},{"insert":" — обычная функция, но когда она вызывается с "},{"attributes":{"code":true},"insert":"new"},{"insert":", то практически в качестве побочного эффекта "},{"attributes":{"italic":true},"insert":"создает"},{"insert":" объект, который мы присваиваем "},{"attributes":{"code":true},"insert":"a"},{"insert":". Этот вызов был "},{"attributes":{"italic":true},"insert":"вызовом конструктора"},{"insert":", но сама по себе функция "},{"attributes":{"code":true},"insert":"NothingSpecial"},{"insert":" не является "},{"attributes":{"italic":true},"insert":"конструктором"},{"insert":".\nИначе говоря, в JavaScript \"конструктор\" — это любая функция, вызванная с ключевым словом "},{"attributes":{"code":true},"insert":"new"},{"insert":" перед ней.\n\n"},{"attributes":{"bold":true},"insert":"Механика"},{"insert":"\nfunction Foo(name) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.name = name;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.myName = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.name;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = new Foo( \"a\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = new Foo( \"b\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a.myName(); // \"a\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b.myName(); // \"b\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот пример показывает два дополнительных трюка для \"класс-ориентированности\":\n"},{"attributes":{"code":true},"insert":"this.name = name"},{"insert":": свойство "},{"attributes":{"code":true},"insert":".name"},{"insert":" добавляется в каждый объект ("},{"attributes":{"code":true},"insert":"a"},{"insert":" и "},{"attributes":{"code":true},"insert":"b"},{"insert":", соответственно; см. главу 2 о привязке "},{"attributes":{"code":true},"insert":"this"},{"insert":"), аналогично тому как экземпляры классов инкапсулируют значения данных."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"Foo.prototype.myName = ..."},{"insert":": возможно более интересный прием, добавляет свойство (функцию) в объект "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":". Теперь работает "},{"attributes":{"code":true},"insert":"a.myName()"},{"insert":", но каким образом?"},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"В примере выше велик соблазн думать, что при создании "},{"attributes":{"code":true},"insert":"a"},{"insert":" и "},{"attributes":{"code":true},"insert":"b"},{"insert":" свойства/функции объекта "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":" "},{"attributes":{"italic":true},"insert":"копируются"},{"insert":" в каждый из объектов "},{"attributes":{"code":true},"insert":"a"},{"insert":" и "},{"attributes":{"code":true},"insert":"b"},{"insert":". "},{"attributes":{"bold":true},"insert":"Однако этого не происходит"},{"insert":".\nВ силу того, как создаются "},{"attributes":{"code":true},"insert":"a"},{"insert":" и "},{"attributes":{"code":true},"insert":"b"},{"insert":", оба объекта получают внутреннюю ссылку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" на "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":". Когда "},{"attributes":{"code":true},"insert":"myName"},{"insert":" не находится в "},{"attributes":{"code":true},"insert":"a"},{"insert":" или "},{"attributes":{"code":true},"insert":"b"},{"insert":" соответственно, она обнаруживается (через делегирование, см. главу 6) в "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"И снова о \"конструкторе\""},{"insert":"\n"},{"attributes":{"italic":true},"insert":"Кажется"},{"insert":", что "},{"attributes":{"code":true},"insert":"a.constructor === Foo"},{"insert":" означает, что в "},{"attributes":{"code":true},"insert":"a"},{"insert":" есть реальное свойство "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", указывающее на "},{"attributes":{"code":true},"insert":"Foo"},{"insert":", верно? Не верно.\nЭто всего лишь путаница. На самом деле ссылка "},{"attributes":{"code":true},"insert":".constructor"},{"insert":" также "},{"attributes":{"italic":true},"insert":"делегируется"},{"insert":" вверх по цепочке в "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":", у которого, так уж случилось, по умолчанию есть свойство "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", указывающее на "},{"attributes":{"code":true},"insert":"Foo"},{"insert":".\n"},{"attributes":{"italic":true},"insert":"Кажется"},{"insert":" ужасно удобным, что у объекта "},{"attributes":{"code":true},"insert":"a"},{"insert":", \"созданного\" "},{"attributes":{"code":true},"insert":"Foo"},{"insert":", будет доступ к свойству "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", которое указывает на "},{"attributes":{"code":true},"insert":"Foo"},{"insert":". Но это ложное чувство безопасности. Лишь по счастливой "},{"attributes":{"italic":true},"insert":"случайности"},{"insert":" "},{"attributes":{"code":true},"insert":"a.constructor"},{"insert":" указывает на "},{"attributes":{"code":true},"insert":"Foo"},{"insert":" через делегирование "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" по умолчанию. На самом деле есть несколько способов наломать дров, предполагая что "},{"attributes":{"code":true},"insert":".constructor"},{"insert":" означает \"использовался для создания\".\nРассмотрим:\nfunction Foo() { /* .. */ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype = { /* .. */ }; // создаем новый объект-прототип"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a1 = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1.constructor === Foo; // false!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a1.constructor === Object; // true!"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"Object(..)"},{"insert":" не был \"конструктором\" "},{"attributes":{"code":true},"insert":"a1"},{"insert":", не так ли? Выглядит так, будто \"конструктором\" объекта должна быть "},{"attributes":{"code":true},"insert":"Foo()"},{"insert":". Многие разработчики думают, что "},{"attributes":{"code":true},"insert":"Foo()"},{"insert":" создает объект, но эта идея трещит по швам, когда вы думаете что \"constructor\" значит \"был создан при помощи\". Ведь в таком случае "},{"attributes":{"code":true},"insert":"a1.constructor"},{"insert":" должен указывать на "},{"attributes":{"code":true},"insert":"Foo"},{"insert":", но это не так!\nЧто же происходит? У "},{"attributes":{"code":true},"insert":"a1"},{"insert":" нет свойства "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", поэтому он делегирует вверх по цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" к "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":". Но и у этого объекта нет "},{"attributes":{"code":true},"insert":".constructor"},{"insert":" (в отличие от стандартного объекта "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":"!), поэтому делегирование идет дальше, на этот раз до "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":" — вершины цепочки делегирования. У "},{"attributes":{"italic":true},"insert":"этого"},{"insert":" объекта действительно есть "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", который указывает на встроенную функцию "},{"attributes":{"code":true},"insert":"Object(..)"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Разрушаем заблуждение"},{"insert":"\nКонечно, можно вернуть объекту "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":" свойство "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", но это придется сделать вручную.\nfunction Foo() { /* .. */ }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype = { /* .. */ }; // создаем новый объект-прототип"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Необходимо правильно \"пофиксить\" отсутствующее свойство `.constructor`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// у нового объекта, выступающего в роли `Foo.prototype`."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// См. главу 3 про `defineProperty(..)`."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.defineProperty( Foo.prototype, \"constructor\" , {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tenumerable: false,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\twritable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconfigurable: true,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvalue: Foo    // `.constructor` теперь указывает на `Foo`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Факт в том, что "},{"attributes":{"code":true},"insert":".constructor"},{"insert":" объекта по умолчанию указывает на функцию, которая, в свою очередь, имеет обратную ссылку на объект — ссылку "},{"attributes":{"code":true},"insert":".prototype"},{"insert":".\n"},{"attributes":{"code":true},"insert":".constructor"},{"insert":" — это не магическое неизменяемое свойство. Оно "},{"attributes":{"italic":true},"insert":"является"},{"insert":", неперечисляемым (см. пример выше), но его значение доступно для записи (может быть изменено), и более того, вы можете добавить или перезаписать (намеренно или случайно) свойство с именем "},{"attributes":{"code":true},"insert":"constructor"},{"insert":" в любом объекте любой цепочки "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", задав ему любое подходящее вам значение.\nВ силу того как алгоритм "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" обходит цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", ссылка на свойство "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", найденная в любом узле цепочки, может получать значение, весьма отличающееся от ожидаемого.\n"},{"attributes":{"code":true},"insert":"a1.constructor"},{"insert":" — слишком ненадежная и небезопасная ссылка, чтобы полагаться на нее в коде. "},{"attributes":{"bold":true},"insert":"В общем случае таких ссылок по возможности следует избегать"},{"insert":".\n\n\"(Прототипное) наследование\""},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Вот типичный пример кода в \"прототипном стиле\":\nfunction Foo(name) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.name = name;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.myName = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.name;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function Bar(name,label) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tFoo.call( this, name );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.label = label;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// здесь мы создаем `Bar.prototype`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// связанный с `Foo.prototype`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype = Object.create( Foo.prototype );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// Осторожно! Теперь `Bar.prototype.constructor` отсутствует,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// и это придется \"пофиксить\" вручную, "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// если вы привыкли полагаться на подобные свойства!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype.myLabel = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn this.label;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = new Bar( \"a\", \"obj a\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a.myName(); // \"a\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a.myLabel(); // \"obj a\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Самая важная строка здесь "},{"attributes":{"code":true},"insert":"Bar.prototype = Object.create( Foo.prototype )"},{"insert":". "},{"attributes":{"code":true},"insert":"Object.create(..)"},{"insert":" "},{"attributes":{"italic":true},"insert":"создает"},{"insert":" \"новый\" объект из ничего, и связывает внутреннюю ссылку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" этого объекта с указанным объектом (в данном случае "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":").\nДругими словами, эта строка означает: \"создать "},{"attributes":{"italic":true},"insert":"новый"},{"insert":" объект ''Bar точка prototype'', связанный с ''Foo точка prototype''\".\nПри объявлении "},{"attributes":{"code":true},"insert":"function Bar() { .. }"},{"insert":" функция "},{"attributes":{"code":true},"insert":"Bar"},{"insert":", как и любая другая, получает ссылку "},{"attributes":{"code":true},"insert":".prototype"},{"insert":" на объект по умолчанию. Но "},{"attributes":{"italic":true},"insert":"этот"},{"insert":" объект не ссылается на "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":", как мы того хотим. Поэтому мы создаем "},{"attributes":{"italic":true},"insert":"новый"},{"insert":"* объект, который "},{"attributes":{"italic":true},"insert":"имеет"},{"insert":" нужную ссылку, и отбрасываем исходный, неправильно связанный объект.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Типичная ошибка — пытаться использовать следующие варианты, думая, что они "},{"attributes":{"italic":true},"insert":"тоже"},{"insert":" сработают, но это приводит к неожиданным результатам:\n// работает не так, как вы ожидаете!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype = Foo.prototype;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// работает почти так, как нужно,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// но с побочными эффектами, которые возможно нежелательны :("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"Bar.prototype = Foo.prototype"},{"insert":" не создает новый объект, на который ссылалось бы "},{"attributes":{"code":true},"insert":"Bar.prototype"},{"insert":". Вместо этого "},{"attributes":{"code":true},"insert":"Bar.prototype"},{"insert":" становится еще одной ссылкой на "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":", и в результате "},{"attributes":{"code":true},"insert":"Bar"},{"insert":" напрямую связывается с тем же самым объектом, что и "},{"attributes":{"code":true},"insert":"Foo"},{"insert":": "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":". Это значит, что когда вы начнете присваивать значения, например "},{"attributes":{"code":true},"insert":"Bar.prototype.myLabel = ..."},{"insert":", вы будете изменять не отдельный объект, а общий объект "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":", что повлияет на любые объекты, привязанные к "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":". Это наверняка не то, чего вы хотите. В противном случае вам вообще не нужен "},{"attributes":{"code":true},"insert":"Bar"},{"insert":", и стоит использовать только "},{"attributes":{"code":true},"insert":"Foo"},{"insert":", сделав код проще.\n"},{"attributes":{"code":true},"insert":"Bar.prototype = new Foo()"},{"insert":" действительно создает новый объект, корректно привязанный к "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":". Но для этого используется \"вызов конструктора\" "},{"attributes":{"code":true},"insert":"Foo(..)"},{"insert":". Если эта функция имеет какие-либо побочные эффекты (логирование, изменение состояния, регистрация в других объектах, добавление свойств в "},{"attributes":{"code":true},"insert":"this"},{"insert":", и т.д.), то эти побочные эффекты сработают во время привязывания (и возможно в отношении неправильного объекта!), а не только при создании конечных \"потомков\" "},{"attributes":{"code":true},"insert":"Bar"},{"insert":", как можно было бы ожидать.\nПоэтому, для правильного привязывания нового объекта без побочных эффектов от вызова "},{"attributes":{"code":true},"insert":"Foo(..)"},{"insert":" у нас остается лишь "},{"attributes":{"code":true},"insert":"Object.create(..)"},{"insert":". Небольшой недостаток состоит в том, что нам приходится создавать новый объект и выбрасывать старый, вместо того чтобы модифицировать существующий стандартный объект.\nСравните пред-ES6 и стандартизованный в ES6 способ привязки "},{"attributes":{"code":true},"insert":"Bar.prototype"},{"insert":" к "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":":\n// пред-ES6"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// выбрасывает стандартный существующий `Bar.prototype`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Bar.prototype = Object.create( Foo.prototype );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// ES6+"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// изменяет существующий `Bar.prototype`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Object.setPrototypeOf( Bar.prototype, Foo.prototype );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Инспектируем связи между \"классами\""},{"insert":"\nЧто если у вас есть объект "},{"attributes":{"code":true},"insert":"a"},{"insert":" и вы хотите выяснить, какому объекту он делегирует? Инспектирование экземпляра (объект в JS) с целью найти его предка (делегирующая связь в JS) в традиционных класс-ориентированных языках часто называют "},{"attributes":{"italic":true},"insert":"интроспекцией"},{"insert":" (или "},{"attributes":{"italic":true},"insert":"рефлексией"},{"insert":").\nРассмотрим:\nfunction Foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Foo.prototype.blah = ...;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = new Foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Как выполнить интроспекцию "},{"attributes":{"code":true},"insert":"a"},{"insert":", чтобы найти его \"предка\" (делегирующую связь)? Первый подход использует путаницу с \"классами\":\na instanceof Foo; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Оператор "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" принимает в качестве операнда слева обычный объект, а в качества операнда справа — функцию. "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" отвечает на следующий вопрос: присутствует ли где-либо в цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта "},{"attributes":{"code":true},"insert":"a"},{"insert":" объект, на который указывает "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":"?\nК сожалению, это значит, что вы можете получить сведения о \"происхождении\" некоторого объекта ("},{"attributes":{"code":true},"insert":"a"},{"insert":") только имея некоторую функцию ("},{"attributes":{"code":true},"insert":"Foo"},{"insert":" c её ссылкой "},{"attributes":{"code":true},"insert":".prototype"},{"insert":"). Если у вас есть два произвольных объекта, например "},{"attributes":{"code":true},"insert":"a"},{"insert":" и "},{"attributes":{"code":true},"insert":"b"},{"insert":", и вы хотите узнать, связаны ли сами эти "},{"attributes":{"italic":true},"insert":"объекты"},{"insert":" друг с другом через цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", одного "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" будет недостаточно.\nВторой подход к рефлексии "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" более наглядный:\nFoo.prototype.isPrototypeOf( a ); // true"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"isPrototypeOf(..)"},{"insert":" отвечает на вопрос: присутствует ли где-либо в цепочке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта "},{"attributes":{"code":true},"insert":"a"},{"insert":" объект "},{"attributes":{"code":true},"insert":"Foo.prototype"},{"insert":"?\nМы можем напрямую получить "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта. В ES5 появился стандартный способ сделать это:\nObject.getPrototypeOf( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Здесь видно, что ссылка на объект является тем, что мы и ожидаем:\nObject.getPrototypeOf( a ) === Foo.prototype; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В большинстве браузеров (но не во всех!) давно добавлена поддержка нестандартного альтернативного способа доступа к "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":":\na.__proto__ === Foo.prototype; // true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Загадочное свойство "},{"attributes":{"code":true},"insert":".__proto__"},{"insert":" (стандартизовано лишь в ES6!) \"магически\" возвращает ссылку на внутреннее свойство "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" объекта, что весьма полезно, если вы хотите напрямую проинспектировать (или даже обойти: "},{"attributes":{"code":true},"insert":".__proto__.__proto__..."},{"insert":") цепочку.\nАналогично рассмотренному ранее "},{"attributes":{"code":true},"insert":".constructor"},{"insert":", свойство "},{"attributes":{"code":true},"insert":".__proto__"},{"insert":" отсутствует у инспектируемого объекта ("},{"attributes":{"code":true},"insert":"a"},{"insert":" в нашем примере). На самом деле оно есть (и является неперечисляемым, см. главу 2) у встроенного "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":", наряду с другими известными утилитами ("},{"attributes":{"code":true},"insert":".toString()"},{"insert":", "},{"attributes":{"code":true},"insert":".isPrototypeOf(..)"},{"insert":", и т.д.).\nБолее того, "},{"attributes":{"code":true},"insert":".__proto__"},{"insert":" выглядит как свойство, но правильнее думать о нем как о геттере/сеттере (см. главу 3).\nГрубо говоря, можно представить, что "},{"attributes":{"code":true},"insert":".__proto__"},{"insert":" реализовано так (см. главу 3 об определениях свойств объекта):\nObject.defineProperty( Object.prototype, \"__proto__\", {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tget: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\treturn Object.getPrototypeOf( this );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t},"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tset: function(o) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// setPrototypeOf(..) доступно начиная с ES6"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tObject.setPrototypeOf( this, o );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\treturn o;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Таким образом, когда мы обращаемся (получаем значение) к "},{"attributes":{"code":true},"insert":"a.__proto__"},{"insert":", это похоже на вызов "},{"attributes":{"code":true},"insert":"a.__proto__()"},{"insert":" (вызов функции геттера). В "},{"attributes":{"italic":true},"insert":"этом"},{"insert":"* вызове функции "},{"attributes":{"code":true},"insert":"this"},{"insert":" указывает на "},{"attributes":{"code":true},"insert":"a"},{"insert":", несмотря на то что функция геттера находится в объекте "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":" (см. главу 2 о правилах привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":"), так что это равносильно "},{"attributes":{"code":true},"insert":"Object.getPrototypeOf( a )"},{"insert":".\nЗначение "},{"attributes":{"code":true},"insert":".__proto__"},{"insert":" можно также изменять, например с помощью функции "},{"attributes":{"code":true},"insert":"Object.setPrototypeOf(..)"},{"insert":" в ES6, как показано выше. Однако обычно н"},{"attributes":{"bold":true},"insert":"е следует изменять "},{"attributes":{"bold":true,"code":true},"insert":"[[Prototype]]"},{"attributes":{"bold":true},"insert":" существующего объекта"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": В ES6 добавлено ключевое слово "},{"attributes":{"code":true},"insert":"class"},{"insert":", с помощью которого можно делать вещи, напоминающие \"создание производных классов\" от встроенных объектов, таких как "},{"attributes":{"code":true},"insert":"Array"},{"insert":".\nВ остальном же единственным исключением будет установка свойства "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" стандартного объекта "},{"attributes":{"code":true},"insert":".prototype"},{"insert":" функции, чтобы оно ссылалось на какой-то другой объект (помимо "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":"). Это позволит избежать замены этого стандартного объекта новым объектом. В любой другой ситуации "},{"attributes":{"bold":true},"insert":"лучше всего считать ссылку "},{"attributes":{"bold":true,"code":true},"insert":"[[Prototype]]"},{"attributes":{"bold":true},"insert":" доступной только для чтения"},{"insert":", чтобы облегчить чтение вашего кода в будущем.\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": В сообществе JavaScript неофициально закрепилось название двойного подчеркивания, особенно перед именами свойств (как "},{"attributes":{"code":true},"insert":"__proto__"},{"insert":"): \"dunder\". Поэтому в мире JavaScript \"крутые ребята\" обычно произносят "},{"attributes":{"code":true},"insert":"__proto__"},{"insert":" как \"dunder proto\".\n\nОбъектные ссылки"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Переход по этой ссылке выполняется (в основном) когда происходит обращение к свойству/методу первого объекта, и это свойство/метод отсутствует. В таком случае ссылка "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" указывает движку, что свойство/метод нужно искать в связанном объекте. Если и в этом объекте ничего не находится, то происходит переход по его ссылке "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", и так далее. Эта последовательность ссылок между объектами образует то, что называется \"цепочкой прототипов\".\n\n"},{"attributes":{"bold":true},"insert":"Создание ссылок"},{"insert":"\nПомните, как в начале этой главы мы сказали, что "},{"attributes":{"code":true},"insert":"Object.create(..)"},{"insert":" станет нашим героем? Теперь вы готовы это увидеть.\nvar foo = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tsomething: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Скажи что-нибудь хорошее...\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = Object.create( foo );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar.something(); // Скажи что-нибудь хорошее..."},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"Object.create(..)"},{"insert":" создает новый объект ("},{"attributes":{"code":true},"insert":"bar"},{"insert":"), связанный с объектом, который мы указали ("},{"attributes":{"code":true},"insert":"foo"},{"insert":"), и это дает нам всю мощь (делегирование) механизма "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":".\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": "},{"attributes":{"code":true},"insert":"Object.create(null)"},{"insert":" создает объект с пустой (или "},{"attributes":{"code":true},"insert":"null"},{"insert":") ссылкой "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", поэтому этот объект не сможет ничего делегировать. Поскольку у такого объекта нет цепочки прототипов, оператору "},{"attributes":{"code":true},"insert":"instanceof"},{"insert":" (рассмотренному ранее) нечего проверять, и он всегда вернет "},{"attributes":{"code":true},"insert":"false"},{"insert":". Эти специальные объекты с пустым "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" часто называют \"словарями\", поскольку они обычно используются исключительно для хранения данных в свойствах, потому что у них не может быть никаких побочных эффектов от делегируемых свойств/функций цепочки "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":", и они являются абсолютно плоскими хранилищами данных.\n\nvar anotherObject = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"круто!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var myObject = Object.create( anotherObject );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.doCool = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tthis.cool(); // внутреннее делегирование!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"myObject.doCool(); // \"круто!\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Здесь мы вызываем "},{"attributes":{"code":true},"insert":"myObject.doCool()"},{"insert":" — метод, который "},{"attributes":{"italic":true},"insert":"действительно есть"},{"insert":" у объекта "},{"attributes":{"code":true},"insert":"myObject"},{"insert":", делая наш API более явным (менее \"магическим\"). "},{"attributes":{"italic":true},"insert":"Внутри"},{"insert":" наша реализация следует шаблону делегирования (см. главу 6), используя делегирование "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" к "},{"attributes":{"code":true},"insert":"anotherObject.cool()"},{"insert":".\nДругими словами, делегирование как правило преподносит меньше сюрпризов, если оно является частью внутренней реализации, а не выставлено наружу в дизайне API. \nОбзор"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"При попытке обратиться к несуществующему свойству объекта внутренняя ссылка "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":" этого объекта задает дальнейшее направление поиска для операции "},{"attributes":{"code":true},"insert":"[[Get]]"},{"insert":" (см. главу 3). Этот каскад ссылок от объекта к объекту образует \"цепочку прототипов\" (чем то похожую на цепочку вложенных областей видимости) для обхода при разрешении свойства.\nУ обычных объектов есть встроенный объект "},{"attributes":{"code":true},"insert":"Object.prototype"},{"insert":" на конце цепочки прототипов (похоже на глобальную область видимости при поиске по цепочке областей видимости), где процесс разрешения свойства остановится, если свойство не будет найдено в предыдущих звеньях цепочки. У этого объекта есть утилиты "},{"attributes":{"code":true},"insert":"toString()"},{"insert":", "},{"attributes":{"code":true},"insert":"valueOf()"},{"insert":" и несколько других, благодаря чему все объекты в языке имеют доступ к ним.\nНаиболее популярный способ связать два объекта друг с другом — использовать ключевое слово "},{"attributes":{"code":true},"insert":"new"},{"insert":" с вызовом функции, что помимо четырех шагов (см. главу 2) создаст новый объект, привязанный к другому объекту.\nЭтим \"другим объектом\" является объект, на который указывает свойство "},{"attributes":{"code":true},"insert":".prototype"},{"insert":" функции, вызванной с "},{"attributes":{"code":true},"insert":"new"},{"insert":". Функции, вызываемые с "},{"attributes":{"code":true},"insert":"new"},{"insert":", часто называют \"конструкторами\", несмотря на то что они не создают экземпляры классов, как это делают "},{"attributes":{"italic":true},"insert":"конструкторы"},{"insert":" в традиционных класс-ориентированных языках.\nХотя эти механизмы JavaScript могут напоминать \"создание экземпляров классов\" и \"наследование классов\" из традиционных класс-ориентированных языков, ключевое отличие в том, что в JavaScript не создаются копии. Вместо этого объекты связываются друг с другом через внутреннюю цепочку "},{"attributes":{"code":true},"insert":"[[Prototype]]"},{"insert":".\nПо множеству причин, среди которых не последнюю роль играет терминологический прецедент, \"наследование\" (и \"прототипное наследование\") и все остальные ОО-термины не имеют смысла, учитывая то как "},{"attributes":{"italic":true},"insert":"на самом деле"},{"insert":" работает JavaScript.\nБолее подходящим термином является \"делегирование\", поскольку эти связи являются не "},{"attributes":{"italic":true},"insert":"копиями"},{"insert":", а делегирующими "},{"attributes":{"bold":true},"insert":"ссылками"},{"insert":".\n\n\nИсточник"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://github.com/azat-io/you-dont-know-js-ru/tree/master/this%20%26%20object%20prototypes"},"insert":"https://github.com/azat-io/you-dont-know-js-ru/tree/master/this%20%26%20object%20prototypes"},{"insert":"\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('29/10/2019, 08:55:00', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('31/01/2020, 16:53:02', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Вы не знаете JS: Область видимости и замыкания"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Конспект по второй книге You Don''t Know JS: Scope & Closures"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/scope%20%26%20closures/cover.jpg"}}},{"insert":"\nГлава 1: Что такое область видимости?"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Теория компиляторов"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Традиционный процесс языковой компиляции:\n"},{"attributes":{"bold":true},"insert":"Разбиение на лексемы (Tokenizing/Lexing)"},{"insert":": разбиение строки символов на имеющие смысл (для языка) части, называемые лексемами."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"Парсинг:"},{"insert":" берет поток (массив) лексем и превращает его в дерево вложенных элементов, которые сообща представляют грамматическую структуру программы. Это дерево называется \"AST\" (Abstract Syntax Tree, дерево абстрактного синтаксиса)."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"bold":true},"insert":"Генерация кода:"},{"insert":" процесс взятия AST и превращения его в исполняемый код."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Несмотря на тот факт, что JavaScript подпадает под общую категорию \"динамических\" или \"интерпретируемых\" языков, на самом деле он является компилируемым языком. Любой код JavaScript должен быть скомпилирован до (обычно "},{"attributes":{"italic":true},"insert":"прямо"},{"insert":" перед!) его выполнения.\n\nПонимание области видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Когда "},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" выполняет код, который "},{"attributes":{"italic":true},"insert":"Компилятор"},{"insert":" генерирует на шаге, он должен поискать переменную "},{"attributes":{"code":true},"insert":"a"},{"insert":", чтобы увидеть была ли она объявлена и этот поиск принимает во внимание "},{"attributes":{"italic":true},"insert":"Область видимости"},{"insert":". \n"},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" выполнит \"RHS\" или \"LHS\"-поиск переменной. Эти термины означают \"Left-hand Side\" (левая сторона) и \"Right-hand Side\" (правая сторона). LHS-поиск выполняется, когда переменная появляется с левой стороны операции присваивания, а RHS-поиск выполняется, когда переменная появляется с правой стороны операции присваивания.\nLHS и RHS, означающие \"левая/правая сторона присваивания\", не обязательно буквально означают \"левая/правая сторона операции присваивания "},{"attributes":{"code":true},"insert":"="},{"insert":"\". Есть еще несколько способов, которыми производится присваивание, и поэтому лучше концептуально думать о нем как: \"кто является целью присваивания (LHS)\" и \"кто источник присваивания (RHS)\".\nfunction foo(a) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar b = a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn a + b;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c = foo( 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Определите все LHS-поиски (их 3!)."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"c = .."},{"insert":", "},{"attributes":{"code":true},"insert":"a = 2"},{"insert":" (неявное присваивание параметру) и "},{"attributes":{"code":true},"insert":"b = .."},{"insert":"\nОпределите все RHS-поиски (их 4!)."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"foo(2.."},{"insert":", "},{"attributes":{"code":true},"insert":"= a;"},{"insert":", "},{"attributes":{"code":true},"insert":"a + .."},{"insert":" и "},{"attributes":{"code":true},"insert":".. + b"},{"insert":"\n\nОбласть видимости — это набор правил, которые определяют где и как переменная (идентификатор) могут быть найдены. Этот поиск может осуществляться для целей присваивания значения переменной, которая является LHS (left-hand-side) ссылкой, или может осуществляться для целей извлечения ее значения, которое является RHS (right-hand-side) ссылкой.\nLHS-ссылки являются результатом операции присваивания. Присваивания, связанные с "},{"attributes":{"italic":true},"insert":"Областью видимости"},{"insert":", могут происходить либо с помощью операции "},{"attributes":{"code":true},"insert":"="},{"insert":", либо передачей аргументов (присваиванием) параметрам функции.\nJavaScript "},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" перед выполнением сначала компилирует код, и пока он это делает, он разбивает операторы, подобные "},{"attributes":{"code":true},"insert":"var a = 2;"},{"insert":" на два отдельных шага:\nПервый, "},{"attributes":{"code":true},"insert":"var a"},{"insert":", чтобы объявить ее в "},{"attributes":{"italic":true},"insert":"Область видимости"},{"insert":". Это выполняется в самом начале, до исполнения кода."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Позже, "},{"attributes":{"code":true},"insert":"a = 2"},{"insert":" ищет переменную (LHS-ссылку) и присваивает ей значение, если находит."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"\nВложенная область видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Простые правила просмотра вложенных "},{"attributes":{"italic":true},"insert":"Областей видимости"},{"insert":": "},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" начинает в текущей выполняемой "},{"attributes":{"italic":true},"insert":"Области видимости"},{"insert":", ищет в ней переменную, затем если не находит, продолжает поиск уровнем выше и так далее. Если достигнута самая внешняя глобальная область видимости, поиск останавливается, независимо от того, нашел он переменную или нет.\nОба поиска ссылок LHS и RHS начинаются в текущей выполняющейся "},{"attributes":{"italic":true},"insert":"Области видимости"},{"insert":" и если нужно (т.е. они не нашли что искали в ней), они работают с их более высокими вложенными "},{"attributes":{"italic":true},"insert":"Областями видимости"},{"insert":", с одной областью (этажом) за раз, ища идентификатор, пока не доберутся до глобальной (верхний этаж) и не остановятся, вне зависимости от результата поиска.\n\nОшибки"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Если RHS-поиск не сможет когда-либо найти переменную, в любой из вложенных "},{"attributes":{"italic":true},"insert":"Областей видимости"},{"insert":", это приведет к возврату "},{"attributes":{"italic":true},"insert":"Движком "},{"insert":"ошибки "},{"attributes":{"code":true},"insert":"ReferenceError"},{"insert":". \nНапротив, если "},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" выполняет LHS-поиск и достигает верхнего этажа (глобальной "},{"attributes":{"italic":true},"insert":"Области видимости"},{"insert":") и не находит ничего, и если программа не запущена в \"строгом режиме\", то затем глобальная "},{"attributes":{"italic":true},"insert":"Область видимости"},{"insert":" создаст новую переменную с таким именем в глобальной области видимости и передаст ее обратно "},{"attributes":{"italic":true},"insert":"Движку"},{"insert":".\n\"Строгий режим\", который был добавлен в ES5, имеет ряд разных отличий от обычного/нестрогого/ленивого режима. Одно такое отличие — это то, что он запрещает автоматическое/неявное создание глобальных переменных. В этом случае, не было бы никакой переменной в глобальной "},{"attributes":{"italic":true},"insert":"Области видимости"},{"insert":", чтобы передать обратно от LHS-поиска, и "},{"attributes":{"italic":true},"insert":"Движок "},{"insert":"выбросит "},{"attributes":{"code":true},"insert":"ReferenceError "},{"insert":"аналогично случаю с RHS.\nТеперь, если переменная найдена в ходе RHS-поиска, но вы пытаетесь сделать что-то с ее значением, что невозможно, например, пытаетесь выполнить как функцию не-функциональное значение или ссылаетесь на свойство значения "},{"attributes":{"code":true},"insert":"null"},{"insert":" или "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", то "},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" выдаст другой вид ошибки, называемый "},{"attributes":{"code":true},"insert":"TypeError"},{"insert":".\n"},{"attributes":{"code":true},"insert":"ReferenceError"},{"insert":" — это сбой разрешения имени, связанный с "},{"attributes":{"italic":true},"insert":"Областью видимости"},{"insert":", тогда как "},{"attributes":{"code":true},"insert":"TypeError"},{"insert":" подразумевает, что разрешение имени в "},{"attributes":{"italic":true},"insert":"Области видимости"},{"insert":" было успешным, но была попытка выполнения нелегального/невозможного действия с результатом.\n\nНевыполненные RHS-ссылки приводят к выбросу "},{"attributes":{"code":true},"insert":"ReferenceError"},{"insert":". Невыполненные LHS-ссылки приводят к автоматической, неявно созданной переменной с таким именем (если не включен \"Строгий режим\"), либо к "},{"attributes":{"code":true},"insert":"ReferenceError"},{"insert":" (если включен \"Строгий режим\").\n\nГлава 2: Лексическая область видимости"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Лексическая область видимости означает, что область видимости определена решениями о том, где объявляются функции на стадии написания кода. Фаза разбиения на лексемы при компиляции фактически способна узнать где и как объявлены все идентификаторы, и таким образом предсказать как их будут искать во время выполнения.\nОбманываем лексическую область видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"обман лексической области видимости ведет к более худшей производительности\n"},{"attributes":{"code":true},"insert":"eval"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Функция "},{"attributes":{"code":true},"insert":"eval(..)"},{"insert":" в JavaScript берет строку как аргумент и интерпретирует содержимое строки как если бы это был код, написанный в этой точке программы. \nКогда "},{"attributes":{"code":true},"insert":"eval(..)"},{"insert":" используется в программе, работающей в строгом режиме, она работает со своей собственной лексической областью видимости, что означает, что объявления, сделанные внутри "},{"attributes":{"code":true},"insert":"eval()"},{"insert":", не поменяют окружающую область видимости.\nfunction foo(str) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"   \"use strict\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"   eval( str );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"   console.log( a ); // ReferenceError: a is not defined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo( \"var a = 2\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Есть другие средства в JavaScript, которые почти равносильны по эффекту вызовам "},{"attributes":{"code":true},"insert":"eval(..)"},{"insert":". "},{"attributes":{"code":true},"insert":"setTimeout(..)"},{"insert":" и "},{"attributes":{"code":true},"insert":"setInterval(..)"},{"insert":", которые "},{"attributes":{"italic":true},"insert":"могут"},{"insert":" принимать строку как свой первый аргумент, содержимое которой "},{"attributes":{"code":true},"insert":"вычисляется"},{"insert":" как код динамически сгенерированной функции. Это старая, унаследованная функциональность и давным-давно устаревшая. Не делайте так!\nКонструктор функции "},{"attributes":{"code":true},"insert":"new Function(..)"},{"insert":" аналогично принимает строку кода в своем последнем аргументе, чтобы превратить ее в динамически сгенерированную функцию (первые аргументы, если указаны, являются именованными параметрами для новой функции). Такой синтаксис конструктора функции немного безопаснее, чем "},{"attributes":{"code":true},"insert":"eval(..)"},{"insert":", но его также следует избегать в вашем коде.\n\nБыстродействие"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"В "},{"attributes":{"italic":true},"insert":"Движке"},{"insert":" JavaScript есть много оптимизаций быстродействия, которые он выполняет во время фазы компиляции. Некоторые из этих оптимизаций сводятся к возможности по сути статически анализировать код, как только он разбирается на лексемы, и заранее определять где находятся все переменные и функции, для того чтобы понадобилось меньше усилий для разрешения имен идентификаторов во время выполнения.\n с точки зрения пессимистического здравого смысла, большинство таких оптимизаций, которые он "},{"attributes":{"italic":true},"insert":"мог бы"},{"insert":" сделать, бессмысленны, если есть "},{"attributes":{"code":true},"insert":"eval(..)"},{"insert":" или "},{"attributes":{"code":true},"insert":"with"},{"insert":", поэтому он просто не выполняет "},{"attributes":{"italic":true},"insert":"никаких"},{"insert":" оптимизаций.\n\n\nГлава 3: Область видимости: функции против блоков"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Область видимости из функций"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Область видимости функции поощряет идею, что все переменные принадлежат функции и могут быть использованы и переиспользованы на всем протяжении функции (и более того, доступны даже во вложенных областях видимости). Этот подход к дизайну может быть довольно полезен и несомненно может использовать в полном объеме \"динамическую\" природу переменных JavaScript, чтобы иметь дело со значениями разных типов при необходимости.\n\nПрячемся на виду у всей области видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Есть множество причин, мотивирующих на это сокрытие, основанное на области видимости. Они имеют тенденцию проистекать из принципа дизайна ПО \"Принцип наименьших привилегий\", также иногда называемый \"Наименьшие полномочия\" или \"Наименьшая открытость\". Этот принцип заявляет, что в дизайне ПО, таком как API для модуля/объекта, вам следует выставлять наружу только то, что минимально необходимо и \"прятать\" всё остальное.\n\nПредотвращение коллизий"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Еще одно преимущество \"скрытия\" переменных и функций внутри области действия — чтобы избежать неумышленных коллизий между двумя идентификаторами с одним и тем же именем, но с разным целевым использованием. Коллизии часто приводят к неумышленной перезаписи значений.\nНапример:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction bar(a) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\ti = 3; // меняем `i` в окружающей области видимости цикла for-loop"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( a + i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfor (var i=0; i<10; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tbar( i * 2 ); // упс, впереди бесконечный цикл!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nФункции как области видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Мы уже видели, что можно взять любой кусок кода и обернуть его в функцию, и это эффективно \"скроет\" любые вложенные определения переменных или функций от внешней области видимости во внутренней области видимости этой функции.\nНесмотря на то, что эта техника \"работает\", она не обязательно очень идеальна. Она привносит некоторые проблемы. Первая, это то, что мы должны объявить именованную функцию "},{"attributes":{"code":true},"insert":"foo()"},{"insert":", которая означает, что само имя идентификатора "},{"attributes":{"code":true},"insert":"foo"},{"insert":" \"засоряет\" окружающую область видимости (в данном случае глобальную). Мы также должны явно вызвать функцию по имени ("},{"attributes":{"code":true},"insert":"foo()"},{"insert":") для того ,чтобы обернутый код выполнился на самом деле.\nК счастью, JavaScript предлагает решение обеих проблем - функциональное выражение.\nvar a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function foo(){ // <-- вставляем это"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( a ); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})(); // <-- и это"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Иными словами, "},{"attributes":{"code":true},"insert":"(function foo(){ .. })"},{"insert":" как выражение означает, что идентификатор "},{"attributes":{"code":true},"insert":"foo"},{"insert":" может быть найден "},{"attributes":{"italic":true},"insert":"только"},{"insert":" в области видимости, которая обозначена "},{"attributes":{"code":true},"insert":".."},{"insert":", но не во внешней области видимости. Скрывание имени "},{"attributes":{"code":true},"insert":"foo"},{"insert":" внутри себя означает, что оно не будет неоправданно загрязнять окружающую область видимости.\n\n"},{"attributes":{"bold":true},"insert":"Анонимный против названного"},{"insert":"\nУ анонимных функций нет удобного имени для отображения в стектрейсах (stacktrace), что может затруднить отладку."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Если функции без имени будет нужно сослаться на себя же, для рекурсии или чего-то подобного, к сожалению требуется устаревшая ссылка "},{"attributes":{"code":true},"insert":"arguments.callee"},{"insert":". Еще один пример необходимости в ссылке на себя, когда функция обработчика события хочет отписать себя от события после выполнения."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Анонимные функции опускают имя, что часто удобно для обеспечения большей читаемости/понятности кода. Наглядное же имя помогает самодокументировать рассматриваемый код."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Встраиваемые функциональные выражения — мощные и полезные инструменты, выбор между анонимными и именованными не умаляет их достоинств. Именование вашего функционального выражения достаточно эффективно решает все перечисленные недостатки, и при этом не имеет ощутимых минусов. Лучшая практика — это всегда именовать ваши функциональные выражения:\nsetTimeout( function timeoutHandler(){ // <-- Смотри, у меня есть имя!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( \"I waited 1 second!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}, 1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Вызов функциональных выражений по месту"},{"insert":"\nvar a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function foo(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( a ); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Теперь, когда у нас есть функция как выражение благодаря обертыванию ее в пару "},{"attributes":{"code":true},"insert":"( )"},{"insert":", мы можем вызвать эту функцию добавив еще одни "},{"attributes":{"code":true},"insert":"()"},{"insert":" в конце, как тут "},{"attributes":{"code":true},"insert":"(function foo(){ .. })()"},{"insert":". Первая окружающая пара "},{"attributes":{"code":true},"insert":"( )"},{"insert":" делает функцию выражением, а вторая "},{"attributes":{"code":true},"insert":"()"},{"insert":" выполняет функцию.\nЭтот шаблон настолько в ходу, что несколько лет назад сообщество условилось о термине для него: "},{"attributes":{"bold":true},"insert":"IIFE"},{"insert":", что означает Immediately (немедленно) Invoked (вызываемое) Function (функциональное) Expression (выражение).\nЕсть легкая вариация формы традиционной IIFE, которую предпочитают некоторые: "},{"attributes":{"code":true},"insert":"(function(){ .. }())"},{"insert":". Посмотрим ближе, чтобы увидеть разницу. В первой форме функциональное выражение обернуто в "},{"attributes":{"code":true},"insert":"( )"},{"insert":", а затем пара вызывающих ее "},{"attributes":{"code":true},"insert":"()"},{"insert":" снаружи прямо за ними. Во второй форме, вызывающая пара "},{"attributes":{"code":true},"insert":"()"},{"insert":" переместилась внутрь внешней окружающей пары "},{"attributes":{"code":true},"insert":"( )"},{"insert":".\nЭти две формы идентичны по функциональности. "},{"attributes":{"bold":true},"insert":"Какую из них предпочесть — всего лишь ваш стилистический выбор."},{"insert":"\nЕще одно применение этого шаблона решает (узкоспециализированную) проблему, что значение идентификатора по умолчанию "},{"attributes":{"code":true},"insert":"undefined"},{"insert":" может быть некорректно перезаписано, приведя к неожиданным результатам. Давая параметру имя "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", но не передавая никакого значения для этого аргумента, мы можем гарантировать, что идентификатор "},{"attributes":{"code":true},"insert":"undefined"},{"insert":" фактически имеет незаданное значение в этом блоке кода:\nundefined = true; // устанавливаем мину для другого кода! остерегайтесь!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function IIFE( undefined ){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tif (a === undefined) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( \"Undefined is safe here!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Еще одна вариация IIFE меняет порядок вещей на обратный, где вызываемая функция идет второй, "},{"attributes":{"italic":true},"insert":"после"},{"insert":" вызова и параметров, которые в нее передаются. Этот шаблон используется в проекте UMD (Universal Module Definition). Некоторые люди находят его более ясным для понимания, хотя он немного более многословный.\nvar a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"(function IIFE( def ){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tdef( window );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})(function def( global ){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( a ); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( global.a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"});"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Функциональное выражение "},{"attributes":{"code":true},"insert":"def"},{"insert":" определяется во второй половине кода, а затем передается как параметр (также названный "},{"attributes":{"code":true},"insert":"def"},{"insert":") в функцию "},{"attributes":{"code":true},"insert":"IIFE"},{"insert":", определенную в первой половине кода. Наконец, параметр "},{"attributes":{"code":true},"insert":"def"},{"insert":" (функция) вызывается, передавая "},{"attributes":{"code":true},"insert":"window"},{"insert":" в нее как параметр "},{"attributes":{"code":true},"insert":"global"},{"insert":".\n\nБлоки как области видимости"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"\nfor (var i=0; i<10; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Мы объявляем переменную "},{"attributes":{"code":true},"insert":"i"},{"insert":" прямо внутри заголовка цикла for-loop, скорее всего потому, что наше "},{"attributes":{"italic":true},"insert":"намерение"},{"insert":" — использовать "},{"attributes":{"code":true},"insert":"i"},{"insert":" только в контексте этого цикла for-loop и в основном игнорировать факт того, что переменная на самом деле заключает себя в окружающую область видимости (функции или глобальную).\nВот это и есть самое важное в блочной области видимости. Объявление переменных как можно ближе и как можно локальней к тому месту, где они будут использоваться. Еще один пример:\nvar foo = true;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (foo) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar bar = foo * 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbar = something( bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Мы используем переменную "},{"attributes":{"code":true},"insert":"bar"},{"insert":" только в контексте оператора if, поэтому вполне разумно, что мы объявили ее внутри блока if. Однако, место, где мы объявляем переменные не имеет значения при использовании "},{"attributes":{"code":true},"insert":"var"},{"insert":", так как они всегда принадлежат окружающей области видимости. Этот код по существу \"поддельная\" блочная область видимости, только для целей стилистики, и полагается на самообязательство не использовать случайно "},{"attributes":{"code":true},"insert":"bar"},{"insert":" в другом месте этой области видимости.\n"},{"attributes":{"code":true},"insert":"try/catch"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"italic":true},"insert":"Очень"},{"insert":" малоизвестным фактом является то, что JavaScript в ES3 специфицирует объявление переменной в блоке "},{"attributes":{"code":true},"insert":"catch"},{"insert":" оператора "},{"attributes":{"code":true},"insert":"try/catch"},{"insert":" как принадлежащее блочной области видимости блока "},{"attributes":{"code":true},"insert":"catch"},{"insert":".\nНапример:\ntry {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tundefined(); // нелегальная операция, чтобы вызвать исключение!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"catch (err) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( err ); // работает!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( err ); // ReferenceError: `err` not found"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Как видите, "},{"attributes":{"code":true},"insert":"err"},{"insert":" существует только в блоке "},{"attributes":{"code":true},"insert":"catch"},{"insert":" и выбрасывает ошибку когда вы пытаетесь сослаться на нее где-либо в другом месте.\nПримечание: Несмотря на то, что такое поведение было определено и истинно практически во всех стандартных средах JS (за исключением разве что старого IE), многие линтеры (средства контроля качества кода) похоже до сих пор жалуются, если у вас есть два или более блоков "},{"attributes":{"code":true},"insert":"catch"},{"insert":" в одной и той же области видимости, каждый из которых объявляет свою переменную ошибки с одинаковым именем идентификатора. В действительности это не переопределение, поскольку переменные безопасно обернуты в блочные области видимости, но линтеры похоже до сих пор раздражающе жалуются на этот факт.\nЧтобы избежать таких ненужных предупреждений, некоторые разработчики именуют свои переменные в "},{"attributes":{"code":true},"insert":"catch"},{"insert":" как "},{"attributes":{"code":true},"insert":"err1"},{"insert":", "},{"attributes":{"code":true},"insert":"err2"},{"insert":" и т.д.. Другие разработчики просто выключают проверку линтера на повторяющиеся имена переменных.\nПрирода блочной области видимости "},{"attributes":{"code":true},"insert":"catch"},{"insert":" может казаться бесполезным академическим фактом, но лучше загляните в приложение B, чтобы получить детальную информацию о том насколько полезна она может быть.\n"},{"attributes":{"code":true},"insert":"let"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Ключевое слово "},{"attributes":{"code":true},"insert":"let"},{"insert":" присоединяет объявление переменной к области видимости того блока (обычно пара "},{"attributes":{"code":true},"insert":"{ .. }"},{"insert":"), в котором оно содержится. \nvar foo = true;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (foo) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tlet bar = foo * 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbar = something( bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( bar ); // ReferenceError"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"bold":true},"insert":"Сборка мусора"},{"insert":"\nЕще одна причина полезности блочной области видимости связана с замыканиями и сборкой мусора, чтобы освободить память. Мы кратко проиллюстрируем это здесь, но детально механизм замыканий будет рассматриваться в главе 5.\nПример:\nfunction process(data) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// делаем что-то интересное"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var someReallyBigData = { .. };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"process( someReallyBigData );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var btn = document.getElementById( \"my_button\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"btn.addEventListener( \"click\", function click(evt){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log(\"button clicked\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}, /*capturingPhase=*/false );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обратный вызов обработчика щелчка "},{"attributes":{"code":true},"insert":"click"},{"insert":" совсем не "},{"attributes":{"italic":true},"insert":"требует"},{"insert":" переменную "},{"attributes":{"code":true},"insert":"someReallyBigData"},{"insert":". Это значит, теоретически, что после выполнения "},{"attributes":{"code":true},"insert":"process(..)"},{"insert":", большая памятезатратная структура данных может быть собрана сборщиком мусора. Однако, весьма вероятно (хотя зависит от реализации), что движок JS все еще должен будет оставить структуру в памяти, поскольку у функции "},{"attributes":{"code":true},"insert":"click"},{"insert":" есть замыкание, действующее во всей области видимости.\nБлочная область видимости может устранить этот недостаток, делая более явным для движка то, что ему не нужна "},{"attributes":{"code":true},"insert":"someReallyBigData"},{"insert":":\nfunction process(data) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// делаем что-то интересное"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// всё, что объявлено внутри этого блока, может исчезнуть после него!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"{"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tlet someReallyBigData = { .. };"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tprocess( someReallyBigData );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var btn = document.getElementById( \"my_button\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"btn.addEventListener( \"click\", function click(evt){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log(\"button clicked\");"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}, /*capturingPhase=*/false );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Объявление явных блоков для переменных, чтобы локально привязать их к блокам — мощный инструмент, который вы можете добавить в свой арсенал.\n"},{"attributes":{"code":true},"insert":"const"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"В дополнение к "},{"attributes":{"code":true},"insert":"let"},{"insert":", ES6 представляет ключевое слово "},{"attributes":{"code":true},"insert":"const"},{"insert":", которое также создает переменную блочной области видимости, но чье значение фиксированно (константа). Любая попытка изменить это значение позже приведет к ошибке.\nvar foo = true;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (foo) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconst b = 3; // в блочной области видимости содержащего ее `if`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta = 3; // просто отлично!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tb = 4; // ошибка!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( a ); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( b ); // ReferenceError!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n\nГлава 4: Поднятие переменных (Hoisting)"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nПредставьте такой код:\na = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Многие разработчики ожидают увидеть "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", поскольку оператор "},{"attributes":{"code":true},"insert":"var a"},{"insert":" идет после "},{"attributes":{"code":true},"insert":"a = 2"},{"insert":", и было бы естественным предположить, что переменная переопределена и потому ей присвоено значение по умолчанию "},{"attributes":{"code":true},"insert":"undefined"},{"insert":". Однако, результат будет "},{"attributes":{"code":true},"insert":"2"},{"insert":".\nПредставьте еще один код:\nconsole.log( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Будет выведено "},{"attributes":{"code":true},"insert":"undefined"},{"insert":".\nКогда видите "},{"attributes":{"code":true},"insert":"var a = 2;"},{"insert":", вы наверное думаете о нем как об одном операторе. Но JavaScript на самом деле думает о нем как о двух операторах: "},{"attributes":{"code":true},"insert":"var a;"},{"insert":" и "},{"attributes":{"code":true},"insert":"a = 2;"},{"insert":". Первый оператор, объявление, обрабатывается во время фазы компиляции. Второй оператор, присваивание, остается на своем месте в фазе исполнения.\nСледовательно о нашем первом коде следует думать как об обрабатываемом следующим образом:\nvar a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"...где первая часть — компиляция, а вторая — выполнение.\nАналогично, наш второй код в действительности будет обработан так:\nvar a;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Получается, один из путей представить это, в какой-то степени образно, что эти объявления переменной и функции \"переехали\" с того места, где они появились в коде в начало кода. Это дало начало названию \"Поднятие (Hoisting)\".\n"},{"attributes":{"bold":true},"insert":"Примечание"},{"insert":": Поднимаются только сами объявления, тогда как любые присваивания или другая логика выполнения остается "},{"attributes":{"italic":true},"insert":"на месте"},{"insert":".\nТакже важно отметить, что "},{"attributes":{"bold":true},"insert":"каждое поднятие соотносится с областью видимости"},{"insert":". \nОбъявления функций поднимаются. А функциональные выражения — нет.\nfoo(); // не ReferenceError, но TypeError!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo = function bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Также помните, что даже если это именованное функциональное выражение, идентификатор имени недоступен в окружающей области видимости:\nfoo(); // TypeError"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar(); // ReferenceError"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo = function bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот код более точно интерпретируется (с учетом поднятия) как:\nvar foo;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo(); // TypeError"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar(); // ReferenceError"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar bar = ...self..."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// ... "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nСначала функции"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Как объявления функций, так и переменных поднимаются. Но тонкость (которая "},{"attributes":{"italic":true},"insert":"поможет"},{"insert":" объяснить множественные объявления \"дубликатов\" в коде) в том, что сперва поднимаются функции, а затем уже переменные.\nПредставим:\nfoo(); // 1"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 1 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"1"},{"insert":" выводится вместо "},{"attributes":{"code":true},"insert":"2"},{"insert":"! Этот код интерпретируется "},{"attributes":{"italic":true},"insert":"Движком"},{"insert":" так:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 1 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo(); // 1"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Обратите внимание, что "},{"attributes":{"code":true},"insert":"var foo"},{"insert":" является дублем объявления (и поэтому игнорируется), даже несмотря на то, что идет до объявления "},{"attributes":{"code":true},"insert":"function foo()..."},{"insert":", потому что объявления функций поднимаются до обычных переменных.\nВ то время как множественные/дублирующие объявления "},{"attributes":{"code":true},"insert":"var"},{"insert":" фактически игнорируются, последовательные объявления функции "},{"attributes":{"italic":true},"insert":"перекрывают"},{"insert":" предыдущие.\nfoo(); // 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 1 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 2 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( 3 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Объявления функций, которые появляются внутри обычных блоков, обычно поднимаются в окружающей области видимости, вместо того чтобы быть условными как показывает код ниже:\nfoo(); // \"b\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = true;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"if (a) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"   function foo() { console.log( \"a\" ); }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"else {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"   function foo() { console.log( \"b\" ); }"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Однако, важно отметить, что такое поведение небезопасно и может измениться в будущих версиях JavaScript, поэтому лучше избегать объявления функций в блоках.\n\n\nГлава 5: Замыкание области видимости"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Замыкание — это когда функция умеет запоминать и имеет доступ к лексической области видимости даже тогда, когда эта функция выполняется вне своей лексической области видимости.\nДавайте посмотрим на код, который представит замыкание во всей красе:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( a );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn bar;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var baz = foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"baz(); // 2 -- Ого, замыкание только что было раскрыто, мужики!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"После выполнения "},{"attributes":{"code":true},"insert":"foo()"},{"insert":", обычно мы ожидаем, что вся внутренняя область видимости "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" целиком будет удалена, поскольку мы знаем что "},{"attributes":{"italic":true},"insert":"Движок"},{"insert":" использует "},{"attributes":{"italic":true},"insert":"сборщик мусора"},{"insert":", который исследует и освобождает память, которая больше не используется. Поскольку видно, что содержимое "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" больше не используется, кажется естественным, что оно должно быть "},{"attributes":{"italic":true},"insert":"удалено"},{"insert":" сборщиком.\n"},{"attributes":{"bold":true,"code":true},"insert":"bar()"},{"attributes":{"bold":true},"insert":" все еще содержит ссылку на эту область видимости и эта ссылка называется замыканием."},{"insert":"\n\nЦиклы + замыкание"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"for (var i=1; i<=5; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}, i*1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Сущность этого кусочка кода в том, что мы обычно "},{"attributes":{"italic":true},"insert":"ожидаем"},{"insert":" такого поведения, что в итоге будут распечатаны числа \"1\", \"2\", .. \"5\", по одному за раз, по одному в секунду соответственно.\nНа самом деле, если вы запустите этот код, вы получите вывод числа \"6\" 5 раз подряд, через односекундные интервалы.\nВсе функции обратного вызова функции timeout запускаются прямо после завершения цикла. Фактически, пока тикают таймеры, даже если это был вызов "},{"attributes":{"code":true},"insert":"setTimeout(.., 0)"},{"insert":" в каждой итерации цикла, все эти функции обратного вызова все равно будут запущены строго после выполнения цикла.\nТем путем, которым работает область видимости, все 5 этих функций, хотя они и определяются отдельно в каждой итерации цикла, все они "},{"attributes":{"bold":true},"insert":"замыкаются на одну и ту же глобальную разделяемую область видимости"},{"insert":", в которой, фактически, только одна переменная "},{"attributes":{"code":true},"insert":"i"},{"insert":".\n\nМы изучили в главе 3, что IIFE создает область видимости объявляя и сразу выполняя функцию.\nДавайте попробуем:\nfor (var i=1; i<=5; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t(function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tconsole.log( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}, i*1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"А вот и нет! Недостаточно иметь изолированную область видимости если эта область пуста. \nЕй нужна ее собственная переменная, с копией значения "},{"attributes":{"code":true},"insert":"i"},{"insert":" в каждой итерации.\nfor (var i=1; i<=5; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t(function(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tvar j = i;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tconsole.log( j );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}, j*1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Эврика! Работает!\nНебольшая вариация на тему, которую некоторые предпочтут вышеуказанной:\nfor (var i=1; i<=5; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t(function(j){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tconsole.log( j );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}, j*1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t})( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Использование IIFE внутри каждой итерации создало новую область видимости для каждой итерации, что дало обратным вызовам функции при вызове timeout возможность захватывать новую область видимости в каждой итерации, в каждой из которых есть переменная с правильным итерационным значением в ней.\n"},{"attributes":{"bold":true},"insert":"И вновь рассмотрим блочную область видимости"},{"insert":"\n"},{"attributes":{"code":true},"insert":"let"},{"insert":" \"похищает\" блок и объявляет переменную прямо в нем. Фактически она превратила блок в область видимости, которую мы можем охватить. Таким образом, следующий прекрасный код \"просто работает\":\nfor (var i=1; i<=5; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tlet j = i; // да-да, блочная область видимости для замыкания!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( j );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}, j*1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Есть особое поведение для объявлений "},{"attributes":{"code":true},"insert":"let"},{"insert":" в заголовке цикла for. Это поведение определяет, что переменная будет объявлена не один раз для всего цикла, а для каждой итерации. И, она, конечно же, будет инициализирована в каждой последующей итерации значением с окончания предыдущей итерации.\nfor (let i=1; i<=5; i++) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( i );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}, i*1000 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nМодули"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"function CoolModule() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar something = \"cool\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar another = [1, 2, 3];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction doSomething() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( something );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction doAnother() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( another.join( \" ! \" ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tdoSomething: doSomething,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tdoAnother: doAnother"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo = CoolModule();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.doSomething(); // cool"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.doAnother(); // 1 ! 2 ! 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот шаблон в JavaScript мы называем "},{"attributes":{"italic":true},"insert":"модуль"},{"insert":". Самый распространенный путь реализации шаблона модуля часто называют \"Действенный модуль\" и это тот вариант, который мы тут и представили.\nЕсть два \"требования\", которые должны выполняться для шаблона модуля:\nДолжна быть внешняя окружающая функция и она должна быть вызвана хотя бы раз (каждый раз создается новый экземпляр модуля)."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Окружающая функция должна возвращать хотя бы одну внутреннюю функцию, для того, чтобы у этой внутренней функции было замыкание на приватную область видимости и был доступ и/или возможность изменения ее внутреннего состояния."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Вышеприведенный код показывает автономный конструктор модуля с названием "},{"attributes":{"code":true},"insert":"CoolModule()"},{"insert":", который можно вызвать любое количество раз, каждый раз создавая новый экземпляр модуля. Небольшая вариация этого шаблона — это когда вы заботитесь о том, чтобы был только один экземпляр, что-то вроде \"синглтона\":\nvar foo = (function CoolModule() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar something = \"cool\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar another = [1, 2, 3];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction doSomething() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( something );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction doAnother() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( another.join( \" ! \" ) );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tdoSomething: doSomething,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tdoAnother: doAnother"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.doSomething(); // cool"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.doAnother(); // 1 ! 2 ! 3"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Тут мы превратили нашу модульную функцию в IIFE (см. главу 3), "},{"attributes":{"italic":true},"insert":"сразу же"},{"insert":" вызвали ее и присвоили возвращаемое ею значение прямо нашему единственному идентификатору "},{"attributes":{"code":true},"insert":"foo"},{"insert":".\nМодули — это всего лишь функции, поэтому они могут принимать параметры:\nfunction CoolModule(id) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction identify() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( id );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tidentify: identify"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo1 = CoolModule( \"foo 1\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var foo2 = CoolModule( \"foo 2\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo1.identify(); // \"foo 1\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo2.identify(); // \"foo 2\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Еще одна небольшая, но полнофункциональная вариация модульного шаблона — дать имя объекту, который вы возвращаете как публичное API:\nvar foo = (function CoolModule(id) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction change() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// modifying the public API"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tpublicAPI.identify = identify2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction identify1() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( id );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction identify2() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( id.toUpperCase() );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar publicAPI = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tchange: change,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tidentify: identify1"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn publicAPI;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})( \"foo module\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.identify(); // foo module"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.change();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.identify(); // FOO MODULE"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Сохраняя внутреннюю ссылку на объект публичного API внутри экземпляра модуля вы можете менять эту ссылку на модуль изнутри, включая добавление и удаление методов, свойств "},{"attributes":{"italic":true},"insert":"и"},{"insert":" изменение их значений.\n\n"},{"attributes":{"bold":true},"insert":"Будущие модули"},{"insert":"\nМодули, основанные на функциях — не статически распознаваемый шаблон (о котором знает компилятор), поэтому их семантика API не учитывается до момента времени выполнения. То есть, вы фактически можете менять API модуля в процессе выполнения кода.\nВ противоположность этому, модульное API ES6 — статическое (API не меняется во время выполнения). Поскольку компилятор "},{"attributes":{"italic":true},"insert":"это"},{"insert":" знает, он может проверить во время (загрузки файла и) компиляции, что ссылка на член API импортируемого модуля "},{"attributes":{"italic":true},"insert":"действительно существует"},{"insert":". Если ссылка на API не существует, компилятор выдаст \"заблаговременную\" ошибку на этапе компиляции, вместо того, чтобы ждать традиционного динамического разрешения ссылок во время выполнения (и ошибок, если есть).\nУ модулей ES6 нет \"встраиваемого\" формата, они должны определяться в отдельных файлах (по одному на модуль). У браузеров/движков есть \"загрузчик модулей\" по умолчанию (который может быть переопределен, но это уже далеко за пределами нашего здесь обсуждения), который синхронно загружает файл модуля, когда он импортируется.\n\nИтог"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Похоже, что знания о замыкании полны предрассудков и суеверий как загадочный мир, стоящий особняком внутри JavaScript, который могут познать только самые храбрые души. Но на самом деле — это всего лишь стандартный и почти очевидный факт о том, как писать код в среде лексической области видимости, где функции являются значениями и могут свободно передаваться куда угодно.\n"},{"attributes":{"bold":true},"insert":"Замыкание — это когда функция может запомнить и иметь доступ к своей лексической области видимости даже тогда, когда она вызывается вне своей лексической области видимости."},{"insert":"\nЗамыкания могут сбить нас с толку, например в циклах, если мы не озаботимся тем, чтобы распознавать их и то как они работают. Но они еще и являются весьма мощным инструментом, дающим доступ к шаблонам, таким как "},{"attributes":{"italic":true},"insert":"модули"},{"insert":" в их различных формах.\nМодули требуют две ключевых характеристики: 1) внешнюю функцию-обертку, которую будут вызывать, чтобы создать закрытую область видимости 2) возвращаемое значение функции-обертки должно включать в себя ссылку на не менее чем одну внутреннюю функцию, у которой потом будет замыкание на внутреннюю область видимости обертки.\nТеперь вы сможете заметить замыкания повсюду в своем существующем коде и у нас теперь есть возможность обнаруживать и использовать все их преимущества!\n\nПриложение: Динамическая область видимости"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nДинамическая область видимости означает, что есть модель, при помощи которой область видимости можно определить динамически во время выполнения, вместо статического определения при написании кода.\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( a ); // 2"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В примере выше лексическая область видимости хранит информацию о том, что RHS-ссылка на "},{"attributes":{"code":true},"insert":"a"},{"insert":" в "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" будет разрешена в глобальную переменную "},{"attributes":{"code":true},"insert":"a"},{"insert":", что приведет к тому, что будет выведено значение "},{"attributes":{"code":true},"insert":"2"},{"insert":".\nДинамическая область видимости, напротив, не интересуется тем как и где были объявлены функции и области видимости, а скорее интересуется тем откуда они будут вызываться. Иными словами, здесь цепочка областей видимости основана на стеке вызовов, а не на вложенности областей видимости в коде.\nИтак, если бы в JavaScript была динамическая область видимости, то когда выполнилась бы "},{"attributes":{"code":true},"insert":"foo()"},{"insert":", теоретически нижеприведенный код привел бы к выводу "},{"attributes":{"code":true},"insert":"3"},{"insert":".\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( a ); // 3  (not 2!)"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"function bar() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar a = 3;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var a = 2;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"bar();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"А всё потому, что когда "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" не может разрешить ссылку на переменную "},{"attributes":{"code":true},"insert":"a"},{"insert":", вместо поднятия по цепочке вложенных лексических областей видимости, она взбирается вверх по стеку вызовов, чтобы найти откуда "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" была "},{"attributes":{"italic":true},"insert":"вызвана"},{"insert":". Поскольку "},{"attributes":{"code":true},"insert":"foo()"},{"insert":" вызывалась из "},{"attributes":{"code":true},"insert":"bar()"},{"insert":", она проверяет переменные в области видимости "},{"attributes":{"code":true},"insert":"bar()"},{"insert":" и находит там "},{"attributes":{"code":true},"insert":"a"},{"insert":" со значением "},{"attributes":{"code":true},"insert":"3"},{"insert":".\nЧтобы внести ясность, "},{"attributes":{"bold":true},"insert":"в JavaScript нет, на самом деле, динамической области видимости"},{"insert":". "},{"attributes":{"bold":true},"insert":"В нем есть лексическая область видимости."},{"insert":" Но механизм работы "},{"attributes":{"code":true},"insert":"this"},{"insert":" немного похож на динамическую область видимости.\nКлючевое сравнение: "},{"attributes":{"bold":true},"insert":"лексическая область видимости определяется временем написания кода, тогда как динамическая область видимости (и "},{"attributes":{"bold":true,"code":true},"insert":"this"},{"attributes":{"bold":true},"insert":"!) определяется во время выполнения"},{"insert":". Лексическую область видимости интересует "},{"attributes":{"italic":true},"insert":"где функция была объявлена"},{"insert":", а динамическую — "},{"attributes":{"italic":true},"insert":"откуда была вызвана"},{"insert":" функция.\nИ наконец: "},{"attributes":{"code":true},"insert":"this"},{"insert":" интересует "},{"attributes":{"italic":true},"insert":"как была вызвана функция"},{"insert":", что показывает как близко связаны механизм "},{"attributes":{"code":true},"insert":"this"},{"insert":" с идеей динамической области видимости. \n\nПриложение: Лексический this"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"var obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tid: \"awesome\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function coolFn() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tconsole.log( this.id );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var id = \"not awesome\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.cool(); // awesome"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"setTimeout( obj.cool, 100 ); // not awesome"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Этот код страдает от одной проблемы - потеря привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":" в функции "},{"attributes":{"code":true},"insert":"cool()"},{"insert":". Есть разные пути решения этой проблемы, но наиболее частое решение — "},{"attributes":{"code":true},"insert":"var self = this;"},{"insert":". Выглядит это примерно так:\nvar obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcount: 0,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function coolFn() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tvar self = this;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (self.count < 1) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\tself.count++;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\tconsole.log( \"красиво?\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t}, 100 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.cool(); // красиво?"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"code":true},"insert":"var self = this"},{"insert":" всего лишь избавляется целиком от всей проблемы понимания и правильного использования привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":", а взамен возвращается к лексической области видимости.\nБолее подходящий подход, с моей точки зрения, к этой \"проблеме\", использовать и рассматривать механизм "},{"attributes":{"code":true},"insert":"this"},{"insert":" правильно.\nvar obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcount: 0,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function coolFn() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (this.count < 1) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tsetTimeout( function timer(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\tthis.count++; // `this` безопасен из-за `bind(..)`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\tconsole.log( \"еще красивее\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t}.bind( this ), 100 ); // смотри, `bind()`!"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.cool(); // еще красивее "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nES6 добавляет особую синтаксическую форму объявления функции, названную \"стрелочная функция\". Решение в ES6, стрелочная функция, вводит поведение, называемое \"лексический this\".\nvar obj = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcount: 0,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tcool: function coolFn() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tif (this.count < 1) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\tsetTimeout( () => { // стрелочная функция, выигрышный вариант?"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\tthis.count++;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t\tconsole.log( \"красиво?\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t\t}, 100 );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj.cool(); // красиво?"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Стрелочные функции ведут себя совсем не как обычные функции в том, что касается их привязки к "},{"attributes":{"code":true},"insert":"this"},{"insert":". Они отбрасывают все обычные правила для привязки "},{"attributes":{"code":true},"insert":"this"},{"insert":", а взамен берут значение "},{"attributes":{"code":true},"insert":"this"},{"insert":" из их непосредственной окружающей области видимости, неважно из какой.\nЧто бы вы ни предпочли: новое поведение лексического "},{"attributes":{"code":true},"insert":"this"},{"insert":" стрелочных функций или испытанный и верный "},{"attributes":{"code":true},"insert":"bind()"},{"insert":", важно отметить, что стрелочные функции — не только сокращение написания \""},{"attributes":{"italic":true},"insert":"function"},{"insert":"\".\n\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"http://en.wikipedia.org/wiki/Principle_of_least_privilege"},"insert":"Принцип наименьших привилегий"},{"insert":"\n\nИсточник"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/README.md#%D0%92%D1%8B-%D0%BD%D0%B5-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-js-%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%B8-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F"},"insert":"https://github.com/azat-io/you-dont-know-js-ru/blob/master/scope%20%26%20closures/README.md#%D0%92%D1%8B-%D0%BD%D0%B5-%D0%B7%D0%BD%D0%B0%D0%B5%D1%82%D0%B5-js-%D0%9E%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%B8-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F"},{"insert":"\n\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('11/10/2019, 08:05:16', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Оператор Тильда ~ в JS"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Оператор "},{"attributes":{"code":true},"insert":"~"},{"insert":" в JavaScript является оператором побитового НЕ .\n Если вы редко работаете с бинарными данными, то для вас это мало о чём говорит. Например, цифра 8 выглядит в двоичной системе : 1000. Когда вы используете ~ на этой цифре, она преобразует каждый бит в противоположное значение. То есть, каждая из 1 станет 0 и наоборот. Так ~8 будет равно 7, двоичное представление которого выглядит следующим образом : 0111. Единственная проблема заключается в том, что JavaScript использует то, что называется «"},{"attributes":{"link":"https://en.wikipedia.org/wiki/Two%27s_complement"},"insert":"Two''s Complement"},{"insert":"», чтобы иметь возможность представлять положительные и отрицательные числа в двоичном формате. Поэтому в джаваскрипте ~7 будет равно -8.\n Если вы хотите получить более внятную картину, то вам лучше всего потестировать этот оператор самостоятельно (можно в той же консоле браузера), а так же посмотрите примеры ниже.\nПримеры использования ~ в javascript"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":" Тильда получила наиболее широкое применение при поиске значения в массиве. Классически оно выглядит так:\nif (arr.indexOf(item) >= 0) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // item найден в массиве"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} else {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // не найден"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\nЭта же логика, но уже с тильдой, принимает более короткий вариант записи:\nif (~arr.indexOf(item)) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // item найден в массиве"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"} else {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    // не найден"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\nОкругление вниз"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":" Можно встретить код когда две тильды подрят "},{"attributes":{"code":true},"insert":"~~"},{"insert":" используют вместо Math.floor( ) для округления дробных чисел вниз до целого числа:\nconsole.log(~~14.65); // 14"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log(~~(-21.72); // -21"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\nНо обратите внимание что делает одинарная тильда с дробными числами:\nconsole.log(~14.65); // -15"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"console.log(~(-14.65)); // -13"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\nПоэтому прежде чем применять тильду, нужно быть уверенным и понимать что вы делаете.\nПреобразования строки в число"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":" Всем известно, что в javascript число + строка в результате вернёт строку:\nconsole.log(2 + ''3''); // вернёт ''23''"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\n Поэтому в JavaScript, чтобы приобразовать строку к числу, применяют унарный плюс:\nconsole.log(2 + +''3''); // вернёт 5"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\n Эту же операцию можно произвести поставив две тильды ~~\nconsole.log(2 + ~~''3''); // вернёт 5"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Копировать\n Но не стоит неосознанно тыкать тильды в код и забывать, что при преобразовании строки к числу при помощи тильд происходит также округление:\nconsole.log(5 + ~~''3.25''); // → 8"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"link":"https://inter-net.pro/javascript/tilda"},"insert":"https://inter-net.pro/javascript/tilda"},{"insert":"\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('27/09/2019, 19:02:22', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('23/10/2019, 09:05:22', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Вы не знаете JS: Начните и Совершенствуйтесь"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Конспект по первой из книг You Don''t Know JS: Up & Going"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://github.com/azat-io/you-dont-know-js-ru/raw/master/up%20%26%20going/cover.jpg"}}},{"insert":"Глава 1: Введение в программирование"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Обычно утверждают, что JavaScript — "},{"attributes":{"italic":true},"insert":"интерпретируемый"},{"insert":", так как ваш исходный код на JavaScript обрабатывается каждый раз, когда запускается. Но это не совсем точно. Движок JavaScript на самом деле "},{"attributes":{"italic":true},"insert":"компилирует"},{"insert":" программу на лету и затем сразу же запускает скомпилированный код.\n\nКомментарии должны объяснять "},{"attributes":{"italic":true},"insert":"почему"},{"insert":", а не "},{"attributes":{"italic":true},"insert":"что"},{"insert":". Они могут дополнительно объяснять "},{"attributes":{"italic":true},"insert":"как"},{"insert":", когда код особенно сложен.\n\nОператор "},{"attributes":{"code":true},"insert":"if"},{"insert":" ожидает "},{"attributes":{"code":true},"insert":"логическое значение"},{"insert":", но если вы передадите что-либо отличное от "},{"attributes":{"code":true},"insert":"логического значения"},{"insert":", произойдет неявное приведение типов.\nJavaScript определяет список особых значений, которые считаются «как бы ложными», так как при приведении к "},{"attributes":{"code":true},"insert":"логическому значению"},{"insert":" они примут значение "},{"attributes":{"code":true},"insert":"false"},{"insert":"; такой список включает в себя "},{"attributes":{"code":true},"insert":"0"},{"insert":" и "},{"attributes":{"code":true},"insert":"\"\""},{"insert":". Любое другое значение, не входящее в список «как бы ложных», автоматически считается «как бы истинным»: при приведении к "},{"attributes":{"code":true},"insert":"логическому значению"},{"insert":" оно становится равным "},{"attributes":{"code":true},"insert":"true"},{"insert":". Истинными, например, являются значения "},{"attributes":{"code":true},"insert":"99.99"},{"insert":" и "},{"attributes":{"code":true},"insert":"\"free\""},{"insert":".\n\nВ JavaScript типизированные значения, а не типизированные переменные. Только у значений есть типы в JavaScript, переменные являются всего лишь контейнерами для этих значений."},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"\nГлава 2: Введение в JavaScript"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nЗначения и типы"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"code":true},"insert":"typeof null"},{"insert":" — это интересный случай, так как он ошибочно возвращает "},{"attributes":{"code":true},"insert":"\"object\""},{"insert":", тогда как вы ожидали бы, что он вернет "},{"attributes":{"code":true},"insert":"\"null\""},{"insert":".\n"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Объекты"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Свойства могут быть доступны либо через "},{"attributes":{"italic":true},"insert":"точечную нотацию"},{"insert":" (т.е. "},{"attributes":{"code":true},"insert":"obj.a"},{"insert":"), либо через "},{"attributes":{"italic":true},"insert":"скобочную нотацию"},{"insert":" (т.е. "},{"attributes":{"code":true},"insert":"obj[\"a\"]"},{"insert":"). Точечная нотация короче и в целом легче для чтения, и, следовательно, ей следует по возможности отдавать предпочтение.\n"},{"attributes":{"bold":true},"insert":"Массивы"},{"insert":"\nПоскольку массивы — это особые объекты (как намекает "},{"attributes":{"code":true},"insert":"typeof"},{"insert":"), то у них могут быть свойства, включая автообновляемое свойство "},{"attributes":{"code":true},"insert":"length"},{"insert":" (длина).\nТеоретически, вы можете использовать массив как обычный объект со своими собственными именованными свойствами\n\nМетоды встроенных типов"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nКак бы истинный и ложный"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Особый список \"как бы ложных\" значений в JavaScript таков:\n"},{"attributes":{"code":true},"insert":"\"\""},{"insert":" (пустая строка)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"0"},{"insert":", "},{"attributes":{"code":true},"insert":"-0"},{"insert":", "},{"attributes":{"code":true},"insert":"NaN"},{"insert":" (некорректное "},{"attributes":{"code":true},"insert":"число"},{"insert":")"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"null"},{"insert":", "},{"attributes":{"code":true},"insert":"undefined"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"false"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Любое значение, не входящее в этот список — \"как бы истинно.\" Вот несколько примеров:\n"},{"attributes":{"code":true},"insert":"\"hello\""},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"42"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"true"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"[ ]"},{"insert":", "},{"attributes":{"code":true},"insert":"[ 1, \"2\", 3 ]"},{"insert":" (массивы)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"{ }"},{"insert":", "},{"attributes":{"code":true},"insert":"{ a: 42 }"},{"insert":" (объекты)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"function foo() { .. }"},{"insert":" (функции)"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"\nРавенство"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Использовать "},{"attributes":{"code":true},"insert":"=="},{"insert":" или "},{"attributes":{"code":true},"insert":"==="},{"insert":":\nЕсли одно из значений (т.е. сторона) в сравнении может быть значением "},{"attributes":{"code":true},"insert":"true"},{"insert":" или "},{"attributes":{"code":true},"insert":"false"},{"insert":", избегайте "},{"attributes":{"code":true},"insert":"=="},{"insert":" и используйте "},{"attributes":{"code":true},"insert":"==="},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Если одно из значений в сравнении может быть одним из этих особых значений ("},{"attributes":{"code":true},"insert":"0"},{"insert":", "},{"attributes":{"code":true},"insert":"\"\""},{"insert":" или "},{"attributes":{"code":true},"insert":"[]"},{"insert":" — пустой массив), избегайте "},{"attributes":{"code":true},"insert":"=="},{"insert":" и используйте "},{"attributes":{"code":true},"insert":"==="},{"insert":"."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Во "},{"attributes":{"italic":true},"insert":"всех"},{"insert":" остальных случаях вы можете безопасно использовать "},{"attributes":{"code":true},"insert":"=="},{"insert":". Это не только безопасно, но во многих случаях это упрощает ваш код путем повышения читаемости."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Правила сравнения непримитивных значения, таких как "},{"attributes":{"code":true},"insert":"object"},{"insert":" (включая "},{"attributes":{"code":true},"insert":"function"},{"insert":" и "},{"attributes":{"code":true},"insert":"array"},{"insert":") просто проверяет равны ли ссылки, но ничего не сделают касаемо самих значений.\nНапример, "},{"attributes":{"code":true},"insert":"массив"},{"insert":" по умолчанию приводится к "},{"attributes":{"code":true},"insert":"строке"},{"insert":" простым присоединением всех значений с запятыми ("},{"attributes":{"code":true},"insert":","},{"insert":") между ними. Можно было бы подумать, что эти два "},{"attributes":{"code":true},"insert":"массива"},{"insert":" с одинаковым содержимым будут равны по "},{"attributes":{"code":true},"insert":"=="},{"insert":", но это не так:\nvar a = [1,2,3];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = [1,2,3];"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c = \"1,2,3\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a == c;\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b == c;\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a == b;\t\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nНеравенство"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Примечательно, что нет операций \"строгого неравенства\", которые запрещали бы приведение таким же путем как и \"строгое равенство\" "},{"attributes":{"code":true},"insert":"==="},{"insert":".\nПример:\nvar a = 41;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = \"42\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var c = \"43\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a < b;\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"b < c;\t\t// true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"В разделе 11.8.5 спецификации ES5 говорится, что, если оба значения в сравнении "},{"attributes":{"code":true},"insert":"<"},{"insert":" являются "},{"attributes":{"code":true},"insert":"строками"},{"insert":", как это было в случае с "},{"attributes":{"code":true},"insert":"b < c"},{"insert":", то сравнение производится лексикографически (т.е. в алфавитном порядке, как в словаре), но если одно или оба значения не являются "},{"attributes":{"code":true},"insert":"строками"},{"insert":", как в случае с "},{"attributes":{"code":true},"insert":"a < b"},{"insert":", то оба значения приводятся к "},{"attributes":{"code":true},"insert":"числу"},{"insert":", и происходит типичное числовое сравнение.\nvar a = 42;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var b = \"foo\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a < b;\t\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a > b;\t\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a == b;\t\t// false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Так как значение "},{"attributes":{"code":true},"insert":"b"},{"insert":" приводится к \"некорректному числовому значению\" "},{"attributes":{"code":true},"insert":"NaN"},{"insert":", а спецификация говорит, что "},{"attributes":{"code":true},"insert":"NaN"},{"insert":" не больше и не меньше, чем любое другое значение."},{"attributes":{"blockBlockquote":true},"insert":"\n"},{"insert":"\nПеременные"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Области видимости функций"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Если вы попытаетесь установить значение переменной, которая еще не объявлена, все либо закончится тем, что переменная создастся в самой верхней глобальной области видимости (плохо!), либо получите ошибку в зависимости от \"строгого режима\" (см. \"Строгий режим\"). Давайте взглянем:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta = 1;\t// `a` формально не объявлена"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"a;\t\t\t// 1 — упс, автоматическая глобальная переменная :("},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Это очень плохая практика. Не делайте так! Всегда явно объявляйте свои переменные.\n\nСтрогий режим (Strict Mode)"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Всего одно ключевое отличие (улучшение!) строго режима — запрет автоматического неявного объявления глобальных переменных из-за пропускаvar:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\"use strict\";\t// включить строгий режим"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\ta = 1;\t\t\t// `var` missing, ReferenceError"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo();"},{"attributes":{"code-block":true},"insert":"\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Функции как значения"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"var foo = function() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// .."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var x = function bar(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// .."},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Первое функциональное выражение, присваиваемое переменной "},{"attributes":{"code":true},"insert":"foo"},{"insert":", называется "},{"attributes":{"italic":true},"insert":"анонимным"},{"insert":" поскольку у него нет "},{"attributes":{"code":true},"insert":"имени"},{"insert":".\n\nВыражения немедленно вызываемых функций (Immediately Invoked Function Expressions (IIFEs))"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Функции IIFE также могут возвращать значения:\nvar x = (function IIFE(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn 42;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"})();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"x;\t// 42"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Значение "},{"attributes":{"code":true},"insert":"42"},{"insert":" "},{"attributes":{"code":true},"insert":"возвращается"},{"insert":" из выполненной "},{"attributes":{"code":true},"insert":"IIFE"},{"insert":" функции, а затем присваивается в "},{"attributes":{"code":true},"insert":"x"},{"insert":".\n\nЗамыкание"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Вы можете думать о замыкании как о способе \"запомнить\" и продолжить работу в области видимости функции (с ее переменными) даже когда функция уже закончила свою работу.\nПроиллюстрируем:\nfunction makeAdder(x) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// параметр `x` - внутренняя переменная"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// внутренняя функция `add()` использует `x`, поэтому"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t// у нее есть \"замыкание\" на нее"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction add(y) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\treturn y + x;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn add;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"bold":true},"insert":"Модули"},{"insert":"\nСамое распространенное использование замыкания в JavaScript — это модульный шаблон. Модули позволяют определять частные детали реализации (переменные, функции), которые скрыты от внешнего мира, а также публичное API, которое "},{"attributes":{"italic":true},"insert":"доступно"},{"insert":" снаружи.\nПредставим:\nfunction User(){"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar username, password;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfunction doLogin(user,pw) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tusername = user;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tpassword = pw;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\t// сделать остальную часть работы по логину"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tvar publicAPI = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t\tlogin: doLogin"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\t};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\treturn publicAPI;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"// создать экземпляр модуля `User`"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var fred = User();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"fred.login( \"fred\", \"12Battery34!\" );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nИдентификатор "},{"attributes":{"code":true},"insert":"this"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Важно понимать, что "},{"attributes":{"code":true},"insert":"this"},{"insert":" "},{"attributes":{"italic":true},"insert":"не"},{"insert":" ссылается на саму функцию, хотя это самое распространенное неверное представление.\nВот краткая иллюстрация:\nfunction foo() {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tconsole.log( this.bar );"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var bar = \"global\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj1 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbar: \"obj1\","},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tfoo: foo"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var obj2 = {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\tbar: \"obj2\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"};"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"//--------"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo();\t\t\t\t// \"global\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"obj1.foo();\t\t\t// \"obj1\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"foo.call( obj2 );\t// \"obj2\""},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"new foo();\t\t\t// undefined"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Есть четыре правила того, как устанавливается "},{"attributes":{"code":true},"insert":"this"},{"insert":", и они показаны в этих четырех последних строках кода.\n"},{"attributes":{"code":true},"insert":"foo()"},{"insert":" присваивает в "},{"attributes":{"code":true},"insert":"this"},{"insert":" ссылку на глобальный объект в нестрогом режиме. В строгом режиме, "},{"attributes":{"code":true},"insert":"this"},{"insert":" будет "},{"attributes":{"code":true},"insert":"undefined"},{"insert":", и вы получите ошибку при доступе к свойству "},{"attributes":{"code":true},"insert":"bar"},{"insert":", поэтому "},{"attributes":{"code":true},"insert":"\"global\""},{"insert":" — это значение для "},{"attributes":{"code":true},"insert":"this.bar"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"obj1.foo()"},{"insert":" устанавливает "},{"attributes":{"code":true},"insert":"this"},{"insert":" в объект "},{"attributes":{"code":true},"insert":"obj1"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"foo.call(obj2)"},{"insert":" устанавливает "},{"attributes":{"code":true},"insert":"this"},{"insert":" в объект "},{"attributes":{"code":true},"insert":"obj2"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"code":true},"insert":"new foo()"},{"insert":" устанавливает "},{"attributes":{"code":true},"insert":"this"},{"insert":" в абсолютно новый пустой объект."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"\n\n----\n*Дополнительно"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\nvoid 0"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Это эквивалентно "},{"attributes":{"code":true},"insert":"undefined"},{"insert":".\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВременные ссылки\n"},{"attributes":{"link":"https://smartprogress.do/goal/315629/?lang=ru"},"insert":"https://smartprogress.do/goal/315629/?lang=ru"},{"insert":"\n"},{"attributes":{"link":"https://toster.ru/q/396641"},"insert":"https://toster.ru/q/396641"},{"insert":"\n"},{"attributes":{"link":"https://rkuzovlev.github.io/ydkjs/"},"insert":"https://rkuzovlev.github.io/ydkjs/"},{"insert":"\n"},{"attributes":{"link":"https://medium.com/devschacht/kyle-simpson-you-dont-know-js-async-performance-2d8cfa7cb6df"},"insert":"https://medium.com/devschacht/kyle-simpson-you-dont-know-js-async-performance-2d8cfa7cb6df"},{"insert":"\n"},{"attributes":{"link":"https://github.com/devSchacht/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md"},"insert":"https://github.com/devSchacht/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch1.md"},{"insert":"\n\nИсточники"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"attributes":{"link":"https://www.amazon.com/gp/product/B07FK9VBD7/?ie=UTF8&%2AVersion%2A=1&%2Aentries%2A=0"},"insert":"Книги на amazon (en)"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/azat-io/you-dont-know-js-ru"},"insert":"Переводы на русском языке"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('16/09/2019, 08:20:01', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Алгоритмы"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"\n"},{"attributes":{"link":"https://algorithm-visualizer.org/"},"insert":"https://algorithm-visualizer.org/"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://code.tutsplus.com/series/data-structures-succinctly-part-1--cms-551"},"insert":"https://code.tutsplus.com/series/data-structures-succinctly-part-1--cms-551"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://habr.com/ru/company/datalaboratory/blog/311210/"},"insert":"https://habr.com/ru/company/datalaboratory/blog/311210/"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://www.smashingmagazine.com/2017/01/algorithm-driven-design-how-artificial-intelligence-changing-design/?utm_source=forwebdev&utm_medium=announcement&utm_campaign=dizayn--upravlyaemyy-algoritmami-yuriy-ve"},"insert":"https://www.smashingmagazine.com/2017/01/algorithm-driven-design-how-artificial-intelligence-changing-design/?utm_source=forwebdev&utm_medium=announcement&utm_campaign=dizayn--upravlyaemyy-algoritmami-yuriy-ve"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://community.risingstack.com/opencv-tutorial-computer-vision-with-node-js/?utm_source=forwebdev&utm_medium=announcement&utm_campaign=ispolzuem-biblioteku-opencv-v-node.js-d"},"insert":"https://community.risingstack.com/opencv-tutorial-computer-vision-with-node-js/?utm_source=forwebdev&utm_medium=announcement&utm_campaign=ispolzuem-biblioteku-opencv-v-node.js-d"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://medium.com/devschacht/nicholas-c-zakas-computer-science-in-javascript-quicksort-afa07c0a47f0"},"insert":"https://medium.com/devschacht/nicholas-c-zakas-computer-science-in-javascript-quicksort-afa07c0a47f0"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://vk.com/doc123534285_444805173?hash=37ac2a8e392fe99a47&dl=303c49e62d35ee977a"},"insert":"https://vk.com/doc123534285_444805173?hash=37ac2a8e392fe99a47&dl=303c49e62d35ee977a"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/egonSchiele/grokking_algorithms/blob/master/06_breadth-first_search/ts/01_breadth-first_search.ts"},"insert":"https://github.com/egonSchiele/grokking_algorithms/blob/master/06_breadth-first_search/ts/01_breadth-first_search.ts"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://vk.com/doc320535556_468898373?hash=0d71fc7053f42b5169&dl=4885c71d4d23073463"},"insert":"https://vk.com/doc320535556_468898373?hash=0d71fc7053f42b5169&dl=4885c71d4d23073463"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://vk.com/doc123534285_444805179?hash=a31140d631d9238a0a&dl=d349cea574b033c9c5"},"insert":"https://vk.com/doc123534285_444805179?hash=a31140d631d9238a0a&dl=d349cea574b033c9c5"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://tutorialzine.com/2017/04/10-machine-learning-examples-in-javascript?utm_source=forwebdev_tlgrm&utm_medium=announcement&utm_campaign=desyat-primerov-algoritmov-mashinnogo-obu"},"insert":"https://tutorialzine.com/2017/04/10-machine-learning-examples-in-javascript?utm_source=forwebdev_tlgrm&utm_medium=announcement&utm_campaign=desyat-primerov-algoritmov-mashinnogo-obu"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://proglib.io/p/sorting-guide/"},"insert":"https://proglib.io/p/sorting-guide/"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"http://www.thatjsdude.com/interview/js1.html"},"insert":"http://www.thatjsdude.com/interview/js1.html"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/jiayihu/pretty-algorithms"},"insert":"https://github.com/jiayihu/pretty-algorithms"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://medium.com/@mad8/%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BD%D0%B0%D0%B1%D0%BE%D1%80-javascript-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85-ba45845afa36"},"insert":"https://medium.com/@mad8/%D0%B1%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B9-%D0%BD%D0%B0%D0%B1%D0%BE%D1%80-javascript-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D1%8E%D1%89%D0%B8%D1%85-ba45845afa36"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://proglib.io/p/required-programmer-algorithms/"},"insert":"https://proglib.io/p/required-programmer-algorithms/"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://ncase.me/joy/getting-started/"},"insert":"https://ncase.me/joy/getting-started/"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html"},"insert":"https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/trekhleb/javascript-algorithms"},"insert":"https://github.com/trekhleb/javascript-algorithms"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://egghead.io/courses/data-structures-and-algorithms-in-javascript"},"insert":"https://egghead.io/courses/data-structures-and-algorithms-in-javascript"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://proglib.io/p/data-structure-algorithms/"},"insert":"https://proglib.io/p/data-structure-algorithms/"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/getting-started/ch1.md"},"insert":"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/getting-started/ch1.md"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/FAQGURU/FAQGURU/blob/master/topics/ru/javascript.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-javascript"},"insert":"https://github.com/FAQGURU/FAQGURU/blob/master/topics/ru/javascript.md#%D1%87%D1%82%D0%BE-%D1%82%D0%B0%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-javascript"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('13/06/2019, 16:19:52', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Сравнение"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"attributes":{"link":"https://github.com/Polymer/lit-element"},"insert":"lit-element"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Одна из проблем, это сильная завязанность на определенный рендер, он не идеален и в итоге ряд проблем получается из-за него, к примеру, "},{"attributes":{"link":"https://github.com/Polymer/lit-element/issues/390"},"insert":"компиляция с помощью rollup "},{"insert":".\n\n\n\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('29/05/2019, 08:58:54', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('18/02/2020, 16:46:31', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"entrypoint"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockDescription":true},"insert":"\n"},{"insert":"Запустить все контейнеры из файла "},{"attributes":{"italic":true},"insert":"docker-compose.yml "},{"insert":"(флаг "},{"attributes":{"code":true},"insert":"-d"},{"insert":" режим в фоне, "},{"attributes":{"code":true},"insert":"--build"},{"insert":" если необходимо пересобрать конейнеры, собранные локально)\n "},{"attributes":{"code":true},"insert":"docker-compose up -d"},{"insert":"\nЗапустить только "},{"attributes":{"bold":true},"insert":"consul"},{"insert":" из файла "},{"attributes":{"italic":true},"insert":"docker-compose.yml"},{"insert":"\n "},{"attributes":{"code":true},"insert":"docker-compose up -d consul"},{"insert":"\nОстановка контейнеров из файла "},{"attributes":{"italic":true},"insert":"docker-compose.yml"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker-compose stop"},{"insert":"\nОстановка и удаление контейнеров из файла "},{"attributes":{"italic":true},"insert":"docker-compose.yml"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker-compose down"},{"insert":"\nСобрать все контейнеры из файла "},{"attributes":{"italic":true},"insert":"docker-compose.yml"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker-compose build"},{"insert":"\nОбновить (стянуть новые версии) контейнеры из файла "},{"attributes":{"italic":true},"insert":"docker-compose.yml"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker-compose pull"},{"insert":"\nЗалогиниться в репозитории\n"},{"attributes":{"code":true},"insert":"docker login gitlab-dev.ispsystem.net:5005"},{"insert":"\nЗайти в контейнер по ID\n"},{"attributes":{"code":true},"insert":"docker exec -it 23332932ce91 bash"},{"insert":"\nПроверить проброшенные порты для контейнера по ID\n"},{"attributes":{"code":true},"insert":"docker port 23332932ce91"},{"insert":"\nПросмотр логов запущенного контейнера\n"},{"attributes":{"code":true},"insert":"docker-compose logs -f consul"},{"insert":"\nСписок сетй для контейнеров\n"},{"attributes":{"code":true},"insert":"docker network ls"},{"insert":"\n\n\nДругие полезные команды:\n"},{"attributes":{"code":true},"insert":"docker ps -a -q -f status=exited"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker network inspect bridge"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker run -it --rm prakhar1989/foodtrucks-web bash"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker network create foodtrucks"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker stop (docker ps -q)"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker rm (docker ps -a -q)"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker stop 8c591f6c92bd"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker rm 8c591f6c92bd"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker ps"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker restart 8c591f6c92bd"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker container logs 3db2de0b3b56"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker-compose logs -f"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker-compose down"},{"insert":"\n"},{"attributes":{"code":true},"insert":"docker stack deploy"},{"insert":"\n\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('16/05/2019, 21:06:29', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Дизайн GraphQL-схем"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"\nСсылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://github.com/nodkz/conf-talks/tree/master/articles/graphql/schema-design#rule-1.1"},"insert":"Дизайн GraphQL-схем — делаем АПИ удобным, предотвращаем боль и страдания"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://graphqlmastery.com/blog/graphql-list-how-to-use-arrays-in-graphql-schema"},"insert":"GraphQL List - How to use arrays in GraphQL schema (GraphQL Modifiers)"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://help.shopify.com/en/api/custom-storefronts/storefront-api/graphql-explorer"},"insert":"GraphQL Explorer"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://github.com/Shopify/graphql-design-tutorial/blob/master/TUTORIAL.md"},"insert":"Tutorial: Designing a GraphQL API"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('16/05/2019, 19:11:00', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Чемпионат по програм­миро­ванию"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"\nОсновные ссылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://yandex.ru/championship/"},"insert":"Сайт визитка"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://habr.com/ru/company/yandex/blog/414997/"},"insert":"ML-Блиц: разбор задач первого квалификационного раунда"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://habr.com/ru/company/yandex/blog/340784/"},"insert":"Яндекс.Блиц. 12 алгоритмических задач отборочного раунда и их разборы"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://contest.yandex.ru/contest/3/enter/"},"insert":"Яндекс Контекст"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://contest.yandex.ru/hiring/errors/"},"insert":"Яндекс Контекст. Значения ошибок, возвращаемых проверяющей системой"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://toster.ru/q/616376"},"insert":"Yandex Contest - один из примеров (как избавиться от ошибки Memory Limit/Time Limit)"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://yandex.ru/support/contest/tasks.html"},"insert":"Яндекс Контекст. Помощь"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://habr.com/ru/company/yandex/blog/430560/"},"insert":"Фронтенд, алгоритмы и опоссум Фридрих. Разбираем задачи конкурса Яндекса"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://habr.com/ru/post/353662/"},"insert":"Как я проходил тестовое задание на летнюю стажировку в Яндекс"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"\nNode.js как язык решения задач"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://toster.ru/q/382469"},"insert":"nodejs ввод из консоли типа cin или input"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"attributes":{"link":"https://nodejs.org/api/readline.html"},"insert":"Readline"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"\nПримеры кода"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Стандартный ввод и вывод:\nconst readline = require(''readline'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"const rl = readline.createInterface({"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  input: process.stdin,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  // output: process.stdout,"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  // terminal: true"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  terminal: false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"});"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"rl.on(''line'', (line) => {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  const sum = line.split('' '').reduce(function (sum, current) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    return Number(sum) + Number(current);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  }, 0);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  // rl.write(String(sum));"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  process.stdout.write(String(sum));"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  rl.close();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nВвод и вывод в через файл:\nconst fs = require(''fs'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"const readline = require(''readline'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"const rl = readline.createInterface({"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  input: fs.createReadStream(''input.txt''),"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  terminal: false"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"});"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"const fd = fs.openSync(''output.txt'', ''w'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"rl.on(''line'', (line) => {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  const sum = line.split('' '').reduce(function (sum, current) {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"    return Number(sum) + Number(current);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  }, 0);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  fs.writeSync(fd, String(sum));"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  rl.close();"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"});"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\n\n\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('17/04/2019, 21:41:27', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Frontend digests"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Если вы только начинаете или уже многое знаете из мира фронтенда, но чувствуете, что вся информация смешалась и перепуталась то сайт MDN точно для вас "},{"attributes":{"link":"https://developer.mozilla.org/ru/docs/Learn"},"insert":"https://developer.mozilla.org/ru/docs/Learn"},{"insert":". А справочник MDN поможет найти информацию на почти любые темы из мира Web."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Небольшой инструмент от Google для простой визиализации данных в формате GIF "},{"attributes":{"link":"https://t.co/gczoxRfwgo?amp=1"},"insert":"link: https://datagifmaker.withgoogle.com/"},{"insert":". Пригодится, если нужно сделать анимированную диаграмму, быстро и просто."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Для тех кто уже знаком с фреймворком Angular, но ещё не до конца понял что нового принесла его 7-я версия блог разработчиков - лучшее место чтобы в этом разобраться "},{"attributes":{"link":"https://blog.angular.io/version-7-of-angular-cli-prompts-virtual-scroll-drag-and-drop-and-more-c594e22e7b8c"},"insert":"https://blog.angular.io/version-7-of-angular-cli-prompts-virtual-scroll-drag-and-drop-and-more-c594e22e7b8c"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Очень большая статья Джейка Арчибальда про то, чей сайт формулы 1 самый быстрый "},{"attributes":{"link":"https://jakearchibald.com/2019/f1-perf/"},"insert":"https://jakearchibald.com/2019/f1-perf/"},{"insert":". Спойлер - команда Шумахера не победила."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"VS Code can do that?! Набор практик работы Visual Studio Code в формате небольших видео. Помогут повысить производительность и сделают программирование в этой IDE ещё более приятным "},{"attributes":{"link":"https://t.co/iYWp3xCbzU?amp=1"},"insert":"https://vscodecandothat.com/"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Знаете что такое Node.js? Нет, тогда за 90 минут этого видео можете не только узнать об его основах, но и посмотрите на примере, как создать HTTP сервер и развернуть его на Heroku "},{"attributes":{"link":"https://t.co/TxZ39qoZDJ?amp=1"},"insert":"https://youtu.be/fBNz5xF-Kx4"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"В любой непонятной ситуации запускай отладку. Как это сделать браузере Chrome поможет эта статья. Часть 1 "},{"attributes":{"link":"https://css-live.ru/faq/prokachivaem-navyki-otladki-s-pomoshhyu-instrumentov-razrabotchika-chrome-chast-1.html"},"insert":"https://css-live.ru/faq/prokachivaem-navyki-otladki-s-pomoshhyu-instrumentov-razrabotchika-chrome-chast-1.html"},{"insert":" и часть 2 "},{"attributes":{"link":"https://css-live.ru/faq/prokachivaem-navyki-otladki-s-pomoshhyu-instrumentov-razrabotchika-chrome-chast-2.html."},"insert":"https://css-live.ru/faq/prokachivaem-navyki-otladki-s-pomoshhyu-instrumentov-razrabotchika-chrome-chast-2.html."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Статья про отладку CSS в браузере Firefox "},{"attributes":{"link":"https://blog.logrocket.com/firefox-devtools-for-css-authors-1511f41d1e3"},"insert":"https://blog.logrocket.com/firefox-devtools-for-css-authors-1511f41d1e3"},{"insert":". При разработке веб-приложений не забывайте заглядывать в разные браузеры, это поможет пользователям получать лучший опыт от работы с вашими продуктами."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"Вадим Горбачёв в своей статье рассматривает уязвимости процесса аутентификации на примерах из реальной жизни "},{"attributes":{"link":"https://medium.com/devschacht/%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7-%D1%83%D1%8F%D0%B7%D0%B2%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-475b749fbb9f"},"insert":"https://medium.com/devschacht/%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7-%D1%83%D1%8F%D0%B7%D0%B2%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B5%D0%B9-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D0%B0-%D0%B0%D1%83%D1%82%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D0%B8-475b749fbb9f"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"},{"insert":"В чем я не шарю в 2018 - откровение Даниила Абрамова, одного из ключевых разработчиков React.js "},{"attributes":{"link":"https://overreacted.io/ru/things-i-dont-know-as-of-2018/"},"insert":"https://overreacted.io/ru/things-i-dont-know-as-of-2018/"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('15/04/2019, 22:55:56', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Шаблоны для создания веб компонентов"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Typed HTML templates using TypeScript''s TSX files - "},{"attributes":{"link":"https://github.com/wisercoder/uibuilder"},"insert":"https://github.com/wisercoder/uibuilder"},{"attributes":{"list":{"type":"ordered","start":"0"}},"insert":"\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('30/03/2019, 23:13:45', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Клиентские плагины"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Техническая реализация"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"\nОбщие ссылки"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://www.webcomponents.org/introduction"},"insert":"Введение в web components"},{"insert":"."},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://developers.google.com/web/fundamentals/primers/modules"},"insert":"Using JavaScript modules on the web"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://developers.google.com/web/updates/2017/11/dynamic-import"},"insert":"Dynamic import()"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://caniuse.com/#feat=es6-module"},"insert":"caniuse [JavaScript modules via script tag]"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://caniuse.com/#feat=es6-module-dynamic-import"},"insert":"caniuse [JavaScript modules: dynamic import()]"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://gist.github.com/ebidel/3201b36f59f26525eb606663f7b487d0"},"insert":"gist - feature_detect_es_modules.js"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://github.com/uupaa/dynamic-import-polyfill"},"insert":"dynamic-import-polyfill"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://hospodarets.com/native-ecmascript-modules-dynamic-import"},"insert":"Native ECMAScript modules: dynamic import()"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://html.spec.whatwg.org/multipage/scripting.html#attr-script-type"},"insert":"html.spec.whatwg ''script'' tag"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction"},"insert":"AsyncFunction"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://basarat.gitbooks.io/typescript/docs/project/dynamic-import-expressions.html"},"insert":"Dynamic import expressions"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://webpack.js.org/api/module-methods/#magic-comments"},"insert":"Webpack Magic Comments"},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\nNetwork layer"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://www.apollographql.com/docs/angular/basics/network-layer/#linkMiddleware"},"insert":"Apollo link - Middleware"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://github.com/apollographql/react-apollo/issues/2059"},"insert":"Pass `extensions` to the client"},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\n\nСсылки Angular"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://angular.io/api/core/Directive"},"insert":"Directive в Angular"},{"insert":", "},{"attributes":{"link":"https://www.sitepoint.com/practical-guide-angular-directives/"},"insert":"структурные и атрибутные директивы"},{"insert":"."},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://stackoverflow.com/questions/39357195/angular-2-dynamically-insert-a-component-into-a-specific-dom-node-without-using"},"insert":"Angular 2 Dynamically insert a component into a specific DOM node without using ViewContainerRef"},{"insert":"."},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://blog.angularindepth.com/exploring-angular-dom-abstractions-80b3ebcfc02"},"insert":"Exploring Angular DOM manipulation techniques using ViewContainerRef"},{"insert":"."},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://www.agiratech.com/dynamic-import-expressions-in-angular-using-typescript/"},"insert":"Dynamic Import Expressions In Angular Using TypeScript"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://angular.io/api/core/Injector"},"insert":"Injectorlink"},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\nRxJS"},{"attributes":{"blockHeader":true},"insert":"\n"},{"attributes":{"link":"https://rxjs-dev.firebaseapp.com/api/index/function/throwError"},"insert":"throwError"},{"insert":", "},{"attributes":{"link":"https://www.learnrxjs.io/operators/creation/throw.html"},"insert":"throw"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://rxjs.dev/api/operators/mergeMap"},"insert":"mergeMap"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"http://stepansuvorov.com/blog/2017/03/rxjs-6-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2-%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B5-%D0%B2%D1%8B-%D0%B4%D0%BE%D0%BB%D0%B6%D0%BD%D1%8B-%D0%B7%D0%BD%D0%B0%D1%82%D1%8C/"},"insert":"Rxjs: 6 операторов, которые вы должны знать"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://blog.angularindepth.com/learn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511"},"insert":"Learn to combine RxJs sequences with super intuitive interactive diagrams"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://www.learnrxjs.io/operators/creation/fromevent.html"},"insert":"fromEvent"},{"attributes":{"list":"ordered"},"insert":"\n"},{"attributes":{"link":"https://www.learnrxjs.io/operators/utility/do.html"},"insert":"do / tap"},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('23/03/2019, 17:32:51', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"frontend в естественном виде"},{"attributes":{"blockTitle":true},"insert":"\n"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Современная разработка это целый скрытый от непосвященных мир. Программирование может быть hobby, профессией, способом заработка или всем этим вместе.\nПрограммирование - это место для героических личных подвигов и для командных достижений. Граний много, какую из них выбрать - решать вам.\nПару слов о содержании лекции. Современный процесс разработки строится поверх абстрактных инструментов, библиотек и фреймворков. Это хорошо для решения конкретных производственных задач. Не приходится писать повторяющегося кода и исключается ряд ошибок на базовом уровне. Обратной стороной медали является непонимание этих самых базовых вещей. В итоге смотришь на такого программиста, который сразу начал изучать какой-либо фреймворк и понимаешь, что его знания подобны колоссу на глиняных ногах - нет основы. \nПомните, что чем больше и сложнее абстрактный уровень, тем скорее вы столкнетесь с его ограничениями и тем сложнее будет их обходить.\nСегодня мы поговорим о наиболее гибких и не обремененных дополнительными абстракциями подходах в web разработке.\n\nПЛАН ЛЕКЦИИ"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Начнем с теории и самых базовых вещах. Web платформа и что это значит. Документоориентированная модель.\nДалее рассмотрим инструменты и перейдем к практике.\nЗаглянем в наиболее современный подход в разработке клиентских приложений и, наконец, закончим подведением итогов с ответом на вопросы (если они будут).\n"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Web платформа"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Web — система доступа к связанным между собой документам на различных компьютерах, подключённых к Интернету. Это наверное одно из первых определений платформы, и в какой-то мере оно до сих пор актуально. Давайте немного расширим и дополним это понятие, ведь современный Web состоит из множестве взаимосвязанных  приложений и сервисов.\nWeb платформа - комплексный подход к организации, реализации и поддержке Web-ресурсов.\nУчастники процесса"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Внесем немного ясности и определимся с действующими лицами. В web разработке обычно принято разделять frontend и backend.\nТермины появились в "},{"attributes":{"link":"https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%B0%D1%8F_%D0%B8%D0%BD%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%8F"},"insert":"программной инженерии"},{"insert":" вследствие развития "},{"attributes":{"link":"https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BE%D1%82%D0%B2%D0%B5%D1%82%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8"},"insert":"принципа разделения ответственности"},{"insert":" между внешним представлением и внутренней реализацией.\nBack-end для предоставления своего функционала, реализует "},{"attributes":{"link":"https://ru.wikipedia.org/wiki/API"},"insert":"API"},{"insert":", которое использует front-end. Таким образом front-end разработчику не нужно знать особенностей реализации сервера, а back-end разработчику — реализацию front-end.\nЭто общая и скорее концептуальная модель, в реальном мире всё может отличаться. К примеру, существуют реализации клиентских приложений без специального сервера, так называемые server-less решения, но сейчас не будем забивать себе этим голову.\nКто-нибудь знает главный язык frontend? А backend?\n"},{"attributes":{"italic":true},"insert":"Лучше как и обещал покажу вам старую и не очень смешную шутку. Помните, что это именно шутка и относится к ней нужно с долей иронии."},{"insert":"\nWeb API"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Идем дальше. Для нас, frontend программистов, основой Web платформы является её API. Это готовые конструкции языка программирования, позволяющие разработчику строить сложный функционал с меньшими усилиями. Они \"скрывают\" более сложный код от программиста, обеспечивая простоту использования.\nДля JavaScript на стороне клиента, в частности, существует множество API. Они не являются частью языка, а построены с помощью встроенных функций JavaScript для того, чтобы увеличить ваши возможности при написании кода. Их можно разделить на две категории:\n - "},{"attributes":{"bold":true},"insert":"API браузера - "},{"insert":"встроены в веб-браузер и способны использовать данные браузера и компьютерной среды для осуществления более сложных действий с этими данными. На самом деле, в браузере выполняется сложный низкоуровневый код (например, на C++) для подключения к устройству GPS (или любому другому устройству геолокации), получения данных и передачи их браузеру для обработки вашей программой, но, как было сказано выше, эти детали скрыты благодаря API.\n - "},{"attributes":{"bold":true},"insert":"сторонние API - "},{"insert":"не встроены в браузер по умолчанию. В данном API определён набор конструкций, осуществляющих запросы к сервисам Twitter и возвращающих определённые данные.\n\nШирокое разнообразие API в современных браузерах позволяет наделить ваше приложение большими возможностями. Достаточно посмотреть список на странице.\nИх можно разбить на несколько групп:\n"},{"attributes":{"bold":true},"insert":"API для работы с документами"},{"insert":", загруженными в браузер. Явный пример - "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model"},"insert":"DOM (Document Object Model) API"},{"insert":", позволяющий работать с HTML и CSS — создавать, удалять и изменять HTML, динамически изменять вид страницы и т.д. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"bold":true},"insert":"API, принимающие данные от сервера"},{"insert":", "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest","code":true},"insert":"XMLHttpRequest"},{"insert":" и "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API"},"insert":"Fetch API"},{"insert":". Вы также могли встретить термин "},{"attributes":{"bold":true},"insert":"Ajax"},{"insert":", описывающий эту технологию. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"bold":true},"insert":"API для работы с графикой"},{"insert":" "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API"},"insert":"Canvas"},{"insert":" и "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API"},"insert":"WebGL"},{"insert":", позволяющие программно изменять данные о пикселях, содержащиеся в элементе HTML  "},{"attributes":{"link":"https://developer.mozilla.org/ru/docs/Web/HTML/Element/canvas","code":true},"insert":"<canvas>"},{"insert":" для создания 2D и 3D изображений. Такие API часто используют в сочетании с API создания анимационных циклов (таких как "},{"attributes":{"link":"https://developer.mozilla.org/ru/docs/Web/API/Window/requestAnimationFrame","code":true},"insert":"window.requestAnimationFrame()"},{"insert":") и другими для создания постоянно меняющегося изображения на экране, как в мультфильмах или играх ."},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"bold":true,"link":"https://developer.mozilla.org/en-US/Apps/Fundamentals/Audio_and_video_delivery"},"insert":"Аудио и Видео API"},{"insert":" как "},{"attributes":{"link":"https://developer.mozilla.org/ru/docs/Web/API/HTMLMediaElement","code":true},"insert":"HTMLMediaElement"},{"insert":", "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API"},"insert":"Web Audio API"},{"insert":", и "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API"},"insert":"WebRTC"},{"insert":"."},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"bold":true},"insert":"API устройств"},{"insert":" - в основном, API для обработки и считывания данных с современных устройств удобным для работы веб-приложений образом. Уведомление пользователя о появившемся обновлении для веб-приложения с помощью системных уведомлений (см. "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Notifications_API"},"insert":"Notifications API"},{"insert":") или вибрации (см. "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API"},"insert":"Vibration API"},{"insert":")."},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"bold":true},"insert":"API хранения данных на стороне пользователя"},{"insert":" например, простое хранилище данных в формате имя/значение (name/value)  "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API"},"insert":"Web Storage API"},{"insert":" или хранилище данных в формате таблиц "},{"attributes":{"link":"https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API"},"insert":"IndexedDB API"},{"insert":"."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Диаграмма с более наглядным изображением Web API"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Здесь стоит упомянуть "},{"attributes":{"bold":true},"insert":"Консо́рциум Всеми́рной паути́ны"},{"insert":" ("},{"attributes":{"link":"https://ru.wikipedia.org/wiki/%D0%90%D0%BD%D0%B3%D0%BB%D0%B8%D0%B9%D1%81%D0%BA%D0%B8%D0%B9_%D1%8F%D0%B7%D1%8B%D0%BA"},"insert":"англ."},{"insert":" "},{"attributes":{"italic":true},"insert":"World Wide Web Consortium, "},{"attributes":{"italic":true,"bold":true},"insert":"W3C"},{"insert":") — организация, разрабатывающая и внедряющая технологические стандарты для "},{"attributes":{"link":"https://ru.wikipedia.org/wiki/%D0%92%D1%81%D0%B5%D0%BC%D0%B8%D1%80%D0%BD%D0%B0%D1%8F_%D0%9F%D0%B0%D1%83%D1%82%D0%B8%D0%BD%D0%B0"},"insert":"Всемирной паутины"},{"insert":". Основателем и главой консорциума является сэр "},{"attributes":{"link":"https://ru.wikipedia.org/wiki/%D0%91%D0%B5%D1%80%D0%BD%D0%B5%D1%80%D1%81-%D0%9B%D0%B8,_%D0%A2%D0%B8%D0%BC"},"insert":"Тимоти Джон Бернерс-Ли"},{"insert":".\n\nПорядок в DOMe"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Одной из наиболее распространенных вещей, которые вы хотите сделать при написании веб-страниц и приложений - это каким-то образом манипулировать структурой документа. Обычно это делается с помощью Document Object Model (DOM), набора API для управления разметкой HTML и стилями, которая сильно использует объект "},{"attributes":{"link":"https://developer.mozilla.org/ru/docs/Web/API/Document","code":true},"insert":"Document"},{"insert":".\nПредположим мы создали HTML страницу - это очень простая страница, содержащая элемент "},{"attributes":{"link":"https://developer.mozilla.org/ru/docs/Web/HTML/Element/section","code":true},"insert":"<section>"},{"insert":", внутри которого вы можете найти изображение, и абзац со ссылкой внутри. Исходный код HTML выглядит так:\n...\nDOM, с другой стороны, выглядит так:\n...\nВы можете видеть здесь, что каждый элемент и бит текста в документе имеют свою собственную запись в дереве - каждый из них называется "},{"attributes":{"bold":true},"insert":"узлом"},{"insert":" ("},{"attributes":{"bold":true},"insert":"node)"},{"insert":". \nКакие именно операторы и методы предоставляет нам это API мы увидим буквально через несколько минут, а пока переходим к следующему пункту - инструменты. Кто-нибудь знает самый главный инструмент frontend разработчика?\n\nНаш главный инструмент"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Это браузер. \nБра́узер, или web-обозреватель — прикладное программное обеспечение для просмотра web-страниц, содержания web-документов, компьютерных файлов и их каталогов, управления web-приложениями, "},{"attributes":{"bold":true},"insert":"а также для решения других задач"},{"insert":".\nА также для решения других задач, как много скрыто в этих нескольких словах. Да, современные браузеры перестали быть просто обозревателями для гипертекстовых страниц. Они стали полноценным окружением для приложений. Сегодня в браузере уже никого не удивляют графические редакторы или трёхмерные игры. Браузеры постепенно становятся новыми операционными системами. Посмотрите на ChromeOS, похожие попытки были и у Mozilla. Но даже самый обычный браузер сегодня может заменить большую часть десктопных приложений.\nЧто касается выбора браузера - здесь как говориться, на вкус и цвет, но Chrome везде. Да, по сути на сегодняшний день осталось три самостоятельных браузера - это Safari, Firefox и разные Chromium браузеры. Есть ещё Эдж, от Майкрософт, но компания в начале этого года заявила, что не видит смысла продолжать развивать собственный браузерный движок и следующий браузер для Windows выпустить на базе Chromium.\nПанель разработчика"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Или инспектор. Есть в каждом браузере, но законодателем здесь является хром, поэтому "},{"attributes":{"bold":true},"insert":"Chrome DevTools"},{"insert":" - набор инструментов web-разработчика, встроенных непосредственно в браузер Google Chrome. DevTools могут помочь редактировать страницу “на лету” и быстро диагностировать проблемы. \nПереходим к практике, поэтому давайте откроем браузер и посмотрим на него.\nОткрываем браузер "},{"attributes":{"link":"https://yandex.ru/"},"insert":"https://yandex.ru/"},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Открываем панель разработчика (обзор основных элементов)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Элементы DOM. "},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Получение элемента "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"document.querySelector(''a''); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Манипуляции элементам"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"link.textContent = ''Mozilla Developer Network'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"link.textContent = ''Mozilla Developer Network'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Создание и размещение"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"var sect = document.querySelector(''section'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var para = document.createElement(''p'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.textContent = ''We hope you enjoyed the ride.'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"sect.appendChild(para);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var text = document.createTextNode('' — the premier source for web development knowledge.'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"var linkPara = document.querySelector(''p'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"linkPara.appendChild(text);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Перемещение и удаление"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"sect.appendChild(linkPara);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"sect.removeChild(linkPara);"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"linkPara.parentNode.removeChild(linkPara); "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"Манипулирование стилями"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"<style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":".highlight {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  color: white;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  background-color: black;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  padding: 10px;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  width: 250px;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  text-align: center;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</style>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.style.color = ''white'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.style.backgroundColor = ''black'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.style.padding = ''10px'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.style.width = ''250px'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.style.textAlign = ''center'';"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"para.setAttribute(''class'', ''highlight'');"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"ыва"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"4. Отладка кода, точки останова.\n\nПишем код"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Для создания простейшего клиентского приложения нам понадобятся три части - разметка HTML, стили CSS и логика JS.\nДавайте попробуем это сделать\n<!DOCTYPE html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<html>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <title>Parcel Sandbox</title>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <meta charset=\"UTF-8\" />"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <link rel=\"stylesheet\" href=\"index.css\"><link> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</head>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <div id=\"app\"></div>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  <script src=\"index.js\"></script>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</body>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"</html> "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nbody {"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"  font-family: sans-serif;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"}"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nimport \"./styles.css\";"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":" "},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"document.getElementById(\"app\").innerHTML = `"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"<h1>Hello World!</h1>"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"`;"},{"attributes":{"code-block":true},"insert":"\n"},{"insert":"\nЭто подходит для примера, но для проектов серьезнее Hello World всё же удобнее писать код в IDE т.е. в специальных средах разработки. И некоторые из них умеют работать прямо в браузере, к примеру CodeSandbox или StackBlitz. Для наших целей подойдет любая из них, давайте попробуем запустить CodeSandbox.\nСоздание компонентов"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Web компоненты - набор API Web платформы, который позволяет создавать новые, переиспользуемые, инкапсулируемые HTML элементы для использования на web-страницах и в web-приложениях.\nПользовательские компоненты создаются на основе стандартов Web components, будут работать в любом современном браузере.\nМогут использоваться как вместе с JavaScript библиотеками и фреймворками, так и без них.\n"},{"attributes":{"bold":true},"insert":"Web components "},{"insert":"это четыре спецификации:\nHTML Template"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Custom Elements"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Shadow DOM"},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"ES Modules"},{"attributes":{"list":"bullet"},"insert":"\n"},{"attributes":{"italic":true},"insert":"Создаем компонент анкеты"},{"insert":"\n\nИтоги"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Сегодня вы познакомились с базовыми элементами Web платформы. Узнали про Web API и теперь представляете что это и зачем нужно. Остальное можно загуглить. \nРассмотрели инструменты frontend разработчика, узнали как управлять DOM. Создали свой HTML элемент с помощью Web components.\nДумаю теперь вы точно знаете, что писать web приложение можно из дополнительных средств, всё что вам нужно - это браузер и знания его API.\nВопросы?\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('17/03/2019, 13:42:31', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Разделение frontend и backend, с сохранением взаимопонимания"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Независимый frontend и backend"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Несколько лет назад мне попалась небольшая статья в журнале, ученый рассказывал о процессе обучения. Отмечалось, что для полноценного получения знаний нужно всё больше и больше времени, а в недалеком будущем этот процесс может быть равен 80-ти годам жизни. Видимо, в IT это будущее уже настало.\nМне посчастливилось, я начинал программировать в те годы, когда не было разделение на backend и frontend программистов, когда не звучали слова UX, прототип, QA и продуктолог. Мир был проще, деревья были выше и зеленее, воздух чище, а во дворах играли дети, а не парковались автомобили. Как бы мне ни хотелось вернуться в те годы, нужно признать, что всё это не замысел какого-то суперзлодея, а ход эволюционного развития общества. Да, общество могло начать развиваться и иначе, но как говорится история не терпит сослагательных наклонений. \nПредыстория"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Продукт над которым работает наша команда тоже появился в те далекие годы, когда не было жесткого разделения по направлениям. Он имел неплохую согласованную архитектуру, умел хорошо управлять поведением пользователя и даже позволял расширять себя с помощью системы плагинов. Шло время, команда развивала продукт и вроде бы всё было хорошо, но стали прослеживаться странные явления. К примеру, когда программист занимался бизнес логикой, он как-то плохо начинал верстать формы, делал их неудобными и сложными для восприятия. Или, добавление, казалось бы простой функциональности оценивалось на несколько недель так как изначально жестко связанная архитектура отдельных модулей плохо подходила под изменение одного без корректировок в другом.\nПро вопросы удобства, эргономики и глобального развития продукта вообще можно было забыть в моменты падения приложения с неизвестной ошибкой. Всё как у всех, когда продукт сравнительно небольшой и общие требования не столь высоки один программист успевал делать работу в разных направлениях. Когда же требования в каждом из этих направлений сильно возросли, а ты видишь картину в целом и прекрасно понимаешь, что если функция не будет правильно и стабильно работать, то все эти кнопочки, формочки, тесты, презентации и продвижения ничем не помогут. В итоге откладываешь всё вокруг и садишься за исправление работы этой злосчастной функции. После этого ты совершаешь свой маленький подвиг пусть он и останется никем неоцененным, но функция начинает работать. Собственно, как-то так и появились в нашей команде люди, ответственные за разные направления, чтобы эти маленькие подвиги дошли до клиентов, которым они действительно нужны.\nНо изменение в составе команды было только первым шагом.  Использование одного технически сильно связанного приложения приводило к невозможности развивать продукт требуемыми темпами и периодически отражалось в \"перетягивании одеяла\" в разработке. Современный интерфейс часто модифицируется под нужды клиентов, что приводит к постоянным изменениям в структуре отображаемых данных. У нас это вело к необходимости менять логику backend''а, хотя структура самих данных чаще всего оставалась неизменной.\nFrontend и backend"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Стать профессионалом во всём долго и дорого. Поэтому современный мир прикладных программистов делится, в основной своей массе, на frontend и backend. Здесь вроде всё понятно: набираем frontend программистов, они теперь у нас будут отвечать за пользовательский интерфейс. У backend тоже всё хорошо: наконец они могут сфокусироваться на бизнес логике, моделях данных и других подкапотных вещах. При этом стоит отметить, что по сути backend, frontend, тестировщики и дизайнеры остаются единой командой. Они делают общий продукт, просто фокусируются на разных его частях. Под одной командой имею ввиду, что у них одно информационное и, желательно, территориальное пространство. То есть вместе обсуждают новые фичи и разбирают проделанную работу, согласовывают порядок совместных действий над одной задачей. У них одна цель и все это понимают.\nДля какого-то абстрактного нового проекта на этом можно закончить, но у нас уже было написанное приложение и одна команда, а объемы планируемых работ и сроки их реализации явно указывали, что одной единой командой обойтись не получится. В футболе команда из 11 человек, в баскетболе из 5-ти, а у нас получалось, что будет команда из 30 участников. Под идеальную scrum команду из 5-9 человек это никак не подходило.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1554174759/blob_b1sj1n.png"}}},{"insert":"Чтобы сдвинуться с места нужно было решить организационную и архитектурную проблему. \nАрхитектура"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Полностью убрать старое и писать новое - это хорошее решение, если есть адекватное и прогнозируемое время такой работы. В нашем случае даже при идеальных условиях приблизительный срок составлял годы. Помимо этого, специфика приложения такова, что для конечного потребителя было бы крайне сложно перейти со старого на новое при полном их различии. Нашим клиентам очень важна обратная совместимость. Её потеря и последующий отказ пользователей переходить на новую версию ставит под сомнение целесообразность такой работы. Было решено, что нужна модернизация архитектуры с сохранением максимальной обратной совместимости. \nКак уже отмечалось ранее, наше приложение - это монолит, интерфейс которого строился на стороне сервера. Frontend только реализовывал полученные от него инструкции. Иными словами, за интерфейс пользователя отвечал не frontend, а backend. Архитектурно frontend и backend работали как одно целое - изменяя одно, были вынуждены менять другое. И это не самое страшное, наибольшей проблемой стала невозможность разработки пользовательского интерфейса без глубинных знаний того, что происходит на сервере. \nНужно было разделять frontend и backend, делать отдельные программные приложения, только так можно было начать развивать их требуемыми темпами и объемами. Но как делать хотя бы два проекта параллельно, сильно менять их структуру, если они сильно зависят друг от друга?  Решением стала дополнительная система - прослойка. Идея прослойки крайне проста - согласовать работы backend и frontend и взять на себя все дополнительные издержки. \n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1554174888/blob_c5inrf.png"}}},{"insert":"К примеру, если происходит декомпозиция функции оплаты на стороне backend, то прослойка начинает их комбинировать, а на стороне frontend никаких дополнительных изменений не требуется. Другой пример, это когда на дашборде в пользовательском интерфейсе вместе с информацией о пользователе захотели выводить все заказанные им услуги, то не делать дополнительную функцию для этого на backend, а агрегировать данные в прослойке. Помимо этого прослойка должна была добавить определенности в том, что можно позвать у сервера и что в итоге вернется без знания внутреннего устройства функций, которые эту операцию исполняют.\nКоммуникации"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Технически сильная зависимость между frontend и backend приводит к невозможности делать работу параллельно, и тем самым тормозит обе части команды. Разделив программно один большой проект на несколько мы получали свободу действий в каждом из них, но при этом сильно возросли требования к коммуникациям. Нужно было сохранить согласованность в работе. Кто-то скажет, что согласованность достигают с помощью повышения soft skills. Да, их нужно развивать, но это не панацея. К примеру, посмотрите на дорожное движение, там тоже важно, чтобы водители были взаимовежливы, умели объезжать случайные препятствия и помогали друг другу на дороге в сложных ситуациях. Но! Без правил дорожного движения мы, даже при наилучших коммуникациях, получили бы аварии на каждом перекрестке и огромные риски не доехать до пункта назначения в запланированное время.\nНам нужны были правила, которые было бы сложно нарушить. Как говорится, чтобы их было проще исполнять, чем не исполнять. Но любые законы помимо плюсов всегда несут накладные расходы, а нам очень не хотелось втягивать всех и сразу в этот процесс и тем самым тормозить основную работу. Из этих соображений родилась координационная группа, а потом и команда. По сути основной целью этой команды стало создание условий для успешной работы разных частей продукта. Они настроили интерфейсы, которые позволили разным проектам работать как одно целое. Сегодня мы называем эту команду API, хотя непосредственно техническая реализация нового API - это только малая часть их задач. Как и в коде, общие участки выносятся в отдельную функцию, так и команда API разбирает общие вопросы продуктовых команд. Именно здесь происходит соединение нашего frontend и backend, и чтобы всё прошло успешно нужно понимать специфику каждой из частей. \nВозможно, название API и не самое хорошее, оно родилось из первых задач команды, сейчас больше подошло бы название говорящее, за архитектуру или масштабное видение. Думаю, что это мелочи и сути бы не изменило.\nAPI"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Интерфейс доступа к функциям на сервере существовал и в нашем начальном большом монолитном приложении, но выглядел достаточно хаотично с точки зрения потребителя. При разделении frontend и backend нужно было больше определенности.\nЦели для нового API сформировались сами собой из наших ежедневных трудностей в реализации новых продуктовых и дизайнерских идей:\nСлабая связанность компонентов системы. Параллельное развитие frontend и backend."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Высокая масштабируемость. Иными словами, новое API не должно стать для нас препятствием в наращивании функциональности."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Стабильность и согласованность."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Весь research по API начали не с backend, как это обычно принято, а наоборот - подумали, что нужно пользователям нашего API. Понятно, что наиболее распространены решения в виде разного рода REST API. В последние годы к ним добавляют описательные модели через инструменты типо swagger, но нужно понимать, что это тот же REST. И по сути, самым главным его плюсом и минусом являются правила, которые носят исключительно описательный характер. Это значит, что никто не запрещает создателю такого API отклоняться от постулатов REST в ходе реализации отдельных частей. Другим распространенным решением является GraphQL и, хотя, он тоже не идеален, но в отличие от REST, GraphQL API это не просто описательная модель, а настоящие правила.\nВыше я говорил про систему, которая должна была согласовывать работу frontend и backend. Прослойка (interlayer) - это именно тот промежуточный уровень. Рассмотрев возможные варианты работы с сервером мы остановились на GraphQL в качестве API для frontend. Но, так как наш backend на C++, то реализация GraphQL сервера оказалось нетривиальной задачей. Не буду здесь описывать все возникшие сложности и ухищрения, на которые мы шли, реального результата они не принесли. В итоге, посмотрели на проблему с другой стороны и решили, что простота - это залог успеха. Поэтому остановились на проверенных решениях в виде отдельного Node.js сервера с Express.js и Apollo Server.\nДалее нужно было решить как обращаться к API backend''а. Сначала смотрели в сторону поднятия REST API, потом пробовали использовать аддоны на C++ для Node.js. В итоге поняли, что это всё нам не подходит и после подробного анализа выбрали API на базе gRPC сервисов.\nСобрав воедино полученный опыт использования C++, TypesSript, GraphQL и gRPC мы получили архитектуру приложения, позволяющую гибко развивать backend и frontend, продолжая при этом создавать единый программный продукт.\nКак результат, получилась схема, где frontend общается с промежуточным сервером с помощью GraphQL запросов (знает, что спросить и что получит в ответ). GraphQL сервер в резолверах вызывает API функции gRPC сервера, при этом для связи они используют Protobuf схемы. API сервер на базе gRPC знает у какого микросервиса взять данные или кому передать полученный запрос. Сами микросервисы при этом построены также на gRPC, что обеспечивает скорость обработки запросов, типизацию данных и возможность использования различных языков программирования для их разработки.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1553042495/blob_oxima9.png"}}},{"insert":"Есть у этого подхода и ряд минусов, основным из них является дополнительная работа по настройке и согласованию схем, а также написанию вспомогательных функций. Но с увеличением количества потребителей API эти затраты окупаются.\nЗаключение"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Мы пошли эволюционным путем развития продукта и команды, что достаточно необычно в рамках нашей компании. Достигли успеха или затея обернулась провалом, наверное, судить рано. Можно подвести промежуточные итоги того, что уже есть:\nЗа отображение отвечает frontend, а за данные backend. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"На frontend сохранилась гибкость в плане запросов и получения данных. Интерфейс знает, что можно попросить у сервера и какие ответы должны быть. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"На backend появилась возможность изменения кода с уверенностью, что интерфейс у пользователя продолжит работать. Стал возможным переход на микросервисную архитектуру без необходимости сразу же переделывать весь frontend. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Появилась возможность использования mock данных для frontend, когда еще не готов backend. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Создание схем для совместной работы исключили проблемы взаимодействия, когда команды понимали одну и ту же задачу по разному. Сократилось количество итераций по переделке форматов данных - действуем по принципу \"Семь раз отмерь, один раз отрежь\". "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Возможность параллельного планирования работ на спринт. "},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Возможность набора разработчиков не знакомых с C++ для реализации отдельных микросервисов."},{"attributes":{"list":"bullet"},"insert":"\n"},{"insert":"Статья получилась обзорной и очень общей. Ее целью было показать путь и результаты сложной исследовательской работы на тему как же с технической точки зрения менять архитектуру для дальнейшего развития продукта, а также продемонстрировать организационные сложности деления команды на согласованные части.\nЗдесь я поверхностно затронул вопросы командной и межкомандной работы над одним продуктом, выбор технологи API (REST vs GraphQL), связь Node.js приложения с C++ и т.д. Каждая из этих тем тянет на отдельную статью и если вам будет интересно, то мы их обязательно напишем.\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('03/03/2019, 12:27:10', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Разделение frontend и backend, с сохранением взаимопонимания"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Независимый frontend и backend"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Несколько лет назад мне попалась небольшая статья в журнале, ученый рассказывал о процессе обучения. Отмечалось, что для полноценного получения знаний нужно всё больше и больше времени, а в недалеком будущем этот процесс может быть равен 80-ти годам жизни. Видимо, в IT это будущее уже настало.\nМне посчастливилось, я начинал программировать в те годы, когда не было разделение на backend и frontend программистов, когда не звучали слова UX, прототип, QA и продуктолог. Мир был проще, деревья были выше и зеленее, воздух чище, а во дворах играли дети, а не парковались автомобили. Как бы мне ни хотелось вернуться в те годы, нужно признать, что всё это не замысел какого-то суперзлодея, а ход эволюционного развития общества. Да, общество могло начать развиваться и иначе, но как говорится история не терпит сослагательных наклонений. \nПредыстория"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Продукт над которым работает наша команда тоже появился в те далекие годы, когда не было жесткого разделения по направлениям. Он имел неплохую согласованную архитектуру, умел хорошо управлять поведением пользователя и даже позволял расширять себя с помощью системы плагинов. Шло время, команда развивала продукт и вроде бы всё было хорошо, но стали прослеживаться странные явления. К примеру, когда программист занимался бизнес логикой, он как-то плохо начинал верстать формы, делал их неудобными и сложными для восприятия. Или, добавление, казалось бы простой функциональности оценивалось на несколько недель так как изначально жестко связанная архитектура отдельных модулей плохо подходила под изменение одного без корректировок в другом.\nПро вопросы удобства, эргономики и глобального развития продукта вообще можно было забыть в моменты падения приложения с неизвестной ошибкой. Всё как у всех, когда продукт сравнительно небольшой и общие требования не столь высоки один программист успевал делать работу в разных направлениях. Когда же требования в каждом из этих направлений сильно возросли, а ты видишь картину в целом и прекрасно понимаешь, что если функция не будет правильно и стабильно работать, то все эти кнопочки, формочки, тесты, презентации и продвижения ничем не помогут. В итоге откладываешь всё вокруг и садишься за исправление работы этой злосчастной функции. После этого ты "},{"attributes":{"bold":true},"insert":"совершаешь"},{"insert":" свой маленький подвиг пусть он и останется никем неоцененным, но функция начинает работать. Собственно, как-то так и появились в нашей команде люди, ответственные за разные направления, чтобы эти маленькие подвиги дошли до клиентов, которым они действительно нужны.\nНо изменение в составе команды было только первым шагом.  Использование одного технически сильно связанного приложения приводило к невозможности развивать продукт требуемыми темпами и периодически отражалось в \"перетягивании одеяла\" в разработке. Современный интерфейс часто модифицируется под нужды клиентов, что приводит к постоянным изменениям в структуре отображаемых данных. У нас это вело к необходимости менять логику backend''а, хотя структура самих данных чаще всего оставалась неизменной.\nFrontend и backend"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Стать профессионалом во всём долго и дорого. Поэтому современный мир прикладных программистов делится, в основной своей массе, на frontend и backend. Здесь вроде всё понятно: набираем frontend программистов, они теперь у нас будут отвечать за пользовательский интерфейс. У backend тоже всё хорошо: наконец они могут сфокусироваться на бизнес логике, моделях данных и других подкапотных вещах. При этом стоит отметить, что по сути backend, frontend, тестировщики и дизайнеры остаются единой командой. Они делают общий продукт, просто фокусируются на разных его частях. Под одной командой имею ввиду, что у них одно информационное и, желательно, территориальное пространство. То есть вместе обсуждают новые фичи и разбирают проделанную работу, согласовывают порядок совместных действий над одной задачей. У них одна цель и все это понимают.\nДля какого-то абстрактного нового проекта на этом можно закончить, но у нас уже было написанное приложение и одна команда, а объемы планируемых работ и сроки их реализации явно указывали, что одной единой командой обойтись не получится. В футболе команда из 11 человек, в баскетболе из 5-ти, а у нас получалось, что будет команда из 30 участников. Под идеальную scrum команду из 5-9 человек это никак не подходило.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1554174759/blob_b1sj1n.png"}}},{"attributes":{"bold":true},"insert":"Чтобы сдвинуться с места нужно было решить организационную и архитектурную проблему. "},{"insert":"\nАрхитектура"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Полностью убрать старое и писать новое - это хорошее решение, если есть адекватное и прогнозируемое время такой работы. В нашем случае даже при идеальных условиях приблизительный срок составлял годы. Помимо этого, специфика приложения такова, что для конечного потребителя было бы крайне сложно перейти со старого на новое при полном их различии. Нашим клиентам очень важна обратная совместимость. Её потеря и последующий отказ пользователей переходить на новую версию ставит под сомнение целесообразность такой работы. Было решено, что нужна модернизация архитектуры с сохранением максимальной обратной совместимости. \nКак уже отмечалось ранее, наше приложение - это монолит, интерфейс которого строился на стороне сервера. Frontend только реализовывал полученные от него инструкции. Иными словами, за интерфейс пользователя отвечал не frontend, а backend. Архитектурно frontend и backend работали как одно целое - изменяя одно, были вынуждены менять другое. И это не самое страшное, наибольшей проблемой стала невозможность разработки пользовательского интерфейса без глубинных знаний того, что происходит на сервере. \nНужно было разделять frontend и backend, делать отдельные программные приложения, только так можно было начать развивать их требуемыми темпами и объемами. Но как делать хотя бы два проекта параллельно, сильно менять их структуру, если они сильно зависят друг от друга?  Решением стала дополнительная система - прослойка. Идея прослойки крайне проста - согласовать работы backend и frontend и взять на себя все дополнительные издержки. \n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1554174888/blob_c5inrf.png"}}},{"insert":"К примеру, если происходит декомпозиция функции оплаты на стороне backend, то прослойка начинает их комбинировать, а на стороне frontend никаких дополнительных изменений не требуется. Другой пример, это когда на дашборде в пользовательском интерфейсе вместе с информацией о пользователе захотели выводить все заказанные им услуги, то не делать дополнительную функцию для этого на backend, а агрегировать данные в прослойке. Помимо этого прослойка должна была добавить определенности в том, что можно позвать у сервера и что в итоге вернется без знания внутреннего устройства функций, которые эту операцию исполняют.\nКоммуникации"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Технически сильная зависимость между frontend и backend приводит к невозможности делать работу параллельно, и тем самым тормозит обе части команды. Разделив программно один большой проект на несколько мы получали свободу действий в каждом из них, но при этом сильно возросли требования к коммуникациям. Нужно было сохранить согласованность в работе. Кто-то скажет, что согласованность достигают с помощью повышения soft skills. Да, их нужно развивать, но это не панацея. К примеру, посмотрите на дорожное движение, там тоже важно, чтобы водители были взаимовежливы, умели объезжать случайные препятствия и помогали друг другу на дороге в сложных ситуациях. Но! Без правил дорожного движения мы, даже при наилучших коммуникациях, получили бы аварии на каждом перекрестке и огромные риски не доехать до пункта назначения в запланированное время.\nНам нужны были правила, которые было бы сложно нарушить. Как говорится, чтобы их было проще исполнять, чем не исполнять. Но любые законы помимо плюсов всегда несут накладные расходы, а нам очень не хотелось втягивать всех и сразу в этот процесс и тем самым тормозить основную работу. Из этих соображений родилась координационная группа, а потом и команда. По сути основной целью этой команды стало создание условий для успешной работы разных частей продукта. Они настроили интерфейсы, которые позволили разным проектам работать как одно целое. Сегодня мы называем эту команду API, хотя непосредственно техническая реализация нового API - это только малая часть их задач. Как и в коде, общие участки выносятся в отдельную функцию, так и команда API разбирает общие вопросы продуктовых команд. Именно здесь происходит соединение нашего frontend и backend, и чтобы всё прошло успешно нужно понимать специфику каждой из частей. \nВозможно, название API и не самое хорошее, оно родилось из первых задач команды, сейчас больше подошло бы название говорящее, за архитектуру или масштабное видение. Думаю, что это мелочи и сути бы не изменило.\nAPI"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Интерфейс доступа к функциям на сервере существовал и в нашем начальном большом монолитном приложении, но выглядел достаточно хаотично с точки зрения потребителя. При разделении frontend и backend нужно было больше определенности.\nЦели для нового API сформировались сами собой из наших ежедневных трудностей в реализации новых продуктовых и дизайнерских идей:\nСлабая связанность компонентов системы. Параллельное развитие frontend и backend."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Высокая масштабируемость. Иными словами, новое API не должно стать для нас препятствием в наращивании функциональности."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Стабильность и согласованность."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"insert":"Весь research по API начали не с backend, как это обычно принято, а наоборот - подумали, что нужно пользователям нашего API. Понятно, что наиболее распространены решения в виде разного рода REST API. В последние годы к ним добавляют описательные модели через инструменты типо swagger, но нужно понимать, что это тот же REST. И по сути, самым главным его плюсом и минусом являются правила, которые носят исключительно описательный характер. Это значит, что никто не запрещает создателю такого API отклоняться от постулатов REST в ходе реализации отдельных частей. Другим распространенным решением является GraphQL и, хотя, он тоже не идеален, но в отличие от REST, GraphQL API это не просто описательная модель, а настоящие правила.\nВыше я говорил про систему, которая должна была согласовывать работу frontend и backend. Прослойка (interlayer) - это именно тот промежуточный уровень. Рассмотрев возможные варианты работы с сервером мы остановились на GraphQL в качестве API для frontend. Но, так как наш backend на C++, то реализация GraphQL сервера оказалось нетривиальной задачей. Не буду здесь описывать все возникшие сложности и ухищрения, на которые мы шли, реального результата они не принесли. В итоге, посмотрели на проблему с другой стороны и решили, что простота - это залог успеха. Поэтому остановились на проверенных решениях в виде отдельного Node.js сервера с Express.js и Apollo Server.\nДалее нужно было решить как обращаться к API backend''а. Сначала смотрели в сторону поднятия REST API, потом пробовали использовать аддоны на C++ для Node.js. В итоге поняли, что это всё нам не подходит и после подробного анализа выбрали API на базе gRPC сервисов.\nСобрав воедино полученный опыт использования C++, TypesSript, GraphQL и gRPC мы получили архитектуру приложения, позволяющую гибко развивать backend и frontend, продолжая при этом создавать единый программный продукт.\nКак результат, получилась схема, где frontend общается с промежуточным сервером с помощью GraphQL запросов (знает, что спросить и что получит в ответ). GraphQL сервер в резолверах вызывает API функции gRPC сервера, при этом для связи они используют Protobuf схемы. API сервер на базе gRPC знает у какого микросервиса взять данные или кому передать полученный запрос. Сами микросервисы при этом построены также на gRPC, что обеспечивает скорость обработки запросов, типизацию данных и возможность использования различных языков программирования для их разработки.\n"},{"insert":{"blockFigure":{"caption":"Архитектурная схема нового API","image":"https://res.cloudinary.com/inscriptum/image/upload/v1553042495/blob_oxima9.png"}}},{"insert":"Есть у этого подхода и ряд минусов, основным из них является дополнительная работа по настройке и согласованию схем, а также написанию вспомогательных функций. Но с увеличением количества потребителей API эти затраты окупаются.\nЗаключение"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Мы пошли эволюционным путем развития продукта и команды, что достаточно необычно в рамках нашей компании. Достигли успеха или затея обернулась провалом, наверное, судить рано. Можно подвести промежуточные итоги того, что уже есть:\nЗа отображение отвечает frontend, а за данные backend. "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"На frontend сохранилась гибкость в плане запросов и получения данных. Интерфейс знает, что можно попросить у сервера и какие ответы должны быть. "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"На backend появилась возможность изменения кода с уверенностью, что интерфейс у пользователя продолжит работать. Стал возможным переход на микросервисную архитектуру без необходимости сразу же переделывать весь frontend. "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Появилась возможность использования mock данных для frontend, когда еще не готов backend. "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Создание схем для совместной работы исключили проблемы взаимодействия, когда команды понимали одну и ту же задачу по разному. Сократилось количество итераций по переделке форматов данных - действуем по принципу \"Семь раз отмерь, один раз отрежь\". "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Возможность параллельного планирования работ на спринт. "},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Возможность набора разработчиков не знакомых с C++ для реализации отдельных микросервисов."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Статья получилась обзорной и очень общей. Ее целью было показать путь и результаты сложной исследовательской работы на тему как же с технической точки зрения менять архитектуру для дальнейшего развития продукта, а также продемонстрировать организационные сложности деления команды на согласованные части.\nЗдесь я поверхностно затронул вопросы командной и межкомандной работы над одним продуктом, выбор технологи API (REST vs GraphQL), связь Node.js приложения с C++ и т.д. Каждая из этих тем тянет на отдельную статью и если вам будет интересно, то мы их обязательно напишем.\n\n\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('13/02/2019, 08:14:02', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Планы развития"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"5 марта 2019"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Нужно придумать и написать общий план развития биллинга. Подумать про команду, факторы развития и деградации. Важным моментом является рассмотрение рисков. Нужен четкий план с приблизительными датами. Список целей, развитие клиентских приложений. Вопросы безопасности. Плагинам нужно будет посвятить отдельную большую часть рассказа.\n\nИсходные данные"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"Признание уникальности команды, проекта, ситуации - это всегда достаточно неоднозначная позиция. С одной стороны становится понятнее, что и как делать в будущем, можно более точно прогнозировать риски и затраты, с другой - это повод для оправданий. Таким образом можно сказать, что что-то пошло ни так не потому, что мы ошиблись, просчитались, приложили не достаточно усилий, а потому, что ситуация уникальна, мы уникальны и другие доводы в этом же роде...\nМне не хотелось бы впадать в такое состояние, но для полноты картины некоторые особенно важные аспекты биллинга упомянуть нужно.\nКомплексный продукт. Даже можно сказать эталон комплексного продукта. В современном олигархическом обществе финансовые отношения на столько запутаны, имеют такое количество нюансов, что учесть их и создать систему становится пазлом на миллиона кусочков. К этому нужно прибавить все продаваемые продукты, которые сами по себе так же являются отдельными предметными областями. Помимо этого высокая сложность заключается в множестве интеграций с другими продуктам.  Комплексность проявляется и в архитектуре приложения, которое с одной стороны сильно завязано на так называемое ядро (core), а с другой является сложно изменяемым монолитом."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Обратная совместимость. На habr есть статья, где описывается анонс 5-ой версии, стоит почитать комментарии, переход для пользователей был не простым. Поэтому для нас очень важен момент максимальной обратной совместимости. Мы не можем просто убрать старое и создать новое. Как говорится, в процессе разработки могут \"рушиться целые вселенные, рваться снаряды и происходить революции\", но клиент должен наблюдать плавное, безболезненное и ожидаемое развитие системы."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Разные клиенты. У всех клиенты разные. Но у нас на это ещё и накладывается то, что они с двух совершенно разных сегментов - администраторы биллинга и их пользователи. К сожалению, их взгляды и потребности далеко не всегда совпадают, а порой и совершенно противоречат друг другу. Нужно угодить всем."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\nЦели"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"В единоборствах есть выражение - \"смотри сквозь стену, чтобы пробить стену\". Поэтому наши цели и планы можно назвать наполеоновскими. Вначале по крупным блокам.\nОжидаемый и прогнозируемый результат по разработке (lean software development)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Более быстрый цикл выпуска (не больше 1-го спринта)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Сохранение обратной совместимости при обновлениях."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Стабильность и отказоустойчивость (уменьшение bugfix, снижение количество переоткрываемых задач)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Headless решения и плагины для максимальной гибкости."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Рассмотрим их подробнее. Далее буду приводить цели в каждом из блоков, проводимые и планируемые действия для их достижения, критерии оценки и ожидаемые сроки.\nКонцепция развития"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"Повышение профессиональных компетенций в командах биллинга. Прозрачное и удобное межкомандное взаимодействие."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Динамические клиентские приложения с системой плагинов (поставляемых из коробки) для решения широкого спектра пользовательских задач из любых категорий."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Модернизация биллинга, создание гибкой и распределенной программной системы (API, микросервисы, независимость клиентских приложений)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\nПо поводу первого из пунктов, есть предложение улучшить и закрепить более прозрачный процесс разработки фич.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1552269709/blob_yizavz.jpg"}}},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"С указанием ролей данный процесс выглядит следующим образом:\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1552280962/blob_zfezok.png"}}},{"insert":"Необходимо отметить, что стейкхолдеры присутствуют на первых трех этапах. На каждом из них проводится брейншторм для выявления рисков и учета всех нюансов.\nИспользую технику user story mapping (построение карты истории пользователя) и job to be done (JTBD) команды подходят к составлению свимлайнов в проектах YouTrack. После оценки задач в свимлайнах мы получаем достаточно точную оценку для выпуска конкретной фичи.\nСледующим предложением который тесно связан с изменением жизненного цикла является создание доски прогресса по фичам=свимлайнам.\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1552286390/blob_jlp2ao.jpg"}}},{"insert":"Наглядность и возможность смещать усилия видя перед собой всю картину является хорошим началом на пути lean development.\nКлиентские приложения"},{"attributes":{"blockSubheader":true},"insert":"\n"},{"insert":"На данный момент у нас одно клиентское приложение 5-го поколения продуктов, а так же десктопный и мобильный пользовательские интерфейсы. При этом ведется проектирование нового интерфейса для администраторов биллинга.\nВ интерфейсе 5-ки не происходит глобальных доработок механизмов его построения (не путать с 5-кой в целом), только исправление баг.\nШестой интерфейс в биллинге является наиболее старым из всех шестых интерфейсов в компании. При его создании было сломано много копий, испробовано подходов и применено технических решений. Первые пол года разработки можно смело отнести к пробе пера. Далее спустя год стало понятно, что требуется и каким образом это действительно можно реализовать. В итоге к бета релизу шестой интерфейс подошел с массой \"велосипедов\", \"костылей\" и решений которые нужно было менять и в коде и в UX.\nТехнические задачи:\nСоздание инструментария (динамические формы, таблицы, основные UI компоненты)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Перевод приложения на динамические формы и таблицы, элементы меню и другие настраиваемые элементы."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Шаринг кода (вынос общих участков, использование корпоративных библиотек)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"Стабильность и отказоустойчивость (unit и функциональные тесты)."},{"attributes":{"list":"ordered"},"insert":"\n"},{"insert":"\nПлагины"},{"attributes":{"blockHeader":true},"insert":"\n"},{"insert":"\n"},{"insert":{"blockFigure":{"caption":"","image":"https://res.cloudinary.com/inscriptum/image/upload/v1552287133/blob_smvwgk.jpg"}}},{"insert":"\n"}]}'
  );


insert into
  draft (
    "author_id",
    "created_at",
    "updated_at",
    "content"
  )
values
  (
    '83f51013-2a43-4916-89da-6027f91f1190',
    to_timestamp('04/01/2019, 01:10:26', 'DD/MM/YYYY, HH24:MI:SS'),
    to_timestamp('22/10/2019, 08:46:45', 'DD/MM/YYYY, HH24:MI:SS'),
    '{"ops":[{"insert":"Сборка и упаковка проекта"},{"attributes":{"blockTitle":true},"insert":"\n"},{"insert":"Наиболее интересным выглядит NectarJS. Тем более, что обещают производительность, как у нативных приложений. Но есть два опасения для использования:"},{"attributes":{"blockAuthor":true},"insert":"\n"},{"insert":"Наиболее интересным выглядит NectarJS. Тем более, что обещают производительность, как у нативных приложений. Но есть два опасения для использования:\nпроект находится в alpha версии;"},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"вся компиляция происходит на удаленном сервере (SAAS или CAAS - Compiler As A Service). Т.е. мы не можем повлиять на этот процесс и нет 100% гарантии, что код останется приватным."},{"attributes":{"list":{"type":"bullet","start":"null"}},"insert":"\n"},{"insert":"Ссылки\n"},{"attributes":{"link":"https://stackoverflow.com/questions/25564719/deploying-node-js-project-without-npm-on-client-side"},"insert":"Оптимизация размера node_modules"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://hackernoon.com/javascript-compilation-epoch-ebfb7b5bb664"},"insert":"Статья про компиляцию/сборку js приложений"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://github.com/Parellin-Technologies-LLC/basic-fs/wiki/pkg-vs-nexe-vs-nodec"},"insert":"Сравнение pkg vs nexe vs nodec"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://github.com/nexe/nexe"},"insert":"nexe"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://github.com/zeit/pkg"},"insert":"pkg"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"},{"attributes":{"link":"https://nectarjs.com/"},"insert":"NectarJS - компиляция js в нативный код"},{"insert":"."},{"attributes":{"list":{"type":"ordered","start":"null"}},"insert":"\n"}]}'
  );
